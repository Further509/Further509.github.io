<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>HUST-SE最优化作业</title>
    <link href="/2025/01/08/%E6%9C%80%E4%BC%98%E5%8C%96%E4%BD%9C%E4%B8%9A/"/>
    <url>/2025/01/08/%E6%9C%80%E4%BC%98%E5%8C%96%E4%BD%9C%E4%B8%9A/</url>
    
    <content type="html"><![CDATA[<h1 id="HUST-SE最优化作业"><a href="#HUST-SE最优化作业" class="headerlink" title="HUST-SE最优化作业"></a>HUST-SE最优化作业</h1><blockquote><p>HUST-SE数学建模与最优化-最优化作业-选题F（外点法，内点法，乘子法求解约束最优化问题）</p></blockquote><h2 id="外点法"><a href="#外点法" class="headerlink" title="外点法"></a>外点法</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>外点法将约束优化问题转化为一系列的无约束优化问题，通过构造带有惩罚项的目标函数逐步逼近最优解。</p><ul><li><strong>目标函数构造</strong>： 对于目标函数 $f(x)$ 和约束条件 $g_i(x)≤0,h_j(x)&#x3D;0$，构造惩罚函数：</li></ul><p>$$<br>F(x,μ)&#x3D; f(x) + \mu \left( \sum_{i&#x3D;1}^{l} \max(0, g_i(x))^2 + \sum_{j&#x3D;1}^{m} h_j(x)^2 \right)<br>$$</p><p>其中，$\mu&gt;0$ 是惩罚因子。</p><ul><li><strong>惩罚项的作用</strong>：<ul><li>当 $x$ 满足约束条件时，惩罚项为 0。</li><li>当 $x$ 不满足约束条件时，惩罚项随 $\mu$ 增大加剧目标函数的值，逼迫 $x$ 回到可行域。</li></ul></li><li><strong>迭代步骤</strong>：<ol><li>初始化 $\mu$ 和 $x$。</li><li>求解无约束问题 $\min F(x, \mu)$。</li><li>若约束条件近似满足（误差 $\epsilon$ 内），停止迭代；否则增大 $\mu$，重复步骤 2。</li></ol></li></ul><p> <strong>优缺点</strong>：</p><ul><li>优点：通用性强，可解决一般约束问题。</li><li>缺点：惩罚因子的增大可能导致数值不稳定，Hesse 矩阵病态。</li></ul><h3 id="算例描述"><a href="#算例描述" class="headerlink" title="算例描述"></a>算例描述</h3><p>$$<br>min f(x) &#x3D; \frac {x_1^2} 2 + \frac{x_2^2}6<br>$$</p><p>$$<br>s.t. x_1+x_2−1&#x3D;0<br>$$</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">from</span> scipy.optimize <span class="hljs-keyword">import</span> minimize<br><br><span class="hljs-comment"># 目标函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">objective</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> x[<span class="hljs-number">0</span>]**<span class="hljs-number">2</span> / <span class="hljs-number">2</span> + x[<span class="hljs-number">1</span>]**<span class="hljs-number">2</span> / <span class="hljs-number">6</span><br><br><span class="hljs-comment"># 惩罚函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">penalty_function</span>(<span class="hljs-params">x, mu</span>):<br>    constraint = x[<span class="hljs-number">0</span>] + x[<span class="hljs-number">1</span>] - <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> objective(x) + mu * constraint**<span class="hljs-number">2</span><br><br>mu = <span class="hljs-number">1</span>  <br>tolerance = <span class="hljs-number">1e-6</span><br>x_init = [<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>] <br>x = x_init<br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    result = minimize(<span class="hljs-keyword">lambda</span> x: penalty_function(x, mu), x)<br>    x_new = result.x<br>    <br>    <span class="hljs-comment"># 检查是否满足约束条件</span><br>    constraint_value = x_new[<span class="hljs-number">0</span>] + x_new[<span class="hljs-number">1</span>] - <span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">abs</span>(constraint_value) &lt; tolerance:<br>        <span class="hljs-keyword">break</span><br>    <br>    <span class="hljs-comment"># 增大惩罚因子</span><br>    mu *= <span class="hljs-number">10</span><br>    x = x_new<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Optimal solution:&quot;</span>, x_new)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Objective value:&quot;</span>, objective(x_new))<br><br></code></pre></td></tr></table></figure><p>求解得到</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">Optimal solution: [0.25001243 0.74998744]<br>Objective value: 0.12499996699040285<br></code></pre></td></tr></table></figure><h2 id="内点法"><a href="#内点法" class="headerlink" title="内点法"></a>内点法</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>内点法从可行域的内部出发，通过构造障碍函数（Barrier Function）避免迭代点越出可行域。</p><ul><li><p><strong>目标函数构造</strong>： 对于目标函数 $f(x)$ 和约束$g_i(x) \leq 0$，构造障碍函数：<br>$$<br>B(x, r) &#x3D; f(x) - r \sum_{i&#x3D;1}^{l} \ln(-g_i(x))<br>$$<br>其中，$r &gt; 0$ 为障碍因子。</p></li><li><p><strong>障碍项的作用</strong>：</p><ul><li>当 $x$ 接近约束边界 $g_i(x) &#x3D; 0$ 时，障碍项趋于无穷大，阻止迭代点越界。</li><li>当 $x$ 远离约束边界时，障碍项的影响较小。</li></ul></li><li><p><strong>迭代步骤</strong>：</p><ol><li>初始化 $r$ 和 $x$。</li><li>求解无约束问题 $\min B(x, r)$。</li><li>若解的精度满足要求，停止迭代；否则减小 $r$，重复步骤 2。</li></ol></li></ul><p><strong>优缺点</strong>：</p><ul><li>优点：始终在可行域内迭代，适用于非线性不等式约束问题。</li><li>缺点：只适用于不等式约束，且初始点必须在可行域内。</li></ul><h3 id="算例描述-1"><a href="#算例描述-1" class="headerlink" title="算例描述"></a>算例描述</h3><p>$$<br>min f(x) &#x3D; {x_1}  + {x_2}<br>$$</p><p>$$<br>s.t. x_1^2+x_2^2−4 \le 0<br>$$</p><h3 id="解答-1"><a href="#解答-1" class="headerlink" title="解答"></a>解答</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">from</span> scipy.optimize <span class="hljs-keyword">import</span> minimize<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">barrier_function</span>(<span class="hljs-params">x, r</span>):<br>    <span class="hljs-keyword">if</span> x[<span class="hljs-number">0</span>]**<span class="hljs-number">2</span> + x[<span class="hljs-number">1</span>]**<span class="hljs-number">2</span> &gt;= <span class="hljs-number">4</span>:<br>        <span class="hljs-keyword">return</span> np.inf<br>    <span class="hljs-keyword">return</span> x[<span class="hljs-number">0</span>] + x[<span class="hljs-number">1</span>] - r * np.log(<span class="hljs-number">4</span> - (x[<span class="hljs-number">0</span>]**<span class="hljs-number">2</span> + x[<span class="hljs-number">1</span>]**<span class="hljs-number">2</span>))<br><br>r = <span class="hljs-number">1.0</span>  <br>tolerance = <span class="hljs-number">1e-6</span><br>x_init = [<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>] <br>x = x_init<br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    result = minimize(<span class="hljs-keyword">lambda</span> x: barrier_function(x, r), x, method=<span class="hljs-string">&quot;BFGS&quot;</span>)<br>    x_new = result.x<br>    <br>    <span class="hljs-comment"># 检查终止条件</span><br>    <span class="hljs-keyword">if</span> r * (<span class="hljs-number">4</span> - (x_new[<span class="hljs-number">0</span>]**<span class="hljs-number">2</span> + x_new[<span class="hljs-number">1</span>]**<span class="hljs-number">2</span>)) &lt; tolerance:<br>        <span class="hljs-keyword">break</span><br>    <br>    <span class="hljs-comment"># 减小障碍因子</span><br>    r *= <span class="hljs-number">0.1</span><br>    x = x_new<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Optimal solution:&quot;</span>, x_new)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Objective value:&quot;</span>, x_new[<span class="hljs-number">0</span>] + x_new[<span class="hljs-number">1</span>])<br><br></code></pre></td></tr></table></figure><p>求解得到</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">Optimal solution: [-1.41416357 -1.41416357]<br>Objective value: -2.8283271340951304<br></code></pre></td></tr></table></figure><h2 id="乘子法"><a href="#乘子法" class="headerlink" title="乘子法"></a>乘子法</h2><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>乘子法结合拉格朗日乘子法和惩罚函数法的优点，通过引入拉格朗日乘子修正惩罚函数，避免惩罚因子过大导致的数值问题。</p><ul><li><p><strong>目标函数构造</strong>： 对于目标函数 $f(x)$ 和约束 $h_j(x) &#x3D; 0$，构造增广拉格朗日函数：</p><p>$$<br>F(x, \lambda, \mu) &#x3D; f(x) + \sum_{j&#x3D;1}^{m} \lambda_j h_j(x) + \frac{\mu}{2} \sum_{j&#x3D;1}^{m} h_j^2(x)<br>$$<br>其中，$\lambda$ 为拉格朗日乘子，$\mu &gt; 0$ 为惩罚因子。</p></li><li><p><strong>思想</strong>：</p><ul><li>$\lambda$ 的更新调整约束的权重，逐步逼近精确的拉格朗日乘子。</li><li>$\mu$ 保持适度即可，不必趋向无穷大。</li></ul></li><li><p><strong>迭代步骤</strong>：</p><ol><li>初始化 $\lambda$、$\mu$ 和 $x$。</li><li>求解无约束问题 $\min F(x, \lambda, \mu)$。</li><li>更新拉格朗日乘子$\lambda_{k+1} &#x3D; \lambda_k + \mu h(x_k)$。</li><li>若约束条件满足精度要求，停止迭代；否则重复步骤 2。</li></ol></li></ul><p> <strong>优缺点</strong>：</p><ul><li>优点：避免了外点法中过大的惩罚因子带来的病态问题，数值稳定性好。</li><li>缺点：实现较为复杂，需联合优化目标变量和拉格朗日乘子。</li></ul><h3 id="算例描述-2"><a href="#算例描述-2" class="headerlink" title="算例描述"></a>算例描述</h3><p>$$<br>min f(x) &#x3D; \frac {x_1^2} 2 + \frac{x_2^2}6<br>$$</p><p>$$<br>s.t. x_1+x_2−1&#x3D;0<br>$$</p><h3 id="解答-2"><a href="#解答-2" class="headerlink" title="解答"></a>解答</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> scipy.optimize <span class="hljs-keyword">import</span> minimize<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">augmented_lagrangian</span>(<span class="hljs-params">x, lmbda, mu</span>):<br>    constraint = x[<span class="hljs-number">0</span>] + x[<span class="hljs-number">1</span>] - <span class="hljs-number">1</span><br>    lagrangian = x[<span class="hljs-number">0</span>]**<span class="hljs-number">2</span> / <span class="hljs-number">2</span> + x[<span class="hljs-number">1</span>]**<span class="hljs-number">2</span> / <span class="hljs-number">6</span> + lmbda * constraint + (mu / <span class="hljs-number">2</span>) * constraint**<span class="hljs-number">2</span><br>    <span class="hljs-keyword">return</span> lagrangian<br><br>lmbda = <span class="hljs-number">0</span>  <span class="hljs-comment"># 拉格朗日乘子</span><br>mu = <span class="hljs-number">1</span>     <span class="hljs-comment"># 惩罚因子</span><br>tolerance = <span class="hljs-number">1e-6</span><br>x_init = [<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>]<br>x = x_init<br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    result = minimize(<span class="hljs-keyword">lambda</span> x: augmented_lagrangian(x, lmbda, mu), x)<br>    x_new = result.x<br>    <br>    <span class="hljs-comment"># 更新拉格朗日乘子</span><br>    constraint_value = x_new[<span class="hljs-number">0</span>] + x_new[<span class="hljs-number">1</span>] - <span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">abs</span>(constraint_value) &lt; tolerance:<br>        <span class="hljs-keyword">break</span><br>    lmbda += mu * constraint_value<br>    x = x_new<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Optimal solution:&quot;</span>, x_new)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Objective value:&quot;</span>, x_new[<span class="hljs-number">0</span>]**<span class="hljs-number">2</span> / <span class="hljs-number">2</span> + x_new[<span class="hljs-number">1</span>]**<span class="hljs-number">2</span> / <span class="hljs-number">6</span>)<br><br></code></pre></td></tr></table></figure><p>求解得到</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">Optimal solution: [0.25000199 0.749998  ]<br>Objective value: 0.12499999758157486<br></code></pre></td></tr></table></figure><p>这里求解出来的结果与外点法求解出的结果误差很小。可以验证两种方法求解结果的正确性。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在本次最优化作业中，我探讨了三种最优化方法：外点法、内点法和乘子法，并通过对特定算例的应用，深入理解了每种方法的原理和实现过程。</p><p>外点法通过引入惩罚项将约束问题转化为无约束问题，其通用性强，但需注意惩罚因子的选择以避免数值不稳定。内点法则通过障碍函数保持迭代点在可行域内，适用于不等式约束问题，但要求初始点必须在可行域内。乘子法结合了拉格朗日乘子法和惩罚函数法，通过引入拉格朗日乘子修正惩罚函数，提高了数值稳定性，但实现相对复杂。</p><p>通过编程求解，我得到了每种方法的最优解，验证了理论的正确性。这些方法各有优势和局限，选择时需根据具体问题的性质和要求来定。通过本次作业，我不仅掌握了最优化算法的理论知识，也提升了解决实际最优化问题的能力。</p>]]></content>
    
    
    <categories>
      
      <category>作业</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学建模与最优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HUST-SE数学建模与最优化考试复习</title>
    <link href="/2025/01/08/HUST-SE%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E8%80%83%E8%AF%95%E5%A4%8D%E4%B9%A0/"/>
    <url>/2025/01/08/HUST-SE%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E8%80%83%E8%AF%95%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="HUST-SE数学建模与最优化考试复习"><a href="#HUST-SE数学建模与最优化考试复习" class="headerlink" title="HUST-SE数学建模与最优化考试复习"></a>HUST-SE数学建模与最优化考试复习</h1><blockquote><p>开卷考试，简答题从书本可以找到答案。答题类似于往年题，学会举一反三。需要会解微分方程，差分方程，线性代数。</p></blockquote><h2 id="2025年真题回忆"><a href="#2025年真题回忆" class="headerlink" title="2025年真题回忆"></a>2025年真题回忆</h2><p>一. 简答题（共40分）</p><ol><li><p>数学模型按变量类型分类</p></li><li><p>什么实际问题能用线性规划模型建模</p></li><li><p>量纲分析法如何选取物理量和量纲</p></li><li><p>你从课程学习中获得了什么能力</p></li></ol><p>二. 量纲分析法（类似于原子弹爆炸）</p><p>三. 物体A在$(0,1)$，物体B在$(-1, 0)$。物体A向y轴正向跑，速度为2.物体B向着A跑，速度为2v。物体B的运动轨迹（类似于盯梢问题）</p><p>四. 线性规划题 （需要绘制坐标系求解最优解，高中难度）</p><p>五. $x_n$为满足条件的数列$a_1,a_2,…a_n$个数，条件(1) $a_i &#x3D; 0或1, i \ge 0$ (2)$n \ge 2时 a_ia_{i+1}&#x3D;0$ 。建立差分方程求$x_n$ （类似于斐波那契数列兔子问题）</p><h2 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h2><ol><li>量纲分析</li><li>微分方程</li><li>差分方程</li><li>线性规划</li></ol><h2 id="样题"><a href="#样题" class="headerlink" title="样题"></a>样题</h2><p>一. 简答题（共40分）</p><ol><li>(10分)按照对模型结构的<strong>了解程度</strong>如何对数学模型进行分类?</li><li>(10分)数学模型的<strong>评价标准</strong>如何？</li><li>(10分)建立数学模型的<strong>一般步骤</strong>有哪些?</li><li>(10分)数学模型有何<strong>特点</strong>?</li></ol><p>二. （15分）原子弹爆炸时巨大的能量从爆炸点以冲击波形式向四周传播。据分析在时刻 t 冲击波达到的半径 r 与释放能量 e ，大气密度 $\rho$ ,大气压强 p 有关（设 t &#x3D; 0时 r &#x3D; 0) 用<strong>量纲分析方法</strong>给出 r 的表达式</p><p>三.（15分）一对刚出生的小兔（一公一母) 被放到一个水草丰盛的孤岛上，2月龄及以上的每对兔子每一个月恰好繁殖一对新兔(也是一公一母），在繁殖期间没有任何兔子死去。试计算在繁殖期间的第 n 个月岛上兔子的总对数</p><p>四.（15分）在坐标平面oxy上以点A、B分别代表罪犯、警察的位置，盯梢意味着在任何时刻 t ,A、B距离保持为常数 a&gt;0 ，并且B的运动方向都是指向A的假设。更假设开始时刻，A在原点，B在（a,0)处。此后，A沿着 y 轴正方向逃跑。问题是求警察B的盯梢路径(运动轨迹)</p><p>五.（15分）有七种规格的包装箱要装到两辆铁路平板车上去，包装箱的宽和高是一样的，但厚度t（厘米)及质量w(千克)是不同的，下表给出了每种包装箱的厚度、重量及数量。每辆平板车有10.2米长的地方可用来装包装箱(像面包片那样）载重为40吨。由于当地货运的限制，对C5、C6、C7类的包装箱的总数有<br>一个特别的限制:这类箱子所占的空间（厚度)不能超过302.7厘米。把包装箱装到平板车上去使得浪费的空间最小。试建立数学模型(不求解)</p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/Screenshot_2025-01-02-12-31-17-87_8b7aa5be40a89c6.jpg" alt="表格"></p>]]></content>
    
    
    <categories>
      
      <category>考试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学建模与最优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HUST校园卡消费年终总结</title>
    <link href="/2024/12/28/HUST-Annual-Eat/"/>
    <url>/2024/12/28/HUST-Annual-Eat/</url>
    
    <content type="html"><![CDATA[<h1 id="HUST校园卡消费年终总结"><a href="#HUST校园卡消费年终总结" class="headerlink" title="HUST校园卡消费年终总结"></a>HUST校园卡消费年终总结</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>HUST校园卡消费年终总结是一个基于Python的脚本，旨在帮助用户分析和汇总其在HUST（华中科技大学）校园卡上的消费记录。</p><p>本项目参考<a href="https://github.com/leverimmy/THU-Annual-Eat">THU-Annual-Eat</a>，<a href="https://github.com/wangerforcs/XJTU-Annual-Eat">XJTU-Annual-Eat</a>，感谢原作者的贡献。</p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/Figure_1.png"></p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><ul><li><p>Python环境（建议使用Python 3.6及以上版本），在终端安装如下库。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install requests matplotlib<br></code></pre></td></tr></table></figure></li></ul><h3 id="获取账号和JSESSIONID"><a href="#获取账号和JSESSIONID" class="headerlink" title="获取账号和JSESSIONID"></a>获取账号和JSESSIONID</h3><p>登录企业微信-华中大微校园</p><p>在校园卡账户信息获取校园卡账号<code>account</code></p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/9a2258a759e80a2a57f4b41ff205e5e7.png" alt="校园卡账号"></p><p>使用浏览器打开进入流水查询在网址处获取<code>JSESSIONID</code>(过一段时间会发生变化)</p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/0f1a5a5b4ed17c716bb34f930df04e48.png" alt="JSESSIONID"></p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python main.py<br></code></pre></td></tr></table></figure><p>输入<code>account</code>和<code>JSESSIONID</code></p><p>等待绘制结果</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>项目仅简单实现了可视化年终消费情况的功能，但可扩展性强。网络请求返回结果还可以用于其他统计分析。感兴趣的同学可以扩展此项目的功能。</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> json<br><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> defaultdict<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>plt.rcParams[<span class="hljs-string">&quot;font.sans-serif&quot;</span>]=[<span class="hljs-string">&quot;SimHei&quot;</span>] <span class="hljs-comment">#设置字体</span><br>plt.rcParams[<span class="hljs-string">&quot;axes.unicode_minus&quot;</span>]=<span class="hljs-literal">False</span> <span class="hljs-comment">#该语句解决图像中的“-”负号的乱码问题</span><br><br>account = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入你的账户号（学号/工号）：&quot;</span>)<br>JSESSIONID = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入你的JSESSIONID：&quot;</span>)<br><br>url_template = <span class="hljs-string">&quot;http://ecard.m.hust.edu.cn/wechat-web/QueryController/select.html?jsoncallback=jQuery21402777983544074327_1735390337447&amp;account=&#123;account&#125;&amp;curpage=&#123;page&#125;&amp;dateStatus=&#123;date&#125;&amp;typeStatus=2&amp;_=1735390337442&quot;</span><br>cookie = &#123;<br>    <span class="hljs-string">&quot;JSESSIONID&quot;</span>: JSESSIONID,<br>&#125;<br>data_list = []  <br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_data</span>(<span class="hljs-params">account, date, url_template, cookie</span>):<br>    <span class="hljs-keyword">global</span> data_list<br>    <span class="hljs-comment"># 获取第一页数据</span><br>    curpage = <span class="hljs-number">1</span><br>    response = requests.get(url_template.<span class="hljs-built_in">format</span>(account = account, page=curpage,date = date), cookies=cookie)<br>    response_text = response.text.strip(<span class="hljs-string">&quot;callJson(&quot;</span>).rstrip(<span class="hljs-string">&quot;)&quot;</span>)<br>    data = json.loads(response_text)<br><br>    <span class="hljs-comment"># 检查是否有数据</span><br>    <span class="hljs-keyword">if</span> data[<span class="hljs-string">&#x27;retcode&#x27;</span>] == <span class="hljs-string">&#x27;0&#x27;</span>:<br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            <span class="hljs-comment"># 提取当前页的数据</span><br>            <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> data[<span class="hljs-string">&#x27;consume&#x27;</span>]:<br>                data_list.append(&#123;<br>                    <span class="hljs-string">&#x27;mercname&#x27;</span>: item[<span class="hljs-string">&#x27;mercname&#x27;</span>],<br>                    <span class="hljs-string">&#x27;tranamt&#x27;</span>: item[<span class="hljs-string">&#x27;tranamt&#x27;</span>]<br>                &#125;)<br>            <br>            <span class="hljs-comment"># 检查是否有下一页</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">int</span>(data[<span class="hljs-string">&#x27;nextpage&#x27;</span>]) &lt;= curpage:  <span class="hljs-comment"># 如果下一页编号小于等于当前页，则结束循环</span><br>                <span class="hljs-keyword">break</span><br>            curpage = <span class="hljs-built_in">int</span>(data[<span class="hljs-string">&#x27;nextpage&#x27;</span>])  <span class="hljs-comment"># 更新当前页编号</span><br>            response = requests.get(url_template.<span class="hljs-built_in">format</span>(account=account, page=curpage, date = date), cookies=cookie)<br>            response_text = response.text.strip(<span class="hljs-string">&quot;callJson(&quot;</span>).rstrip(<span class="hljs-string">&quot;)&quot;</span>)<br>            data = json.loads(response_text)<br>            <br>            <span class="hljs-comment"># 检查返回状态</span><br>            <span class="hljs-keyword">if</span> data[<span class="hljs-string">&#x27;retcode&#x27;</span>] != <span class="hljs-string">&#x27;0&#x27;</span>:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Failed to retrieve data:&quot;</span>, data[<span class="hljs-string">&#x27;errmsg&#x27;</span>])<br>                <span class="hljs-keyword">break</span><br><br><span class="hljs-comment"># 2024年年终总结</span><br>date_list = [<span class="hljs-string">&#x27;2024-01-01&#x27;</span>,<span class="hljs-string">&#x27;2023-02-01&#x27;</span>,<span class="hljs-string">&#x27;2024-03-01&#x27;</span>,<span class="hljs-string">&#x27;2024-04-01&#x27;</span>,<span class="hljs-string">&#x27;2024-05-01&#x27;</span>,<span class="hljs-string">&#x27;2024-06-01&#x27;</span>,<span class="hljs-string">&#x27;2024-07-01&#x27;</span>,<span class="hljs-string">&#x27;2024-08-01&#x27;</span>,<span class="hljs-string">&#x27;2024-09-01&#x27;</span>,<span class="hljs-string">&#x27;2024-10-01&#x27;</span>,<span class="hljs-string">&#x27;2024-11-01&#x27;</span>,<span class="hljs-string">&#x27;2024-12-01&#x27;</span>]<br><br><span class="hljs-keyword">for</span> date <span class="hljs-keyword">in</span> date_list:<br>    get_data(account, date, url_template, cookie)<br>    <br><span class="hljs-comment"># 使用defaultdict来存储相同mercname的tranamt总和</span><br>tranamt_sum = defaultdict(<span class="hljs-built_in">float</span>)<br><br><span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> data_list:<br>    tranamt_sum[item[<span class="hljs-string">&#x27;mercname&#x27;</span>]] += <span class="hljs-built_in">int</span>(item[<span class="hljs-string">&#x27;tranamt&#x27;</span>])/<span class="hljs-number">100</span><br><br>sorted_tranamt = <span class="hljs-built_in">sorted</span>(tranamt_sum.items(), key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-number">1</span>], reverse=<span class="hljs-literal">True</span>)<br>mercnames, amounts = <span class="hljs-built_in">zip</span>(*sorted_tranamt)<br><br>plt.figure(figsize=(<span class="hljs-number">16</span>, <span class="hljs-number">9</span>))<br>plt.bar(mercnames, amounts, color=<span class="hljs-string">&#x27;skyblue&#x27;</span>) <br>plt.xlabel(<span class="hljs-string">&#x27;商户名称&#x27;</span>) <br>plt.ylabel(<span class="hljs-string">&#x27;总交易金额&#x27;</span>)  <br>plt.title(<span class="hljs-string">&#x27;各商户总交易金额&#x27;</span>)  <br>plt.xticks(rotation=<span class="hljs-number">45</span>, ha=<span class="hljs-string">&#x27;right&#x27;</span>) <br>plt.tight_layout() <br>plt.show() <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HUST-Annual-Eat</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>15数码问题求解算法及性能比较</title>
    <link href="/2024/12/20/15%20%E6%95%B0%E7%A0%81%E9%97%AE%E9%A2%98%E6%B1%82%E8%A7%A3%E7%AE%97%E6%B3%95%E5%8F%8A%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83/"/>
    <url>/2024/12/20/15%20%E6%95%B0%E7%A0%81%E9%97%AE%E9%A2%98%E6%B1%82%E8%A7%A3%E7%AE%97%E6%B3%95%E5%8F%8A%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83/</url>
    
    <content type="html"><![CDATA[<h1 id="15-数码问题求解算法及性能比较"><a href="#15-数码问题求解算法及性能比较" class="headerlink" title="15 数码问题求解算法及性能比较"></a>15 数码问题求解算法及性能比较</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>本研究旨在探讨和比较不同求解算法及其启发式函数在解决 15 数码问题时的性能表现。15 数码问题是一个经典的益智游戏，涉及在一个 4x4 网格中通过移动方块达到有序布局。实验的核心是 A* 搜索算法，结合多种启发式函数（海明距离、棋盘距离、曼哈顿距离和欧几里得距离）进行性能评估。实验结果表明，曼哈顿距离和棋盘距离在求解时间和步数上表现优异，而海明距离则效率较低。研究还发现，问题的初始状态与目标状态之间的距离直接影响求解时间和步数。基于实验结果，提出改进建议，包括启发式函数的优化、算法适应性的增强以及并行计算的应用，以提升 15 数码问题求解算法的效率和适用性。</p><h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1.引言"></a>1.引言</h2><p>15 数码问题是一个经典的益智游戏，起源于 19 世纪末。它由一个 4x4 的网格组成，包含 15 个标有数字的方块和一个空白位置。目标是通过移动方块（只能与空白位置相邻的方块交换位置）将初始的随机布局转变为有序的目标布局。这个问题不仅因其娱乐性而受到欢迎，也因其在计算机科学和人工智能领域的研究价值而备受关注。</p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241216113926905.png" alt="15数码问题"></p><center>    图1 15数码问题</center><p>15 数码问题的研究意义在于它提供了一个理想的平台来探索和比较不同的搜索算法和启发式函数。由于其状态空间巨大（<code>16!</code> 种可能的布局），但又足够小以允许在合理的时间内进行搜索，因此它成为了评估算法性能的理想测试案例。此外，15 数码问题的求解过程涉及到路径搜索、启发式评估和状态空间表示等关键技术，这些技术在许多其他领域（如机器人路径规划、游戏AI等）中也有广泛应用。</p><p>本实验的目的是研究和比较不同的求解方法在解决 15 数码问题时的性能表现。我们将实现并分析多种启发式搜索算法，特别是 A* 算法，并探讨不同启发式函数对算法性能的影响。实验内容包括：设计和实现 15 数码问题的状态表示方法、生成初始状态、实现搜索算法及其启发式函数，并通过实验案例来评估这些算法的效率和有效性。通过这些研究，我希望深入理解启发式搜索算法的工作原理及其在实际问题中的应用潜力。</p><h2 id="2-问题的表示和求解算法"><a href="#2-问题的表示和求解算法" class="headerlink" title="2. 问题的表示和求解算法"></a>2. 问题的表示和求解算法</h2><p><strong>15 数码问题的状态表示方法</strong></p><p>15 数码问题的状态表示是求解算法的基础。在一个 4x4 的网格中，有 15 个标有数字的方块和一个空白位置。状态表示需要捕捉每个方块的位置以及空白位置。以下是状态表示的详细方法：</p><ol><li><strong>字符串表示</strong>：<ul><li>使用一个长度为 16 的字符串来表示整个网格的状态。每个字符代表一个方块或空白位置。</li><li>数字方块用字符 ‘a’ 到 ‘p’ 表示，分别对应数字 0 到 15。</li><li>空白位置用特定字符（如 ‘a’）表示。</li></ul></li><li><strong>字符映射</strong>：<ul><li>使用一个映射表 <code>unordered_map&lt;int, char&gt; h</code> 将数字映射到字符，方便状态表示和处理。</li></ul></li><li><strong>目标状态</strong>：<ul><li>目标状态是一个特定的字符串，表示所有方块按顺序排列的状态（例如 “bcdefghijklmnop”）。</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> ha[<span class="hljs-number">16</span>] = &#123;<span class="hljs-number">15</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>&#125;; <span class="hljs-comment">// 每个数字的目标位置映射 如0-&gt;15, 1-&gt;0</span><br><span class="hljs-type">int</span> num[<span class="hljs-number">16</span>];                      <span class="hljs-comment">// 初始状态，存储输入的 16 个数字</span><br></code></pre></td></tr></table></figure><p><strong>15 数码问题的求解算法</strong></p><p>求解 15 数码问题的核心是搜索算法和启发式函数的结合。以下是求解算法的详细描述：</p><ol><li><strong>搜索算法</strong>：<ul><li>使用 A* 搜索算法，这是一种启发式搜索算法，结合了最佳优先搜索和 Dijkstra 算法的特点。</li><li>A* 算法通过优先队列管理待搜索的状态，优先选择估价函数值最小的状态进行扩展。</li></ul></li><li><strong>启发式函数</strong>：<ul><li><strong>海明距离</strong> (<code>hamming_distance</code>)：计算当前状态与目标状态不同的块的数量。这个函数衡量的是有多少个方块不在正确的位置。</li><li><strong>棋盘距离</strong> (<code>chessboard_f</code>)：计算每个方块到其目标位置的最大单轴距离。</li><li><strong>曼哈顿距离</strong> (<code>manhattan_f</code>)：计算每个方块到其目标位置的曼哈顿距离之和。这个函数考虑了方块的行和列位置。</li><li><strong>欧几里得距离</strong> (<code>euclidean_f</code>)：计算每个方块到其目标位置的欧几里得距离之和。这个函数考虑了方块的直线距离。</li></ul></li><li><strong>状态扩展</strong>：<ul><li>在搜索过程中，每个状态通过移动空白位置的相邻方块进行扩展，生成新的状态。</li><li>每个新状态的估价函数值由启发式函数计算，并根据这个值决定其在优先队列中的位置。</li></ul></li><li><strong>路径回溯</strong>：<ul><li>通过记录每个状态的前驱状态，实现路径回溯。一旦找到目标状态，就可以通过回溯前驱状态来重建解路径。</li></ul></li><li><strong>可解性判断</strong>：<ul><li>在开始搜索之前，通过计算逆序数和空格位置来判断初始状态是否有解。这一步确保了搜索不会在无解的状态上浪费资源。</li></ul></li></ol><p>通过上述状态表示和求解算法的设计，15 数码问题的求解过程被有效地组织和优化。A* 算法结合多种启发式函数，能够在合理的时间内找到问题的解。</p><h2 id="3-实验设计"><a href="#3-实验设计" class="headerlink" title="3. 实验设计"></a>3. 实验设计</h2><p><strong>实验目标</strong></p><p>实验的主要目标是研究和比较不同求解算法在解决 15 数码问题时的性能表现。具体目标包括：</p><ol><li><strong>算法性能评估</strong>：通过实验评估不同搜索算法及其启发式函数在解决 15 数码问题时的效率和有效性。</li><li><strong>启发式函数比较</strong>：比较不同启发式函数（如海明距离、曼哈顿距离、欧几里得距离）对 A* 算法性能的影响。</li><li><strong>问题难度分析</strong>：通过设计不同难度级别的 15 数码问题实例，分析算法在不同难度下的表现。</li><li><strong>可视化展示</strong>：以可视化方式呈现搜索过程，帮助理解算法的工作原理和性能差异。</li></ol><p><strong>评价指标</strong></p><p>为了全面评估算法性能，实验采用以下评价指标：</p><ol><li><strong>求解时间</strong>：记录算法找到解决方案所需的时间。这是衡量算法效率的关键指标。</li><li><strong>步数</strong>：记录从初始状态到目标状态所需的最少移动步数。这是衡量算法有效性的重要指标。</li></ol><p><strong>设计难度不同的 15 数码问题实例</strong></p><p>下面给出16种不同的样例（总体难度递增）</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs txt">5 1 2 4 9 6 3 8 13 15 10 11 0 14 7 12<br>5 1 2 3 0 6 8 4 9 10 7 11 13 14 15 12<br>5 1 3 4 2 0 7 8 10 6 11 12 9 13 14 15<br>1 0 3 4 5 2 7 8 9 6 11 12 13 10 14 15<br>1 2 3 0 5 6 7 4 9 10 11 8 13 14 15 12<br>0 1 2 3 5 6 7 4 9 10 11 8 13 14 15 12<br>1 2 3 4 5 6 7 8 9 10 11 12 13 0 14 15<br>1 2 3 4 5 6 7 8 9 10 11 12 0 13 14 15<br>5 1 2 4 9 6 3 8 13 15 10 11 0 14 7 12<br>1 2 6 4 5 10 11 8 13 9 15 0 7 12 3 14<br>1 2 3 4 5 10 6 8 0 9 7 12 13 14 11 15<br>2 5 1 3 7 11 6 4 10 14 9 8 13 0 12 15<br>5 3 7 8 1 2 11 4 13 6 15 14 0 10 9 12<br>11 9 4 15 1 3 0 12 7 5 8 6 13 2 10 14<br>0 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1<br>1 3 5 7 9 11 13 15 2 4 6 8 10 12 14 0<br></code></pre></td></tr></table></figure><p><strong>选择并实现不同的搜索算法</strong></p><p>本实验采用A*算法，通过更换不同的启发函数来对比不同启发函数下算法的有效性和效率。</p><ul><li>海明距离</li><li>棋盘距离</li><li>曼哈顿距离</li><li>欧几里得距离</li></ul><h2 id="4-实验结果"><a href="#4-实验结果" class="headerlink" title="4. 实验结果"></a>4. 实验结果</h2><p>选取了六种难易不同的初始状态进行在不同启发函数下的对比实验，结果如下表所示：</p><center>    表1 不同样例在不同方法下的求解结果(TLE表示超出规定求解时间)</center><table><thead><tr><th align="center">初始状态</th><th align="left">A* (海明距离)</th><th>A* (棋盘距离)</th><th align="left">A* (曼哈顿距离)</th><th align="left">A* (欧几里得距离)</th></tr></thead><tbody><tr><td align="center">5 1 2 4 9 6 3 8 13 15 10 11 0 14 7 12</td><td align="left">TLE</td><td>时间：0.000188218秒，步数：15</td><td align="left">时间：0.000174202秒，步数：15</td><td align="left">时间：0.000294349秒，步数：15</td></tr><tr><td align="center">1 0 3 4 5 2 7 8 9 6 11 12 13 10 14 15</td><td align="left">TLE</td><td>时间：3.4887e-05秒，步数：5</td><td align="left">时间：4.0557e-05秒，步数：5</td><td align="left">时间：5.268e-05秒，步数：5</td></tr><tr><td align="center">1 2 3 4 5 6 7 8 9 10 11 12 0 13 14 15</td><td align="left">TLE</td><td>时间：1.9928e-05秒，步数：3</td><td align="left">时间：3.0228e-05秒，步数：3</td><td align="left">时间：3.3814e-05秒，步数：3</td></tr><tr><td align="center">2 5 1 3 7 11 6 4 10 14 9 8 13 0 12 15</td><td align="left">TLE</td><td>时间：1.85473秒，步数：32</td><td align="left">时间：0.182626秒，步数：32</td><td align="left">时间：2.17753秒，步数：32</td></tr><tr><td align="center">5 3 7 8 1 2 11 4 13 6 15 14 0 10 9 12</td><td align="left">TLE</td><td>时间：76.0207秒，步数：39</td><td align="left">时间：3.7021秒，步数：39</td><td align="left">时间：84.4167秒，步数：39</td></tr><tr><td align="center">11 9 4 15 1 3 0 12 7 5 8 6 13 2 10 14</td><td align="left">TLE</td><td>时间：16.3697秒，步数：41</td><td align="left">时间：0.108953秒，步数：41</td><td align="left">时间：18.5989秒，步数：41</td></tr></tbody></table><p>从表中可以发现，海明距离作为启发函数的A*算法求解效率极低，在规定时间基本无法求解出正确结果。而棋盘距离，曼哈顿距离和欧几里得距离均可求得正确答案。但其中曼哈顿距离的优势较为明显，求解速度很快，在困难的任务中尤其突出。</p><h2 id="5-实验分析与讨论"><a href="#5-实验分析与讨论" class="headerlink" title="5. 实验分析与讨论"></a>5. 实验分析与讨论</h2><p>通过上述实验，可以得出以下结论：</p><ol><li><strong>海明距离的局限性</strong>：<ul><li>在所有测试案例中，使用海明距离作为启发函数的 A* 算法均未能在合理时间内找到解决方案。这表明海明距离在这种类型的问题中可能不够有效，因为它没有充分利用方块位置的具体信息。</li></ul></li><li><strong>棋盘距离的优势</strong>：<ul><li>棋盘距离在大多数情况下表现出了较好的性能，尤其是在较难的实例中（如第四个和第五个示例）。它通常能够在较短的时间内找到解决方案，尽管在某些情况下步数可能较多。</li></ul></li><li><strong>曼哈顿距离的稳定性</strong>：<ul><li>曼哈顿距离在所有测试案例中均表现出稳定的性能，提供了较好的时间效率和步数。它在处理不同难度的实例时都能保持较好的表现，显示出其作为启发函数的可靠性。</li></ul></li><li><strong>欧几里得距离的效率</strong>：<ul><li>欧几里得距离在某些情况下（如第一个和第三个示例）提供了最快的求解时间，但在其他更复杂的实例中可能不如棋盘距离或曼哈顿距离有效。这表明欧几里得距离在某些特定情况下可能更优。</li></ul></li></ol><p><strong>可视化分析：</strong></p><p>在求解过程通过打印棋盘状态来进行过程的可视化分析</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 输出棋盘的函数，将状态字符串输出为 4x4 格局</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_board</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">16</span>; i++) &#123;<br>        cout &lt;&lt; <span class="hljs-built_in">int</span>(s[i]-<span class="hljs-string">&#x27;a&#x27;</span>) &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        <span class="hljs-keyword">if</span> ((i + <span class="hljs-number">1</span>) % <span class="hljs-number">4</span> == <span class="hljs-number">0</span>) cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-comment">// 每4个数换行</span><br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>例如选取初始状态<code>1 0 3 4 5 2 7 8 9 6 11 12 13 10 14 15</code>，运行结果如下</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs txt">1 0 3 4 <br>5 2 7 8 <br>9 6 11 12 <br>13 10 14 15 <br><br>1 2 3 4 <br>5 0 7 8 <br>9 6 11 12 <br>13 10 14 15 <br><br>1 2 3 4 <br>5 6 7 8 <br>9 0 11 12 <br>13 10 14 15 <br><br>1 2 3 4 <br>5 6 7 8 <br>9 10 11 12 <br>13 0 14 15 <br><br>1 2 3 4 <br>5 6 7 8 <br>9 10 11 12 <br>13 14 0 15 <br><br>1 2 3 4 <br>5 6 7 8 <br>9 10 11 12 <br>13 14 15 0 <br><br>Time taken: 5.4303e-05 seconds<br>Steps: 5<br>DDDRR<br></code></pre></td></tr></table></figure><h2 id="6-结论"><a href="#6-结论" class="headerlink" title="6. 结论"></a>6. 结论</h2><p>通过对 15 数码问题的多种求解算法及其启发式函数的实验比较，我们得出以下结论：</p><ol><li><strong>启发式函数的重要性</strong>：<ul><li>启发式函数的选择对 A* 算法的性能有显著影响。曼哈顿距离和棋盘距离通常提供了较好的性能，而海明距离在这种情况下可能不够有效。</li></ul></li><li><strong>算法效率的差异</strong>：<ul><li>A* 算法结合适当的启发式函数（如曼哈顿距离和棋盘距离）在求解时间和步数上表现优异，尤其是在处理较难的实例时。</li></ul></li><li><strong>问题难度的影响</strong>：<ul><li>初始状态与目标状态之间的距离（如逆序数）直接影响求解时间和步数。更复杂的问题需要更高效的启发式函数来指导搜索。</li></ul></li></ol><p><strong>改进建议</strong></p><p>基于实验结果，提出以下对改进 15 数码问题求解算法的思考和建议：</p><ol><li><strong>启发式函数的优化</strong>：<ul><li>继续研究和开发更高效的启发式函数，以进一步提高 A* 算法的性能。可以考虑结合多种启发式函数的优点，设计新的复合启发式函数。</li></ul></li><li><strong>算法的适应性</strong>：<ul><li>改进算法以适应不同难度的问题。对于更复杂的问题，可以考虑使用更高级的搜索策略，如迭代深化搜索或双向搜索。</li></ul></li><li><strong>并行计算的应用</strong>：<ul><li>利用并行计算技术来加速搜索过程。通过多线程或分布式计算，可以同时探索多个搜索路径，从而提高求解速度。</li></ul></li><li><strong>算法的泛化能力</strong>：<ul><li>研究算法在其他类似问题（如更大规模的数码问题）中的应用潜力，以验证其泛化能力。</li></ul></li></ol><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] Johnson, W. W., &amp; Story, W. E. (1879). Notes on the “15” puzzle. <em>American Journal of Mathematics</em>, <em>2</em>(4), 397-404.</p><p>[2] Story, W. E. (1879). Notes on the” 15” Puzzle. <em>American Journal of Mathematics</em>, <em>2</em>(4), 397-404.</p><p>[3] Culberson, J., &amp; Schaeffer, J. (1994). Efficiently searching the 15-puzzle.</p><p>[4] Tang, G., Tang, C., Claramunt, C., Hu, X., &amp; Zhou, P. (2021). Geometric A-star algorithm: An improved A-star algorithm for AGV path planning in a port environment. <em>IEEE access</em>, <em>9</em>, 59196-59210.</p><p>[5] Erke, S., Bin, D., Yiming, N., Qi, Z., Liang, X., &amp; Dawei, Z. (2020). An improved A-Star based path planning algorithm for autonomous land vehicles. <em>International Journal of Advanced Robotic Systems</em>, <em>17</em>(5), 1729881420962263.</p><p>[6] <a href="https://www.geeksforgeeks.org/a-search-algorithm/">https://www.geeksforgeeks.org/a-search-algorithm/</a></p><p>[7] <a href="https://en.wikipedia.org/wiki/15_puzzle">https://en.wikipedia.org/wiki/15_puzzle</a></p><p>[8]  <a href="https://blog.csdn.net/qq_44174803/article/details/109901611">https://blog.csdn.net/qq_44174803/article/details/109901611</a></p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><code>astar.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span> <span class="hljs-comment">// 用于计时</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">char</span>&gt; h;                <span class="hljs-comment">// 数字到字符的映射（方便状态表示）</span><br>unordered_map&lt;string, <span class="hljs-type">int</span>&gt; dist;           <span class="hljs-comment">// 当前状态的步数</span><br>unordered_map&lt;string, string&gt; pre;         <span class="hljs-comment">// 当前状态的前一个状态，用于路径回溯</span><br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, string&gt; PIS;             <span class="hljs-comment">// 优先队列元素：估价函数值和状态字符串</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> x first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> y second</span><br><br><span class="hljs-type">int</span> ha[<span class="hljs-number">16</span>] = &#123;<span class="hljs-number">15</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>&#125;; <span class="hljs-comment">// 每个数字的目标位置映射 如0-&gt;15, 1-&gt;0</span><br><span class="hljs-type">int</span> num[<span class="hljs-number">16</span>];                      <span class="hljs-comment">// 初始状态，存储输入的 16 个数字</span><br><br><span class="hljs-comment">// 海明距离</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">hamming_distance</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">16</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span> (s[i] != <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; s[i] != h[i]) &#123;  <span class="hljs-comment">// 如果当前块不等于目标位置的块</span><br>            cnt++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;<br><br><span class="hljs-comment">// 棋盘距离作为启发函数，计算状态字符串到目标状态的距离</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">chessboard_f</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">16</span>; i++) &#123;<br>        <span class="hljs-type">int</span> p = s[i] - <span class="hljs-string">&#x27;a&#x27;</span>;       <span class="hljs-comment">// 将字符映射回数字</span><br>        <span class="hljs-keyword">if</span> (!p) <span class="hljs-keyword">continue</span>;         <span class="hljs-comment">// &#x27;a&#x27; 表示空格，跳过</span><br>        <span class="hljs-type">int</span> sx = i % <span class="hljs-number">4</span>, sy = i / <span class="hljs-number">4</span>;                <span class="hljs-comment">// 当前数字位置的坐标</span><br>        <span class="hljs-type">int</span> tx = ha[p] % <span class="hljs-number">4</span>, ty = ha[p] / <span class="hljs-number">4</span>;      <span class="hljs-comment">// 目标位置坐标</span><br>        cnt += <span class="hljs-built_in">max</span>(<span class="hljs-built_in">abs</span>(sx - tx), <span class="hljs-built_in">abs</span>(sy - ty));  <span class="hljs-comment">// 棋盘距离</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;<br><br><span class="hljs-comment">// 曼哈顿距离作为启发函数，计算状态字符串到目标状态的距离</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">manhattan_f</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">16</span>; i++) &#123;<br>        <span class="hljs-type">int</span> p = s[i] - <span class="hljs-string">&#x27;a&#x27;</span>;       <span class="hljs-comment">// 将字符映射回数字</span><br>        <span class="hljs-keyword">if</span> (!p) <span class="hljs-keyword">continue</span>;         <span class="hljs-comment">// &#x27;a&#x27; 表示空格，跳过</span><br>        <span class="hljs-type">int</span> sx = i % <span class="hljs-number">4</span>, sy = i / <span class="hljs-number">4</span>;                <span class="hljs-comment">// 当前数字位置的坐标</span><br>        cnt += <span class="hljs-built_in">abs</span>(sx - ha[p] % <span class="hljs-number">4</span>) + <span class="hljs-built_in">abs</span>(sy - ha[p] / <span class="hljs-number">4</span>); <span class="hljs-comment">// 曼哈顿距离</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;<br><br><span class="hljs-comment">// 欧几里得距离作为启发函数，计算状态字符串到目标状态的距离</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">euclidean_f</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">16</span>; i++) &#123;<br>        <span class="hljs-type">int</span> p = s[i] - <span class="hljs-string">&#x27;a&#x27;</span>;       <span class="hljs-comment">// 将字符映射回数字</span><br>        <span class="hljs-keyword">if</span> (!p) <span class="hljs-keyword">continue</span>;         <span class="hljs-comment">// &#x27;a&#x27; 表示空格，跳过</span><br>        <span class="hljs-type">int</span> sx = i % <span class="hljs-number">4</span>, sy = i / <span class="hljs-number">4</span>;                <span class="hljs-comment">// 当前数字位置的坐标</span><br>        <span class="hljs-type">int</span> tx = ha[p] % <span class="hljs-number">4</span>, ty = ha[p] / <span class="hljs-number">4</span>;      <span class="hljs-comment">// 目标位置坐标</span><br>        cnt += <span class="hljs-built_in">sqrt</span>(<span class="hljs-built_in">pow</span>(sx - tx, <span class="hljs-number">2</span>) + <span class="hljs-built_in">pow</span>(sy - ty, <span class="hljs-number">2</span>));  <span class="hljs-comment">// 欧几里得距离</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;<br><br><span class="hljs-comment">// 判断数码问题是否有解，通过计算逆序数和空格位置校验</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">solvable</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">16</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span> (!num[i]) cnt += <span class="hljs-number">3</span> - i / <span class="hljs-number">4</span>;  <span class="hljs-comment">// 空格所在行到目标状态行的距离</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>                <span class="hljs-keyword">if</span> (num[j] &amp;&amp; num[j] &gt; num[i]) cnt++;  <span class="hljs-comment">// 计算逆序数</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>;  <span class="hljs-comment">// 可解当且仅当逆序数为偶数</span><br>&#125;<br><br><span class="hljs-comment">// 输出棋盘的函数，将状态字符串输出为 4x4 格局</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_board</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">16</span>; i++) &#123;<br>        cout &lt;&lt; <span class="hljs-built_in">int</span>(s[i]-<span class="hljs-string">&#x27;a&#x27;</span>) &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        <span class="hljs-keyword">if</span> ((i + <span class="hljs-number">1</span>) % <span class="hljs-number">4</span> == <span class="hljs-number">0</span>) cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-comment">// 每4个数换行</span><br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br><br><span class="hljs-comment">// A* 搜索主算法</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Astar</span><span class="hljs-params">(string sta, <span class="hljs-type">int</span> (*f)(string))</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> start_time = chrono::high_resolution_clock::<span class="hljs-built_in">now</span>(); <span class="hljs-comment">// 开始计时</span><br>    priority_queue&lt;PIS, vector&lt;PIS&gt;, greater&lt;PIS&gt;&gt; q; <span class="hljs-comment">// 小顶堆，按估价函数排序</span><br>    q.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-built_in">f</span>(sta), sta&#125;);                           <span class="hljs-comment">// 初始状态入队</span><br>    dist[sta] = <span class="hljs-number">0</span>;                                   <span class="hljs-comment">// 初始状态步数为 0</span><br><br>    <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>()) &#123;<br>        <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">top</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        string s = t.y;<br>        <span class="hljs-type">int</span> step = t.x;<br><br>        <span class="hljs-comment">// 输出每一步的棋盘矩阵，计时时注释掉，减少IO时间</span><br>        <span class="hljs-comment">// print_board(s);</span><br><br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">f</span>(s) &amp;&amp; dist[s] &lt;= <span class="hljs-number">45</span>) &#123;<br>            <span class="hljs-keyword">auto</span> end_time = chrono::high_resolution_clock::<span class="hljs-built_in">now</span>(); <span class="hljs-comment">// 结束计时</span><br>            chrono::duration&lt;<span class="hljs-type">double</span>&gt; elapsed = end_time - start_time;<br>            cout &lt;&lt; <span class="hljs-string">&quot;Time taken: &quot;</span> &lt;&lt; elapsed.<span class="hljs-built_in">count</span>() &lt;&lt; <span class="hljs-string">&quot; seconds\n&quot;</span>;<br>            <span class="hljs-keyword">return</span> dist[s]; <span class="hljs-comment">// 找到目标状态</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (step &gt; <span class="hljs-number">45</span>) <span class="hljs-keyword">break</span>;                      <span class="hljs-comment">// 超过搜索步数限制，认为无解</span><br><br>        <span class="hljs-type">int</span> zero;                                  <span class="hljs-comment">// 记录空格位置</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">16</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;a&#x27;</span>) &#123;<br>                zero = i;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 四个方向的状态转移</span><br>        vector&lt;<span class="hljs-type">int</span>&gt; directions = &#123;<span class="hljs-number">-4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>&#125;;   <span class="hljs-comment">// 上下左右</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> d : directions) &#123;<br>            <span class="hljs-type">int</span> newZero = zero + d;<br>            <span class="hljs-keyword">if</span> (newZero &lt; <span class="hljs-number">0</span> || newZero &gt;= <span class="hljs-number">16</span>) <span class="hljs-keyword">continue</span>;    <span class="hljs-comment">// 越界检测</span><br>            <span class="hljs-keyword">if</span> ((zero % <span class="hljs-number">4</span> == <span class="hljs-number">0</span> &amp;&amp; d == <span class="hljs-number">-1</span>) || ((zero + <span class="hljs-number">1</span>) % <span class="hljs-number">4</span> == <span class="hljs-number">0</span> &amp;&amp; d == <span class="hljs-number">1</span>)) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 水平越界检测</span><br><br>            string ss = s;<br>            <span class="hljs-built_in">swap</span>(ss[zero], ss[newZero]);                   <span class="hljs-comment">// 交换空格和目标位置</span><br>            <span class="hljs-keyword">if</span> (!dist.<span class="hljs-built_in">count</span>(ss) &amp;&amp; ss != sta) &#123;            <span class="hljs-comment">// 新状态未被访问过</span><br>                dist[ss] = dist[s] + <span class="hljs-number">1</span>;                    <span class="hljs-comment">// 更新步数</span><br>                q.<span class="hljs-built_in">push</span>(&#123;dist[ss] + <span class="hljs-built_in">f</span>(ss), ss&#125;);            <span class="hljs-comment">// 入队</span><br>                pre[ss] = s;                               <span class="hljs-comment">// 记录前驱状态</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// 搜索失败，返回无解</span><br>&#125;<br><br><span class="hljs-comment">// 根据两个状态的空格位置，返回操作方向</span><br><span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">check</span><span class="hljs-params">(string a, string b)</span> </span>&#123;<br>    <span class="hljs-type">int</span> d1, d2;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; a.<span class="hljs-built_in">size</span>(); i++)<br>        <span class="hljs-keyword">if</span> (a[i] == <span class="hljs-string">&#x27;a&#x27;</span>) &#123;<br>            d1 = i;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; b.<span class="hljs-built_in">size</span>(); i++)<br>        <span class="hljs-keyword">if</span> (b[i] == <span class="hljs-string">&#x27;a&#x27;</span>) &#123;<br>            d2 = i;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    <span class="hljs-keyword">if</span> (d1 - <span class="hljs-number">4</span> == d2) <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;U&#x27;</span>;<br>    <span class="hljs-keyword">if</span> (d1 == d2 - <span class="hljs-number">4</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;D&#x27;</span>;<br>    <span class="hljs-keyword">if</span> (d1 - <span class="hljs-number">1</span> == d2) <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;L&#x27;</span>;<br>    <span class="hljs-keyword">if</span> (d1 + <span class="hljs-number">1</span> == d2) <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;R&#x27;</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;?&#x27;</span>; <span class="hljs-comment">// 不应发生</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>), cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">15</span>; i++) h[i] = <span class="hljs-string">&#x27;a&#x27;</span> + i; <span class="hljs-comment">// 初始化字符映射</span><br><br>    <span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<br>    cin &gt;&gt; T;<br>    <span class="hljs-keyword">while</span> (T--) &#123;<br>        string s;<br>        dist.<span class="hljs-built_in">clear</span>();<br>        pre.<span class="hljs-built_in">clear</span>();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, x; i &lt; <span class="hljs-number">16</span>; i++) &#123;<br>            cin &gt;&gt; x;<br>            num[i] = x;<br>            s += h[x];<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">solvable</span>()) &#123;  <span class="hljs-comment">// 判断是否有解</span><br>            cout &lt;&lt; <span class="hljs-string">&quot;This puzzle is not solvable.\n&quot;</span>;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> res = <span class="hljs-built_in">Astar</span>(s, chessboard_f); <span class="hljs-comment">// 启发函数</span><br>        <span class="hljs-keyword">if</span> (res == <span class="hljs-number">-1</span>)&#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;No answer for search&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Steps: &quot;</span> &lt;&lt; res &lt;&lt; endl;<br><br>        <span class="hljs-comment">// 回溯找到解路径</span><br>        string ss = <span class="hljs-string">&quot;bcdefghijklmnopa&quot;</span>, ans;<br>        <span class="hljs-keyword">while</span> (ss != s) &#123;  <br>            string sss = pre[ss];<br>            ans += <span class="hljs-built_in">check</span>(sss, ss);<br>            ss = sss;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = ans.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) cout &lt;&lt; ans[i]; <span class="hljs-comment">// 逆序输出路径</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="数据表"><a href="#数据表" class="headerlink" title="数据表"></a>数据表</h3><center>    表1 不同样例在不同方法下的求解结果(TLE表示超出规定求解时间)</center><table><thead><tr><th align="center">初始状态</th><th align="left">A* (海明距离)</th><th>A* (棋盘距离)</th><th align="left">A* (曼哈顿距离)</th><th align="left">A* (欧几里得距离)</th></tr></thead><tbody><tr><td align="center">5 1 2 4 9 6 3 8 13 15 10 11 0 14 7 12</td><td align="left">TLE</td><td>时间：0.000188218秒，步数：15</td><td align="left">时间：0.000174202秒，步数：15</td><td align="left">时间：0.000294349秒，步数：15</td></tr><tr><td align="center">1 0 3 4 5 2 7 8 9 6 11 12 13 10 14 15</td><td align="left">TLE</td><td>时间：3.4887e-05秒，步数：5</td><td align="left">时间：4.0557e-05秒，步数：5</td><td align="left">时间：5.268e-05秒，步数：5</td></tr><tr><td align="center">1 2 3 4 5 6 7 8 9 10 11 12 0 13 14 15</td><td align="left">TLE</td><td>时间：1.9928e-05秒，步数：3</td><td align="left">时间：3.0228e-05秒，步数：3</td><td align="left">时间：3.3814e-05秒，步数：3</td></tr><tr><td align="center">2 5 1 3 7 11 6 4 10 14 9 8 13 0 12 15</td><td align="left">TLE</td><td>时间：1.85473秒，步数：32</td><td align="left">时间：0.182626秒，步数：32</td><td align="left">时间：2.17753秒，步数：32</td></tr><tr><td align="center">5 3 7 8 1 2 11 4 13 6 15 14 0 10 9 12</td><td align="left">TLE</td><td>时间：76.0207秒，步数：39</td><td align="left">时间：3.7021秒，步数：39</td><td align="left">时间：84.4167秒，步数：39</td></tr><tr><td align="center">11 9 4 15 1 3 0 12 7 5 8 6 13 2 10 14</td><td align="left">TLE</td><td>时间：16.3697秒，步数：41</td><td align="left">时间：0.108953秒，步数：41</td><td align="left">时间：18.5989秒，步数：41</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>论文翻译- 实体关系模型——企业数据视图的基础</title>
    <link href="/2024/12/10/%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91-%E5%AE%9E%E4%BD%93%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B%E2%80%94%E2%80%94%E4%BC%81%E4%B8%9A%E6%95%B0%E6%8D%AE%E8%A7%86%E5%9B%BE%E7%9A%84%E5%9F%BA%E7%A1%80/"/>
    <url>/2024/12/10/%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91-%E5%AE%9E%E4%BD%93%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B%E2%80%94%E2%80%94%E4%BC%81%E4%B8%9A%E6%95%B0%E6%8D%AE%E8%A7%86%E5%9B%BE%E7%9A%84%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="实体关系模型——企业数据视图的基础"><a href="#实体关系模型——企业数据视图的基础" class="headerlink" title="实体关系模型——企业数据视图的基础"></a>实体关系模型——企业数据视图的基础</h1><blockquote><p>The entity-relationship model— A basis for the enterprise view of data</p><p>PETER PIN-SHAN CHEN Massachusetts Institute of Technology Cambridge, Massachusetts</p></blockquote><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>企业数据视图的概念在数据库设计过程和概念模式构建中非常有用。本文讨论了实体关系方法在描述和维护企业数据视图中的应用。介绍了更改企业模式的基本操作。最后，通过一个示例展示了实体关系方法和数据结构方法在企业数据视图建模方面的差异。</p><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>在过去十年中，数据的逻辑视图这一主题引起了相当大的关注。然而，大多数研究人员都专注于数据的用户视图。直到最近，研究数据的企业视图的必要性才被认识到。数据库的不同用户可能对数据库有不同的看法，但企业应该对数据库有一个独特且一致的视图。</p><p>这对于设计具有逻辑意义和一致性的数据库尤为重要。数据的企业视图概念在数据库设计过程和概念模式设计中非常有用。</p><h3 id="企业视图和数据库设计"><a href="#企业视图和数据库设计" class="headerlink" title="企业视图和数据库设计"></a>企业视图和数据库设计</h3><p>数据库设计是将数据组织成与数据库管理系统的底层数据模型相匹配的形式的过程。数据库管理系统主要有三种类型：网络、层次和关系。在网络数据库管理系统（包括 Honeywell 的 IDS 和 UNIVAC DMS-1100）中，数据将被组织成不同类型的记录，并可以用数据结构图 1 表示（见图 1）。在层次数据库管理系统（包括 IBM 的 IMS）中，数据将被组织成与数据结构图类似但更受限制的形式。在关系数据库管理系统中，数据将被组织成一组表（或“关系”）。</p><p>通常，设计数据库就是决定如何将数据组织成特定形式（记录类型、表）以及如何访问它们。到目前为止，很少有工具可用于辅助数据库设计过程。通常，数据库设计者依靠自己的直觉和经验。因此，得到的数据库可能无法满足公司的目标，并可能导致公司运营出现问题。</p><p>数据库设计中的另一个相关问题是，数据库设计过程的输出——用户模式（对数据的用户视图的描述）——不是现实世界的“纯粹”表示。原因之一是数据库设计者受到数据库管理系统有限功能的限制。例如，在某些数据库系统中，实体之间的多对多关系很难直接表示。另一个原因是用户模式可能包含一些与数据库的存储表示相关的特性。例如，它可能描述哪些记录类型可以直接访问以及如何访问其他记录类型。此外，用户模式通常设计为对某种类型的数据处理操作有效。例如，关于员工的数据可能被分组为两种记录类型，即员工主记录和员工详细信息，以提高检索性能。因此，用户模式通常不是现实世界的直接表示。这使得更改非常困难。</p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241130104521377.png" alt="image-20241130104521377"></p><center>图 1—传统数据库设计流程</center><p>解决上述问题的一个可能方法是在数据库设计过程中引入一个中间阶段：定义企业模式，它是现实世界的“纯粹”表示，与存储和效率考虑无关。然后，企业模式将被转换为不同类型的模式，用于不同的数据库管理系统（见图 2）。它还可以被转换为同一数据库管理系统的多个模式，以优化不同类型的数据处理操作。这种方法有几个优点：</p><ol><li>企业模式比用户模式更容易理解，因为前者不受底层数据库管理&#x2F;系统的限制；</li><li>企业模式比用户模式更稳定，因为用户模式中的某些类型的更改可能不需要企业模式进行任何更改。如果需要更改企业模式以反映企业环境的变化，则可以轻松执行更改，因为无需考虑效率和存储问题。</li></ol><h3 id="企业视图和概念模式"><a href="#企业视图和概念模式" class="headerlink" title="企业视图和概念模式"></a>企业视图和概念模式</h3><p>企业模式与 ANSI&#x2F;X3&#x2F;SPARC 小组提出的概念模式有何区别？基本上，它们非常相似，因为两者都是对企业数据视图的描述。在 SPARC 的方法中，概念模式充当外部模式（数据的用户视图）和存储模式（数据的物理视图）之间的接口（见图 3）。充当其他两个模式之间的接口的要求可能会给概念模式带来一些不良特性。如果忽略对概念模式的这一限制，概念模式和企业模式之间几乎没有区别。因此，本文讨论的技术也适用于描述和维护 SPARC 架构中的概念模式</p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241130104924264.png" alt="image-20241130104924264"></p><center>图 2—企业模式作为数据库设计的中间步骤</center><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241130105030176.png" alt="image-20241130105030176"></p><center>图 3—企业视图和概念架构</center><h3 id="本文采用的方法"><a href="#本文采用的方法" class="headerlink" title="本文采用的方法"></a>本文采用的方法</h3><p>为了描述企业数据视图，需要一个对现实世界进行建模的思维框架。不同的人可能习惯于不同的思维框架。本文使用的思维框架是实体关系 (E-R) 模型。E-R 模型和类似方法在对现实世界进行建模时已被发现很有用。本文将使用一种称为实体关系 (E-R) 图的图表技术来表示企业数据视图。 </p><p>本文分为三个部分。第一部分讨论如何使用 E-R 模型和图表技术来描述企业数据视图。这是参考文献 5 中报告的工作的扩展。第二部分描述了更改企业数据视图的基本操作。这是一个工作很少的领域。本文提出的操作将有助于维护企业模式。第三部分使用 E-R 方法分析 Bachman给出的有关概念模式变化的示例。</p><h2 id="使用实体关系模型和图表技术对现实世界进行建模"><a href="#使用实体关系模型和图表技术对现实世界进行建模" class="headerlink" title="使用实体关系模型和图表技术对现实世界进行建模"></a>使用实体关系模型和图表技术对现实世界进行建模</h2><p>在本节中，我们将使用示例来展示如何使用实体关系 (E-R) 模型和图表技术来描述数据的企业视图。该模型的更正式定义可以在参考文献 5 中找到。</p><p>假设定义和维护企业模式的责任属于企业管理员。以下是建议企业管理员定义企业模式的程序：</p><p>（1）确定企业感兴趣的实体集 实体是可以明确识别的“事物”。</p><p>根据企业的需要，实体可以分为不同的实体类型，如员工、股东等。实体集是一组相同类型的实体。在 E-R 图中，实体集用矩形框表示（见图 4）。术语“集合”和“类型”在 E-R 图中可以互换。读者可以使用其中任意一种来解释 E-R 图。</p><p>现实世界中有很多“事物”，而且不同的企业对同一事物的看法也不同，选择最适合自己企业的实体类型是企业管理员的职责。</p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241130105246258.png" alt="image-20241130105246258"></p><center>    图 4—实体集</center><p>（2）识别企业感兴趣的关系集</p><p>实体之间是相互关联的，不同类型的实体之间可能存在不同类型的关系。关系集是一组相同类型的关系。例如，描述员工分配到项目的PROJLEMP是定义在两个实体集EMP和PROJ上的关系集。关系集也可以定义在两个以上的实体集上。例如，PROJ_SUPP_PART是定义在三个实体集PROJ、SUPP和PART上的关系集。在实体关系图中，关系集用菱形框表示，其中有线条连接到相关的实体集（见图5）。E-R图中PROJLEMP关系对应的“m”和“n”表示该关系是m:n映射。也就是说，每个员工可能与几个项目相关联，每个项目也可能有多个员工。在某些公司中，每个员工最多属于一个项目，PROJLEMP关系是1:n映射。</p><p>实体之间存在多种类型的关系。企业管理员的职责是选择企业感兴趣的关系集（或类型）。他还必须指定关系的映射类型（1:1、1:n、m:1 或 m:n）。</p><p>（3）识别实体和关系的相关属性（即定义值集和属性）</p><p>实体和关系具有属性，可以用属性-值对来表示。</p><p>“蓝色”和“4”是值的示例。值可以分为不同类型，例如 COLOR 或 QUANTITY。值集是一组相同类型的值。属性是从实体集（或关系集）到值集（或一组值集）的映射。例如，“地址”是将实体集 EMP 中的实体映射到值集 NAMES_OF_LOC 中的值的属性。请注意，我们放宽了参考文献 5 中施加的约束，即从实体集到值集的映射必须是函数（即 m: 1 映射）。换句话说，我们现在允许一个属性（例如地址）可以对同一实体（员工）具有多个值（例如位置）。属性定义的这种放宽将使企业视图中的更改更简单。这一点将在下一节中变得清晰</p><p>在 E-R 图中，值集用圆圈表示，属性用从实体集（或关系集）指向所需值集的箭头表示（见图 6）。在选择实体集和关系集后，企业管理员确定与公司运营相关的属性和值集。</p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241130105438843.png" alt="image-20241130105438843"></p><center>    图 5—关系集</center><p>以上三个步骤涵盖了企业模式的主要部分。为了简单起见，我们在本文中不再讨论与企业模式相关的其他问题，例如完整性约束。</p><p>要设计数据库，企业管理员首先要绘制一个 E-R 图，如图 7 所示。<br>然后，他绘制每个实体集和关系集的属性和值集。然后，将 E-R 图转换为数据结构图或一组表（“关系”）（参见图 2）。参考文献 5 讨论了转换过程中使用的规则和程序。在这里，我们将研究如何更改企业模式（E-R 图）本身。</p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241130105615624.png" alt="image-20241130105615624"></p><center>    图 6—属性和值集</center><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241130105641392.png" alt="image-20241130105641392"></p><center>    图 7—实体关系图（仅包含实体集和关系集）</center><h2 id="修改企业视图"><a href="#修改企业视图" class="headerlink" title="修改企业视图"></a>修改企业视图</h2><p>尽管企业模式比用户模式更稳定，但它仍然需要不时地进行更改以反映企业环境的变化。除了 Bachman 的一篇论文 10 外，很少有人在这方面做过什么工作。在本文中，我们使用 E-R 模型作为分析企业数据视图中不同类型的变化的基础。我们不仅提出了一组操作，还分析了这些操作的后果。</p><p>有五种基本类型的操作：添加、删除、拆分、合并和移动。前四种操作适用于实体集、关系集、属性和值集。当企业管理员希望将旧企业模式中的值集视为新模式中的实体集或反之亦然时，使用移动操作。认为 E-R 图由两个概念域组成是有用的：（1）上层概念域，由实体集和关系集组成；（2）下层概念域，由属性和值集组成。我们将在上层和下层概念域中讨论前四种操作。<br>最后，我们将讨论将实体集从上层概念域移动到下层概念域以及将值集向相反方向移动。</p><h3 id="上层概念域中的操作"><a href="#上层概念域中的操作" class="headerlink" title="上层概念域中的操作"></a>上层概念域中的操作</h3><p>以下是适用于实体集和联系集的基本操作：</p><p>（1）将一个实体拆分成几个子集</p><p>例如，图 8a 中的实体集 EMP 可以拆分为两个实体集：图 8b 中的 MALE_EMP 和 FEMALE_EMP。此操作的结果是与实体集相关的关系集也必须拆分。例如，PROLEMP 拆分为 PROJ_M_EMP 和 PROJLF_EMP（参见图 8b）。</p><p>（2）将多个实体集合并为一个实体集</p><p>这是 (1) 的逆操作。其结果是相关关系集可能必须合并。</p><p>（3）将一个关系集拆分成几个子集</p><p>此操作的一个示例是：图 8a 中的关系集 PROJLEMP 可以拆分为两个关系集，即图 8c 中的 PROJLMANAGER 和 PROJ_WORKER。请注意，新关系中的映射类型可能与原始关系中的映射类型不同。例如，PROJLMANAGER 中的映射为 1: n，而 PROJ_EMP 中的映射为 m:n。</p><p>（4）将多个联系集合并为一个集合</p><p>这是（3）的逆操作。注意这些联系集必须定义在同一组实体集上。</p><p>（5）添加新实体集</p><p>例如，可以在图 8a 中的 E-R 图中增加一个名为 SUPPLIER 的新实体集。结果如图 9a 所示。请注意，企业模式中可以有独立的实体集，尽管在许多情况下，新实体集和现有实体集之间的关系是立即建立的（参见下一个操作）。</p><p>（6）添加新的关系集</p><p>我们可以为新的实体集添加新的关系集，如图9b中的关系集PROJLSUPP。我们也可以为现有的实体集添加新的关系集，如图9b中的关系集PROJLMANAGER</p><p>（7）删除实体集</p><p>例如，删除图9b中的实体集EMP后，得到图9c。其后果是：（i）与该实体集相关的关系集也被删除；（ii）与被删除实体集相关的属性和相关关系集也被删除</p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241130105955940.png" alt="image-20241130105955940"></p><center>    图9-增加/删除 实体/关系 集</center><p>（8）删除关系集</p><p>一个例子是：删除图9b中的关系集PROJLEMP，结果如图9d所示。该操作的后果是关系的属性被删除（图9d中未显示）。</p><h3 id="较低概念域中的操作"><a href="#较低概念域中的操作" class="headerlink" title="较低概念域中的操作"></a>较低概念域中的操作</h3><p>假设实体集 EMP 中的实体具有两个属性，即 LEOAl^MAME 和 PHONE，它们将实体映射到值集 NAME 和 PHONE_#（参见图 10a）。我们将使用这些属性和值集作为讨论以下操作的基础：</p><p>（1）添加值集</p><p>例如，可以在图10a中添加一个名为DOLLARS的新值集。结果如图10b所示。通常，此操作后跟“添加属性”操作。</p><p>（2）删除值集</p><p>删除图10a中的值集PHONE_#后，得到图10c。其结果是，与该值集相关的所有属性都将被删除</p><p>（3）将一个值集拆分成几个子集 </p><p>图 10a 中的值集 NAMES 可以拆分成图 10d 中的两个值集 FIRST_NAMES 和 LAST_NAMES。其结果是，与该值集相关的属性可能必须进行调整。虽然图 10d 中没有拆分属性 LEGAL_NAME，但可以将其拆分成两个属性：LEGAL_FIRST_NAME 和 LEGAL. LAST_NAME。企业管理员有责任做出此决定。</p><p>（4）将多个值集合并为一个值集</p><p>这是（3）的逆操作。</p><p>（5）添加属性</p><p>例如，图11a中添加属性OTHER_NAME，即可得到图11b。</p><p>（6）删除属性 </p><p>从图 11a 中删除属性 LEGAL_NAME，得到图 11e。如果需要，与该属性关联的值集将通过另一个操作（“删除值集”）删除。在某些情况下，该值集可能仍与其他属性相关联（参见图 11e）。</p><p>（7）将一个属性拆分为多个属性</p><p>例如图11a中，将图11d中的属性PHONE拆分为OFFICE_PHONE和HOME_PHONE两个属性。</p><p>（8）将多个属性合并为一个属性</p><p>这是（7）的逆操作。属性必须定义在同一个实体集（或联系集）上。</p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241130110413846.png" alt="image-20241130110413846"></p><center>    图 10—值集上的操作</center><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241130110439315.png" alt="image-20241130110439315"></p><center>    图 11—属性操作</center><h3 id="两个概念域之间的操作"><a href="#两个概念域之间的操作" class="headerlink" title="两个概念域之间的操作"></a>两个概念域之间的操作</h3><p>假设有两个实体集（EMP 和 PROJ）、一个关系集（PROJLEMP）、四个值集（NAMES_OF_PLACES、SOG_SEC_#、PHONE_# 和 PROJLNAMES）和四个属性（ADDRESS、SOC_SEC_NO、PHONE 和 NAME），如图 12a 所示。我们将以它们为基础讨论以下操作：</p><p>(1) 将值集从下层概念域移到上层概念域</p><p>当企业环境发生变化时，将 PLACE 视为实体集而不是值集可能变得很自然。因此，在图 12b 中，“ADDRESS”变成了一个关系集，“PLACE”有一个属性“NAME”，它指向值集 NAMES_OF_PLACES。由于 PLACE 是一个实体集，我们可以将它与其他实体集（如 PROJ）建立新的关系，或者添加更多属性和值集来描述“地点”的属性。</p><p>（2）将实体集从上层概念域移到下层概念域</p><p>当企业环境再次发生变化时，将PROJ视为值集而不是实体集可能变得很自然。在图12c中，PROJ从上层概念域中删除，联系集PROJLEMP变为属性INVOLVED_PROJ。图12b中的实体集PROJ可能与多个值集相关联，但只有用于标识实体PR.OJ的值集PROJ_NAMES仍保留在下层概念域中。</p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241130110755667.png" alt="image-20241130110755667"></p><center>    图12—将集合从上层概念域移至下层概念域，反之亦然</center><h2 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h2><p>在最近的一篇论文中，Bachman 使用数据结构图来说明概念模式的变化。在本节中，我们将首先陈述他的例子，然后使用 ER 图来解释他的例子</p><h3 id="使用数据结构图描述示例"><a href="#使用数据结构图描述示例" class="headerlink" title="使用数据结构图描述示例"></a>使用数据结构图描述示例</h3><p>以下是 Bachman 示例的简化版本：</p><p>(a) 一开始，企业管理员声明了一个概念模式，如图 13a 所示。假设读者对数据结构图有一定的了解。1 简单来说，一个矩形框代表一种记录类型，一个箭头代表一个数据结构集（即记录类型之间的 l:n 关系）。在图 13a 中，有两种类型的概念记录，即 COMPANY 和 PERSON，以及一个数据结构集“a”，表示每个人只与一家公司相关联，并且每家公司都有一组人员。</p><p>(b) 后来，企业管理员认识到公司的人员本身就是人。在几家公司合并时可能会发现这一事实，其中一些人身兼两职，是合并后两家公司的人员。图 13b 说明了新概念模式的数据结构图。基本上，旧的人员类型记录已分为两种记录类型，即 PERSONNEL 和 PERSON。“PERSON”具有属性 NAME 和 ADDRESS（图中未显示）</p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241130110832257.png" alt="image-20241130110832257"></p><center>    图13—使用数据结构图表达企业视图中的变化</center><p>（c）过了一会儿，企业管理员决定将居住地址从个人记录中分离出来。图 13c 说明了“PLACE”概念记录类型和数据结构集类型 c 的添加。还假设每个人都有一个唯一的地址（地点）。</p><p>(d) 现在人们认识到人们会从一个地方搬到另一个地方，因此了解当前地址和过去地址是必要的。另一个原因可能是：人们发现一个人可能有多个地址。无论哪种情况，都会将新的概念记录类型 ADDRESS 添加到概念模式中（参见图 13d）。</p><h3 id="使用实体关系图进行分析"><a href="#使用实体关系图进行分析" class="headerlink" title="使用实体关系图进行分析"></a>使用实体关系图进行分析</h3><p>下面我们用E-R图来解释上面的例子：</p><p>（a）图 14a 中的 E-R 图对应于图 13a 中的数据结构图。在企业视图中，有两种类型的实体，即 PERSON 和 COMPANY。由于 COMPANY 和 PERSON 之间的映射为 1：n，因此关系集 PERSONNEL 在图 13a 中用数据结构集“a”表示</p><p>（b）图 14b 是图 13b 对应的 E-R 图。由于关系集 PERSONNEL 是 m:n 映射，因此在图 13b 中它由关系记录类型 PERSONNEL 和两个数据结构集“a”和“b”表示。请注意，图 14a 和 14b 在上层概念域中具有相同的实体集和关系集，不同之处在于实体集之间的映射类型</p><p>(c) 现在，企业管理员更愿意将“PLACE”视为实体集，而不是值集。<br>因此，我们有图 14c。图 14b 中的属性 ADDRESS 成为图 14c 中的关系集。由于 PLACE 和 PERSON 之间的映射为 1:n，因此关系集 ADDRESS 由图 13c 中的数据结构集“c”表示。</p><p>（d）企业管理员发现 PLACE 和 PERSON 之间的映射是 m:n 映射，而不是 l:n 映射。新的企业视图由图 14d 表示。由于映射是 m:n，关系集 ADDRESS 由记录类型 ADDRESS 和两个数据结构集“d”和“e”表示。请注意，图 14c 和 14d 几乎相同，只是 PLACE 和 PERSON 之间的映射类型不同。</p><p>总体而言，E-R 图比数据结构图更易于分析企业视图的变化。Bachman 还提出了图 13d 中的歧义问题：如果要修改某人的地址，他是否必须创建新的“地址”记录或更改此人居住地的名称？使用 E-R 方法可以轻松回答这个问题。考虑图 14d。由于 PLACE 是一个实体集，因此更改某人的地址就是更改此人与“他的住所”之间的关系。我们不应该更改此人居住地的名称，因为“NAME”和“NAMES_OF_PLACES”用于描述 PLACE 实体的属性（参见图 14d）。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>企业模式是数据库设计中的一个有用的中间步骤。在本文中，我们展示了如何使用实体关系模型和图表技术来描述企业模式。由于企业环境时常发生变化，企业模式也必须随之改变以反映这些变化。本文介绍了可用于修改企业模式的五种基本操作（添加、删除、拆分、合并和移位），并讨论了这些操作的后果。最后，我们用一个例子来分析实体关系方法和网络方法在对数据的企业视图进行建模方面的差异。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><p>Bachman, C. W., “Data Structure Diagrams,” Data Base 1, 2, Summer 1969, pp. 4-10.</p></li><li><p>Codd, E. F., “A Relational Model of Data for Large Shared Data Banks,” Comm. ACM 13, 6, June 1970, pp. 377-387.</p></li><li><p>ANSI, Interim Report ofANSI&#x2F;X3&#x2F;SPARC Group on Database Management Systems, ANSI, February 1975.</p></li><li><p>Chen, P. P., “The Entity-Relationship Model,” (abstract), Proc. 1st Very Large Database Conf., Framingham, Mass., Sept. 1975, ACM.</p></li><li><p>Chen, P. P., “The Entity-Relationship Model: Toward a Unified View of Data,” ACM Tran. on Database Systems 1, 1, March 1976, pp. 9-36.</p></li><li><p>Moulin, P., J. Randon, M. Teboul, et al, “Conceptual Model as a Database Design Tool,” Proc. IFIP TC-2 Working Conf., Jan. 1976, Black Forest, Germany, pp. 459-479.</p></li><li><p>Hall, P., Todd S. Owlett, “Relations and Entities,” Proc. IFIP TC-2 Working Conf., Jan. 1976, Black Forest, Germany, pp. 430-458.</p></li><li><p>Deheneffe C. and H. Hennebert, “NUL: a Navigational User’s Language for a Network Structured Data Base,” Proc. ACM 1976 SIGMOD Conf, Washington, D.C., June 1976, pp. 135-142.</p></li><li><p>Tozer, E. E., “Database Systems Analysis and Design,” Technical report, Software Sciences Limited, England, April 1976.</p></li><li><p>Bachman, C. W., “Trends in Database Management—1975,” Proc.  AFIPS 1975 NCC, Vol. 44, AFIPS Press, Montvale, N. J., pp. 569-576.</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>论文导读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MarsCode-小M的多任务下载器挑战</title>
    <link href="/2024/11/10/MarsCode-%E5%B0%8FM%E7%9A%84%E5%A4%9A%E4%BB%BB%E5%8A%A1%E4%B8%8B%E8%BD%BD%E5%99%A8%E6%8C%91%E6%88%98/"/>
    <url>/2024/11/10/MarsCode-%E5%B0%8FM%E7%9A%84%E5%A4%9A%E4%BB%BB%E5%8A%A1%E4%B8%8B%E8%BD%BD%E5%99%A8%E6%8C%91%E6%88%98/</url>
    
    <content type="html"><![CDATA[<h1 id="小M的多任务下载器挑战"><a href="#小M的多任务下载器挑战" class="headerlink" title="小M的多任务下载器挑战"></a>小M的多任务下载器挑战</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>小M的程序设计大作业是编写一个多任务下载器。在实现过程中，他遇到了一个问题：在一次下载过程中，总共有<code>N</code>个任务，每个任务会在第<code>x</code>秒开始，并持续<code>y</code>秒。小M需要知道，在同一时刻，最多有多少个任务正在同时下载，也就是计算出任务的最高并发数。</p><ul><li><code>n</code> 表示任务的数量。</li><li><code>array</code> 是一个二维列表，每个元素为<code>[x, y]</code>，表示任务的开始时间和持续时间，其中：</li><li><code>x</code> 表示任务的开始时间；</li><li><code>y</code> 表示任务的持续时间。</li></ul><hr><h2 id="测试样例"><a href="#测试样例" class="headerlink" title="测试样例"></a>测试样例</h2><p><em><strong>样例1：</strong></em></p><blockquote><p>输入：<code>n = 2 ,array = [[1, 2], [2, 3]]</code><br>输出：<code>2</code></p></blockquote><p><em><strong>样例2：</strong></em></p><blockquote><p>输入：<code>n = 4 ,array = [[1, 2], [2, 3], [3, 5], [4, 3]]</code><br>输出：<code>3</code></p></blockquote><p><em><strong>样例3：</strong></em></p><blockquote><p>输入：<code>n = 5 ,array = [[1, 3], [3, 4], [2, 2], [6, 5], [5, 3]]</code><br>输出：<code>3</code></p></blockquote><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="思路一-遍历"><a href="#思路一-遍历" class="headerlink" title="思路一-遍历"></a>思路一-遍历</h3><p>先按起始时间排序，再遍历整个下载周期。时间复杂度高</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">solution</span>(<span class="hljs-params">n, array</span>):<br>    <span class="hljs-comment"># Edit your code here</span><br>    array.sort(key= <span class="hljs-keyword">lambda</span> x: x[<span class="hljs-number">0</span>])<br>    max_concurrency = <span class="hljs-number">0</span><br>    end = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        start_time = array[i][<span class="hljs-number">0</span>]<br>        duration = array[i][<span class="hljs-number">1</span>]<br>        end_time = start_time + duration<br>        array[i][<span class="hljs-number">1</span>] = end_time <span class="hljs-comment"># 将持续时间转为截至时间</span><br>        <span class="hljs-keyword">if</span> end_time &gt; end:<br>            end = end_time<br>    start = array[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]<br>    <br>    <span class="hljs-keyword">for</span> time <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(start, end+<span class="hljs-number">1</span>):<br>        concurrency = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">if</span> array[i][<span class="hljs-number">0</span>] &lt;= time &lt; array[i][<span class="hljs-number">1</span>]:<br>                concurrency += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> concurrency &gt; max_concurrency:<br>            max_concurrency = concurrency<br><br>    <span class="hljs-keyword">return</span> max_concurrency<br></code></pre></td></tr></table></figure><h3 id="思路二-事件驱动"><a href="#思路二-事件驱动" class="headerlink" title="思路二-事件驱动"></a>思路二-事件驱动</h3><p>将每个任务的开始和结束时间视为事件，并使用事件驱动的方法来计算并发任务数。</p><p>时间复杂度<code>O(n)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">solution</span>(<span class="hljs-params">n, array</span>):<br>    events = []<br>    <br>    <span class="hljs-comment"># 将每个任务的开始和结束时间转换为事件</span><br>    <span class="hljs-keyword">for</span> task <span class="hljs-keyword">in</span> array:<br>        start_time = task[<span class="hljs-number">0</span>]<br>        end_time = task[<span class="hljs-number">0</span>] + task[<span class="hljs-number">1</span>]<br>        events.append((start_time, <span class="hljs-number">1</span>))  <span class="hljs-comment"># 开始事件</span><br>        events.append((end_time, -<span class="hljs-number">1</span>))   <span class="hljs-comment"># 结束事件</span><br>    <br>    <span class="hljs-comment"># 按照时间顺序排序事件</span><br>    events.sort()<br>    <br>    max_concurrency = <span class="hljs-number">0</span><br>    current_concurrency = <span class="hljs-number">0</span><br>    <br>    <span class="hljs-comment"># 遍历事件，计算并发任务数</span><br>    <span class="hljs-keyword">for</span> event <span class="hljs-keyword">in</span> events:<br>        current_concurrency += event[<span class="hljs-number">1</span>]<br>        max_concurrency = <span class="hljs-built_in">max</span>(max_concurrency, current_concurrency)<br>    <br>    <span class="hljs-keyword">return</span> max_concurrency<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-comment"># Add your test cases here</span><br>    <span class="hljs-built_in">print</span>(<br>        solution(<span class="hljs-number">2</span>, [[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]]) == <span class="hljs-number">2</span><br>    )<br>    <span class="hljs-built_in">print</span>(<br>        solution(<span class="hljs-number">4</span>, [[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">5</span>], [<span class="hljs-number">4</span>,<span class="hljs-number">3</span>]]) == <span class="hljs-number">3</span><br>    )<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>MarsCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>事件驱动</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HUST-SE编译作业-第10章</title>
    <link href="/2024/11/08/HUST-SE%E7%BC%96%E8%AF%91%E4%BD%9C%E4%B8%9A%E7%AC%AC10%E7%AB%A0/"/>
    <url>/2024/11/08/HUST-SE%E7%BC%96%E8%AF%91%E4%BD%9C%E4%B8%9A%E7%AC%AC10%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="HUST-SE编译作业-第10章"><a href="#HUST-SE编译作业-第10章" class="headerlink" title="HUST-SE编译作业-第10章"></a>HUST-SE编译作业-第10章</h1><blockquote><p>编译技术代码优化与目标代码生成</p></blockquote><h2 id="源程序"><a href="#源程序" class="headerlink" title="源程序"></a>源程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> n, sum = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入一个正整数 n: &quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br><br>    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入一个正整数。\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (i &lt;= n) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= i; j++) &#123;<br>            sum += j;<br>        &#125;<br>        i++;<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;1 到 %d 的累加和为 %d\n&quot;</span>, n, sum);<br><br>    <span class="hljs-comment">// 分支结构</span><br>    <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d 是一个偶数。\n&quot;</span>, n);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d 是一个奇数。\n&quot;</span>, n);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="中间代码表示"><a href="#中间代码表示" class="headerlink" title="中间代码表示"></a>中间代码表示</h2><p>$B_i$为基本块块号，$i.$为语句序号</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs tex">B1<br>1. n := 0<br>2. sum := 0<br>3. PRINT &quot;请输入一个正整数 n: &quot;<br>4. SCAN n<br>5. IF n &lt;= 0 GOTO 7.<br><br>B2<br>6. GOTO 9.<br><br>B3<br>7. PRINT &quot;请输入一个正整数。&quot;<br>8. RETURN 1<br><br>B4<br>9. i := 1<br><br>B5<br>10. IF i &gt; n GOTO 21.<br><br>B6<br>11. j := 1<br><br>B7<br>12. IF j &gt; i GOTO 18.<br><br>B8<br>13. t1 := sum + j<br>14. sum := t1<br>15. t2 := j + 1<br>16. j := t2<br>17. GOTO 12.<br><br>B9<br>18. t3 := i + 1<br>19. i := t3<br>20. GOTO 10.<br><br>B10<br>21. PRINT &quot;1 到 &quot;, n, &quot; 的累加和为 &quot;, sum<br>22. t4 := n <span class="hljs-comment">% 2</span><br>23. IF t4 == 0 GOTO 25.<br><br>B11<br>24. GOTO 27.<br><br>B12<br>25. PRINT n, &quot; 是一个偶数。&quot;<br>26. GOTO 28.<br><br>B13<br>27. PRINT n, &quot; 是一个奇数。&quot;<br><br>B14<br>28. RETURN 0<br></code></pre></td></tr></table></figure><h2 id="程序流图"><a href="#程序流图" class="headerlink" title="程序流图"></a>程序流图</h2><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/IMG_20241108_174128.jpg" alt="程序流图"></p><h2 id="循环的计算"><a href="#循环的计算" class="headerlink" title="循环的计算"></a>循环的计算</h2><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/IMG_20241108_174241-1731059033913.jpg" alt="必经节点集，回边，循环"></p>]]></content>
    
    
    <categories>
      
      <category>作业</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MarsCode-完美整数</title>
    <link href="/2024/11/07/MarsCode-%E5%AE%8C%E7%BE%8E%E6%95%B4%E6%95%B0/"/>
    <url>/2024/11/07/MarsCode-%E5%AE%8C%E7%BE%8E%E6%95%B4%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="MarsCode-完美整数"><a href="#MarsCode-完美整数" class="headerlink" title="MarsCode-完美整数"></a>MarsCode-完美整数</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>一个整数如果由相同的数字构成，则称为<strong>完美整数</strong>。例如：</p><ul><li><code>1</code>、<code>11</code>、<code>333</code> 是完美整数。</li><li><code>12</code>、<code>19</code>、<code>101</code> 是不完美整数。</li></ul><p>现在，你需要计算给定区间 <code>[x, y]</code> 中有多少个整数是完美整数。</p><hr><h2 id="测试样例"><a href="#测试样例" class="headerlink" title="测试样例"></a>测试样例</h2><p><em><strong>样例1：</strong></em></p><blockquote><p>输入：<code>x = 1 ,y = 10</code><br>输出：<code>9</code></p></blockquote><p><em><strong>样例2：</strong></em></p><blockquote><p>输入：<code>x = 2 ,y = 22</code><br>输出：<code>10</code></p></blockquote><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="思路一-逐个判断"><a href="#思路一-逐个判断" class="headerlink" title="思路一-逐个判断"></a>思路一-逐个判断</h3><p>时间复杂度高，计算效率低下</p><h3 id="思路二-生成完美整数序列"><a href="#思路二-生成完美整数序列" class="headerlink" title="思路二-生成完美整数序列"></a>思路二-生成完美整数序列</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">solution</span>(<span class="hljs-params">x, y</span>):<br>    <span class="hljs-comment"># Edit your code here</span><br>    count = <span class="hljs-number">0</span><br>    <span class="hljs-comment"># 单独判断0</span><br>    <span class="hljs-keyword">if</span> x &lt;= <span class="hljs-number">0</span> &lt;= y:<br>        count += <span class="hljs-number">1</span><br>    <span class="hljs-comment"># 生成诸如11，22，111等完美整数</span><br>    <span class="hljs-keyword">for</span> length <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1000</span>):<br>        <span class="hljs-keyword">for</span> digit <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>):<br>            num = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">str</span>(digit)*length)<br>            <span class="hljs-keyword">if</span> x &lt;= num &lt;= y:<br>                count += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">elif</span> num &gt; y:<br>                <span class="hljs-keyword">return</span> count<br>        <br><br>    <span class="hljs-keyword">return</span> count<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-comment"># Add your test cases here</span><br><br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>) == <span class="hljs-number">9</span>)<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">2</span>, <span class="hljs-number">22</span>) == <span class="hljs-number">10</span>)<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>MarsCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>简单</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>论文翻译-大型共享数据库的关系数据模型</title>
    <link href="/2024/11/04/%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91-%E5%A4%A7%E5%9E%8B%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B/"/>
    <url>/2024/11/04/%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91-%E5%A4%A7%E5%9E%8B%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="大型共享数据库的关系数据模型"><a href="#大型共享数据库的关系数据模型" class="headerlink" title="大型共享数据库的关系数据模型"></a>大型共享数据库的关系数据模型</h1><blockquote><p>A Relational Model of Data Large Shared Data Banks</p><p>E.F. CODD IBM Research Laboratory, San Jose, California</p></blockquote><p>必须保护大型数据库的未来用户，使他们不必知道数据在机器中的组织方式（内部表示）。提供此类信息的提示服务并不是令人满意的解决方案。当数据的内部表示发生变化，甚至外部表示的某些方面发生变化时，终端和大多数应用程序上的用户活动应不受影响。由于查询、更新和报告流量的变化以及存储信息类型的自然增长，通常需要更改数据表示。</p><p>现有的非推理格式化数据系统为用户提供树形文件或稍微更通用的数据网络模型。在第 1 节中，讨论了这些模型的不足之处。介绍了基于 n 元关系的模型、数据库关系的范式以及通用数据子语言的概念。在第 2 节中，讨论了某些关系操作（逻辑推理除外），并将其应用于用户模型中的冗余和一致性问题。</p><p>关键词和短语：数据库、数据库、数据结构、数据组织、数据层次结构、数据网络、关系、可导出性、冗余度、一致性、组合、连接、检索语言、谓词演算、安全性、数据完整性 CR 类别：3.70、3.73、3.75、4.20、4.22、4.29</p><h2 id="1-关系模型与范式"><a href="#1-关系模型与范式" class="headerlink" title="1.关系模型与范式"></a>1.关系模型与范式</h2><h3 id="1-1引言"><a href="#1-1引言" class="headerlink" title="1.1引言"></a>1.1引言</h3><p>本文关注的是基本关系理论在提供对大型格式化数据共享访问的系统中的应用。除了 Childs [1] 的一篇论文外，关系在数据系统中的主要应用是演绎问答系统。<br>Levein 和 Maron [2] 提供了大量有关该领域工作的参考资料。<br>与此相反，本文讨论的问题是数据独立性问题（应用程序和终端活动不受数据类型增长和数据表示变化的影响），以及某些类型的数据不一致性问题，这些问题即使在非演绎系统中也会变得麻烦.</p><p>第 1 节中描述的数据关系视图（或模型）似乎在多个方面优于目前在非推理系统中流行的图形或网络模型 [3, 4]。它提供了一种仅使用其自然结构描述数据的方法——也就是说，无需为机器表示目的而添加任何附加结构。因此，它为高级数据语言提供了基础，这种语言将在程序与机器表示和数据组织之间实现最大程度的独立性。</p><p>关系视图的另一个优点是它为处理关系的可导出性、冗余性和一致性奠定了坚实的基础——这些将在第 2 节中讨论。另一方面，网络模型引发了许多混淆，其中最严重的混淆是将连接的导出误认为是关系的导出（请参阅第 2 节中关于“连接陷阱”的注释）。</p><p>最后，关系视图允许更清楚地评估当前格式化数据系统的范围和逻辑限制，以及单个系统内竞争数据表示的相对优点（从逻辑角度来看）。本文各部分都引用了这种更清晰观点的例子。不讨论支持关系模型的系统的实现。</p><h3 id="1-2-现有系统中的数据依赖性"><a href="#1-2-现有系统中的数据依赖性" class="headerlink" title="1.2. 现有系统中的数据依赖性"></a>1.2. 现有系统中的数据依赖性</h3><p>在最近开发的信息系统中，数据描述表的提供代表着朝着数据独立性目标迈出了一大步 [5, 6, 7]。这样的表有助于更改数据库中存储的数据表示的某些特征。然而，在不从逻辑上损害某些应用程序的情况下可以更改的数据表示特征种类仍然非常有限。此外，用户与之交互的数据模型仍然充斥着表示属性，特别是在数据集合（而不是单个项目）的表示方面。仍然需要消除的三种主要数据依赖关系是：<strong>排序依赖关系、索引依赖关系和访问路径依赖关系</strong>。在某些系统中，这些依赖关系彼此之间不能明显区分</p><h4 id="1-2-1-排序依赖性"><a href="#1-2-1-排序依赖性" class="headerlink" title="1.2.1. 排序依赖性"></a>1.2.1. 排序依赖性</h4><p>数据库中的数据元素可以以多种方式存储，有些方式与排序无关，有些方式允许每个元素仅参与一种排序，而另一些方式允许每个元素参与多种排序。让我们考虑那些现有系统，它们要求或允许数据元素以至少一种全排序方式存储，该全排序与硬件确定的地址排序密切相关。例如，文件中有关零件的记录可能按零件序列号的升序存储。此类系统通常允许应用程序假设此类文件中记录的呈现顺序与存储的排序相同（或为其子排序）。如果出于某种原因需要用另一种排序方式替换该排序，那么利用文件存储排序的应用程序可能无法正常运行。对于通过指针实现的存储排序，也有类似的评论。</p><p>没有必要单独挑出任何系统作为例子，因为当今市场上所有知名的信息系统都没有明确区分显示顺序和存储顺序。要提供这种独立性，必须解决重大的实施问题。</p><h4 id="1-2-2-索引依赖性。"><a href="#1-2-2-索引依赖性。" class="headerlink" title="1.2.2. 索引依赖性。"></a>1.2.2. 索引依赖性。</h4><p>在格式化数据的上下文中，索引通常被认为是数据表示中纯粹面向性能的组件。它倾向于提高对查询和更新的响应，同时减慢对插入和删除的响应。从信息的角度来看，索引是数据表示的冗余组件。如果系统使用索引，并且要在数据库活动模式不断变化的环境中表现良好，那么可能需要能够不时创建和销毁索引。然后出现了一个问题：应用程序和终端活动能否在索引来来去去时保持不变？目前的格式化数据系统采用截然不同的索引方法。 TDMS [7] 无条件地为所有属性提供索引。当前发布的 IMS [5] 版本为每个文件提供了选择：完全不索引（分层顺序组织）或仅对主键进行索引（分层索引顺序组织）。在这两种情况下，用户的应用程序逻辑都不依赖于无条件提供的索引的存在。但是，IDS [8] 允许文件设计者选择要索引的属性，并通过附加链将索引合并到文件结构中。利用这些索引链的性能优势的应用程序必须通过名称引用这些链。如果这些链后来被删除，此类程序将无法正常运行。</p><h4 id="1-2-3-访问路径依赖性。"><a href="#1-2-3-访问路径依赖性。" class="headerlink" title="1.2.3. 访问路径依赖性。"></a>1.2.3. 访问路径依赖性。</h4><p>许多现有的格式化数据系统为用户提供了树结构文件或稍微更通用的数据网络模型。</p><p>如果树或网络的结构发生变化，为与这些系统协同工作而开发的应用程序往往会在逻辑上受到损害。下面是一个简单的例子。<br>假设数据库包含有关零件和项目的信息。对于每个零件，记录零件编号、零件名称、零件说明、现有数量和订单数量。对于每个项目，记录项目编号、项目名称和项目说明。每当项目使用某个零件时，还会记录该零件投入到给定项目的数量。假设系统要求用户或文件设计者以树形结构声明或定义数据。那么，可以采用上述信息中的任何一种层次结构（参见结构 1-5）。</p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241025115148224.png" alt="image-20241025115148224"></p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241025115200941.png" alt="image-20241025115200941"></p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241025115212926.png" alt="image-20241025115212926"></p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241025115226134.png" alt="image-20241025115226134"></p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241025115237674.png" alt="image-20241025115237674"></p><p>现在，考虑打印出项目名称为“alpha”的项目中所使用的每个部件的部件编号、部件名称和承诺数量的问题。无论选择哪种可用的树形信息系统来解决此问题，都可以进行以下观察。如果针对此问题开发了一个程序 P，假设上述五种结构之一——即 P 不进行测试以确定哪种结构有效——那么 P 将在剩余结构中的至少三种上失败。更具体地说，如果 P 在结构 5 上成功，它将在所有其他结构上失败；如果 P 在结构 3 或 4 上成功，它将至少在 1、2 和 5 上失败；如果 P 在 1 或 2 上成功，它将至少在 3、4 和 5 上失败。每种情况下的原因都很简单。在没有测试来确定哪种结构有效的情况下，P 会失败，因为尝试执行对不存在的文件的引用（可用系统将此视为错误）或没有尝试执行对包含所需信息的文件的引用。<br>不相信的读者应该为这个简单的问题开发示例程序。</p><p>由于通常开发测试系统允许的所有树结构的应用程序是不切实际的，因此当需要更改结构时，这些程序就会失败。</p><p>为用户提供数据网络模型的系统也会遇到类似的困难。在树和网络情况下，用户（或其程序）都需要利用一组用户访问数据路径。这些路径是否与存储表示中的指针定义路径紧密对应并不重要——在 IDS 中，对应关系非常简单，在 TDMS 中则恰恰相反。无论存储的表示如何，其结果是终端活动和程序都依赖于用户访问路径的持续存在。</p><p>解决此问题的一个方法是采用以下策略：一旦定义了用户访问路径，它将不会过时，直到使用该路径的所有应用程序都过时为止。这种策略并不切实际，因为数据库用户社区的总体模型中的访问路径数量最终会变得非常大。</p><h3 id="1-3-数据的关系视图"><a href="#1-3-数据的关系视图" class="headerlink" title="1.3. 数据的关系视图"></a>1.3. 数据的关系视图</h3><p>这里使用术语“关系”的数学意义。给定集合 $S_1、S_2、… 、S_n$（不一定不同），如果 R 是一组 n 元组，每个 n 元组的第一个元素来自 $S_1$，第二个元素来自 $S_2$，依此类推，则 R 是这 n 个集合上的关系。我们将 $S_j$ 称为 R 的第 j 个域。如上所述，R 被称为度为 n。度为 1 的关系通常称为一元关系，度为 2 的关系称为二元关系，度为 3 的关系称为三元关系，度为 n 的关系称为 n 元关系。</p><p>出于解释的原因，我们将经常使用关系的数组表示，但必须记住，这种特定的表示并不是所阐述的关系观点的必要部分。表示 n 元关系 R 的数组具有以下属性：<br>(1) 每行代表 R 的 n 元组。<br>(2) 行的顺序无关紧要。<br>(3) 所有行都是不同的。<br>(4) 列的顺序很重要 - 它对应于定义 R 的域的顺序 $S_1、S_2、…、S_n$（但请参见下面关于域有序和域无序关系的注释）。<br>(5) 每列的重要性部分地通过用相应域的名称标记它来传达</p><p>图 1 中的示例说明了 4 度关系，称为供应，它反映了从指定供应商到指定项目的指定数量的在制品零件的发货情况。</p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241025174327590.png" alt="image-20241025174327590"></p><p>有人可能会问：如果列是用相应域的名称标记的，那么列的顺序为什么重要呢？如图 2 中的示例所示，两列可能具有相同的标题（表示相同的域），但就关系而言具有不同的含义。所描绘的关系称为组件。它是一个三元关系，其前两个域称为零件，第三个域称为数量。组件 (x, y, z) 的含义是零件 x 是零件 y 的直接组件（或子组件），并且需要零件 x 的 z 个单元来组装零件 y 的一个单元。它是在零件爆炸问题中起着关键作用的关系</p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241025174405853.png" alt="image-20241025174405853"></p><p>值得注意的是，现有的几个信息系统（主要是基于树形文件的信息系统）无法为具有两个或更多相同域的关系提供数据表示。当前版本的 IMS&#x2F;360 [5] 就是此类系统的一个例子。</p><p>数据库中的全部数据可以看作是随时间变化的关系的集合。这些关系有各种程度。随着时间的推移，每个 n 元关系可能会插入额外的 n 元组、删除现有的 n 元组以及更改其现有 n 元组中的任意一个的组件</p><p>然而，在许多商业、政府和科学数据库中，一些关系的度数相当高（30 度并不罕见）。用户通常不必记住任何关系的域顺序（例如，关系供应中的订购供应商，然后是零件，然后是项目，然后是数量）。</p><p>因此，我们建议用户不要处理按域排序的关系，而是处理其无序域对应关系。2 为实现这一点，域必须至少在任何给定关系中唯一可识别，而无需使用位置。因此，当有两个或多个相同的域时，我们在每种情况下都要求域名由独特的角色名称限定，该角色名称用于标识该域在给定关系中扮演的角色。例如，在图 2 的关系组件中，第一个域部分可能由角色名称 sub 限定，第二个域部分可能由 super 限定，这样用户就可以处理关系组件及其域（sub.part super.part，数量），而无需考虑这些域之间的任何顺序。</p><p>总之，建议大多数用户应该与由随时间变化的关系（而不是关系）集合组成的数据关系模型进行交互。每个用户只需知道关系的名称及其域的名称（必要时角色限定）即可。3 甚至这些信息也可能由系统以菜单形式提供（受安全和隐私约束），以应用户请求。</p><p>通常，为数据库建立关系模型有很多种替代方法。为了讨论首选方法（或范式），我们必须首先介绍一些额外的概念（活动域、主键、外键、非简单域），并与信息系统编程中当前使用的术语建立一些联系。在本文的其余部分，我们不会费心区分关系和关系，除非明确说明会更有利。</p><p>考虑一个数据库的例子，其中包括与零件、项目和供应商有关的关系。一个称为零件的关系在以下域上定义：</p><p>(1)零件编号</p><p>(2)零件名称</p><p>(3)零件颜色</p><p>(4)零件重量</p><p>(5)现有数量</p><p>(6)订单数量</p><p>可能还有其他域。实际上，这些域中的每一个都是一个值池，其中的部分或全部可能在任何时刻都表示在数据库中。虽然可以想象，在某个时刻，所有零件颜色都存在，但所有可能的零件重量、零件名称和零件编号都存在的可能性不大。我们将在某个时刻表示的值集称为该时刻的活动域</p><p>通常，给定关系的一个域（或域的组合）具有唯一标识该关系的每个元素（n 元组）的值。这样的域（或组合）称为主键。在上面的例子中，零件编号是主键，而零件颜色不是。如果主键是简单域（不是组合）或组合，使得参与的简单域中没有一个在唯一标识每个元素方面是多余的，则主键是非冗余的。关系可能拥有多个非冗余主键。如果不同的零件始终被赋予不同的名称，则在示例中就是这种情况。每当关系具有两个或多个非冗余主键时，就会任意选择其中一个并称为该关系的主键。</p><p>一个常见的要求是关系的元素交叉引用同一关系的其他元素或不同关系的元素。键提供了一种面向用户的方法（但不是唯一的方法）来表达这种交叉引用。如果关系 R 的域（或域组合）不是 R 的主键，但其元素是某个关系 S 的主键的值（不排除 S 和 R 相同的可能性），则我们称其为外键。在图 1 的关系供应中，供应商、零件、项目的组合是主键，而这三个域单独来看都是外键。</p><p>在以前的工作中，人们倾向于将数据库中的数据视为由两部分组成，一部分由实体描述（例如，供应商描述）组成，另一部分由各种实体或实体类型之间的关系组成（例如，供应关系）。当任何关系中都可能有外键时，这种区别很难保持。在用户的关系模型中，做出这样的区分似乎没有任何好处（但是，当将关系概念应用于用户关系集的机器表示时，可能会有一些好处）。</p><p>到目前为止，我们讨论了在简单域上定义的关系的例子——这些域的元素是原子（不可分解）值。非原子值可以在关系框架内讨论。因此，一些域可能将关系作为元素。这些关系又可以在非简单域上定义，等等。</p><p>例如，定义关系雇员的域之一可能是薪资历史。薪资历史域的一个元素是在域日期和域薪资上定义的二元关系。薪资历史域是所有此类二元关系的集合。在任何时刻，数据库中薪资历史关系的实例数与雇员数一样多。相比之下，雇员关系只有一个实例</p><p>当前数据库术语中的术语属性和重复组分别大致类似于简单域和非简单域。当前术语中的许多混淆是由于未能区分类型和实例（如“记录”）以及数据的用户模型组件与机器表示对应物（再次引用“记录”作为示例）。</p><h3 id="1-4-范式"><a href="#1-4-范式" class="headerlink" title="1.4 范式"></a>1.4 范式</h3><p>域都是简单的关系可以在存储中用上面讨论的二维列同质数组表示。对于具有一个或多个非简单域的关系，需要一些更复杂的数据结构。由于这个原因（以及下面要引用的其他原因），消除非简单域的可能性似乎值得研究。4 事实上，有一个非常简单的消除过程，我们称之为规范化。</p><p>例如，考虑图 3 (a) 中展示的关系集合。工作经历和子女是关系雇员的非简单域。工资历史是关系工作历史的非简单域。图 3 (a) 中的树显示了非简单域的这些相互关系</p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241025174950094.png" alt="image-20241025174950094"></p><p>规范化过程如下。从树顶部的关系开始，取其主键，并通过插入此主键域或域组合来扩展每个直接下属关系。</p><p>每个扩展关系的主键由扩展前的主键加上从父关系向下复制的主键组成。现在，从父关系中删除所有非简单域，删除树的顶部节点，并对每个剩余子树重复相同的操作序列。</p><p>规范化图 3 (a) 中的关系集合的结果是图 3 (b) 中的集合。每个关系的主键都以斜体显示，以显示这些键如何通过规范化进行扩展。</p><p>如果要应用上述规范化，则非规范化的关系集合必须满足以下条件：</p><p>（1）非简单域的相互关系图是树的集合。<br>（2）没有主键具有非简单的组成域。</p><p>作者不知道任何需要放宽这些条件的应用程序。规范化类型的进一步操作是可能的。本文不讨论这些。</p><p>当所有关系都以规范形式转换时，数组表示的简单性变得可行，这不仅有利于存储目的，而且有利于在使用不同数据表示的系统之间进行批量数据通信。通信形式将是数组表示的适当压缩版本，并具有以下优点：</p><p>（1）它将没有指针（地址值或位移值）。<br>（2）它将避免对哈希寻址方案的所有依赖。<br>（3）它不包含索引或排序列表</p><p>如果用户的关系模型是按照标准形式建立的，那么数据库中数据项的名称可以采用比其他情况更简单的形式。通用名称可以采用诸如 $R (g).r.d$ 的形式，其中 R 是关系名称；g 是代标识符（可选）；r 是角色名称（可选）；d 是域名。<br>由于只有当给定关系的几代存在或预计存在时才需要 g，而只有当关系 R 有两个或多个名为 d 的域时才需要 r，因此简单形式 R.d 通常是足够的</p><h3 id="1-5-一些语言方面"><a href="#1-5-一些语言方面" class="headerlink" title="1.5. 一些语言方面"></a>1.5. 一些语言方面</h3><p>如上所述，采用关系数据模型允许开发基于应用谓词演算的通用数据子语言。如果关系集合是范式，则一阶谓词演算就足够了。这种语言将为所有其他提议的数据语言提供语言能力的标准，并且本身将成为嵌入（经过适当的语法修改）各种宿主语言（编程、命令或面向问题）的有力候选者。虽然本文的目的不是详细描述这种语言，但它的显著特征如下。</p><p>让我们用 R 表示数据子语言，用 H 表示宿主语言。R 允许声明关系及其域。每个关系声明都标识该关系的主键。已声明的关系被添加到系统目录中，供具有适当授权的用户社区的任何成员使用。H 允许支持声明，这些声明可能不是永久的，表明这些关系在存储中是如何表示的。 R 允许从数据库中检索任何数据子集。对此类检索请求的操作受到安全约束。</p><p>数据子语言的通用性在于其描述能力（而非计算能力）。在大型数据库中，每个数据子集都具有大量可能的（且合理的）描述，即使我们假设（正如我们所假设的）系统只能访问一组有限的函数子例程来限定要检索的数据。因此，可用于集合规范的限定表达式类必须具有应用谓词演算的合式公式类的描述能力。众所周知，为了保持这种描述能力，没有必要（无论选择哪种语法）表达所选谓词演算的每个公式。例如，只要前缀范式中的公式就足够了 [9]。</p><p>检索语句的限定或其他部分可能需要算术函数。此类函数可以在 H 中定义并在 R 中调用。</p><p>如此指定的集合可能仅用于查询目的，也可能被保留以备可能发生的更改。插入采取向声明的关系添加新元素的形式，而不考虑其机器表示中可能存在的任何顺序。对社区（而不是单个用户或子社区）有效的删除采取从声明的关系中删除元素的形式。如果在 R 中声明了指定关系之间的删除和更新依赖关系，则某些删除和更新可能会由其他删除和更新触发。对数据采取的观点对用于检索数据的语言的一个重要影响是数据元素和集合的命名。上一节讨论了这方面的一些方面。使用通常的网络视图，用户通常会被创造和使用比绝对必要的更多的关系名称所困扰，因为名称与路径（或路径类型）相关联，而不是与关系相关联。一旦用户知道存储了某个关系，他将期望能够使用其参数作为“已知”和其余参数作为“未知”的任意组合来利用它，因为信息（如 Everest）就在那里。这是一个系统特性（许多当前信息系统都缺少这个特性），我们将其称为（逻辑上）对称关系利用。当然，性能上的对称性是不可预期的。</p><p>为了支持对称利用单个二元关系，需要两条有向路径。对于 n 度关系，要命名和控制的路径数是 n 阶乘。</p><p>同样，如果采用关系视图，其中每个 n 元关系（n &gt; 2）都必须由用户表示为仅涉及二元关系的嵌套表达式（例如，参见 Feldman 的 LEAP 系统 [10]），则必须创造 $2n -1$ 个名称，而不是仅使用 1.2 节中所述的直接 n 元表示法创造 $n + 1$ 个名称。例如，图 1 中的 4-ary 关系 supply 在 n 元表示法中需要 5 个名称，在嵌套二元表示法中将以 $P（供应商，Q（零件，R（项目，数量）））$的形式表示，因此使用 7 个名称。</p><p>这种表达方式的另一个缺点是它的不对称性。虽然这种不对称性并不妨碍对称利用，但它肯定会使用户表达某些查询基础非常困难（例如，考虑通过 Q 和 R 查询与某些给定项目相关的零件和数量）。 </p><h3 id="1-6-可表达、命名和存储关系"><a href="#1-6-可表达、命名和存储关系" class="headerlink" title="1.6. 可表达、命名和存储关系"></a>1.6. 可表达、命名和存储关系</h3><p>与数据库相关联的是两个关系集合：命名集和可表达集。命名集是用户社区可以通过简单名称（或标识符）识别的所有关系的集合。 </p><p>当适当授权的用户声明 R 时，关系 R 获得命名集合的成员资格；当适当授权的用户取消 R 的声明时，它失去成员资格。 </p><p>可表达集是可以通过数据语言中的表达式指定的关系的总集合。这些表达式由命名集中关系的简单名称、世代、角色和域的名称、逻辑连接词构成；谓词演算的量词；6 和某些常量关系符号，如 &#x3D;、&gt;。</p><p>命名集是可表达集的子集——通常是一个非常小的子集。</p><p>由于命名集中的一些关系可能是该集合中其他关系的时间无关组合，因此考虑将定义这些时间无关约束的语句集合与命名集相关联是很有用的。</p><p>我们将推迟对此的进一步讨论，直到我们介绍了几个关系操作（参见第 2 节）。<br>数据系统的设计人员面临的一个主要问题是确定要支持的存储表示类别，该系统要为其用户提供关系模型。理想情况下，允许的数据表示的多样性应该刚好足以覆盖整个安装集合的性能要求范围。种类太多会导致不必要的存储开销和对当前有效结构的描述的不断重新解释。</p><p>对于任何选定的存储表示类型，数据系统必须提供一种手段，将以关系模型的数据语言表达的用户请求转换为当前存储表示上的相应且高效的操作。对于高级数据语言来说，这是一个具有挑战性的设计问题。然而，这是一个必须解决的问题——随着越来越多的用户同时访问大型数据库，提供高效响应和吞吐量的责任从单个用户转移到数据系统。</p><h2 id="2-冗余和一致性"><a href="#2-冗余和一致性" class="headerlink" title="2. 冗余和一致性"></a>2. 冗余和一致性</h2><h3 id="2-1-关系上的操作"><a href="#2-1-关系上的操作" class="headerlink" title="2.1. 关系上的操作"></a>2.1. 关系上的操作</h3><p>由于关系是集合，因此所有常见的集合操作都适用于它们。但是，结果可能不是关系；例如，二元关系和三元关系的并集不是关系。</p><p>下面讨论的操作专门用于关系。引入这些操作是因为它们在从其他关系派生关系方面起着关键作用。它们的主要应用是在非推理信息系统（不提供逻辑推理服务的系统）中，尽管添加此类服务并不一定会破坏它们的适用性。 </p><p>大多数用户不会直接关注这些操作。但是，信息系统设计人员和关注数据库控制的人员应该非常熟悉它们。 </p><h4 id="2-1-1-排列。"><a href="#2-1-1-排列。" class="headerlink" title="2.1.1. 排列。"></a>2.1.1. 排列。</h4><p>二元关系具有包含两列的数组表示。交换这些列可得出逆关系。更一般地，如果对 n 元关系的列应用排列，则结果关系被称为给定关系的排列。例如，如果我们包括保持列顺序不变的身份排列，则图 1 中的关系供应有 4！–24 种排列。<br>由于用户的关系模型由关系集合（域无序关系）组成，因此排列与单独考虑的这种模型无关。</p><p>但是，它与模型的存储表示的考虑有关。在提供关系对称利用的系统中，存储关系可回答的查询集与该关系的任何排列可回答的查询集相同。虽然从逻辑上讲，没有必要同时存储关系及其某些排列，但出于性能考虑，建议这样做</p><h4 id="2-1-2-投影。"><a href="#2-1-2-投影。" class="headerlink" title="2.1.2. 投影。"></a>2.1.2. 投影。</h4><p>假设现在我们选择一个关系的某些列（删除其他列），然后从结果数组中删除行中的任何重复项。最终数组表示一个关系，该关系被称为给定关系的投影。</p><p>选择运算符 $\pi$ 用于获得任何所需的排列、投影或两个操作的组合。因此，如果 L 是 k 索引列表 $ L &#x3D; i_1,i_2, • • • , i_k $并且 R 是 n 元关系 (n &gt; k)，则 ${\pi}_L (R)$ 是 k 元关系，其第 j 列是 $R (j &#x3D; 1, 2, … , k)$ 的列 $i_j$，只是结果行中的重复项被删除。考虑图 1 的关系供应。图 4 展示了此关系的排列投影。请注意，在这种特殊情况下，投影的 n 元组少于它所衍生的关系</p><h4 id="2-1-3-连接"><a href="#2-1-3-连接" class="headerlink" title="2.1.3. 连接"></a>2.1.3. 连接</h4><p>假设我们给定两个二元关系，它们有一些共同的定义域。在什么情况下我们可以将这些关系组合起来形成三元关系，以保留给定关系中的所有信息？</p><p>图 5 中的示例显示了两个关系 R、S，它们可以连接且不会丢失信息，而图 6 显示了 R 与 S 的连接。如果存在三元关系 U 使得 $\pi_{12}(U) &#x3D; R$ 且 $\pi_{23}(U) &#x3D; S$，则二元关系 R 可以与二元关系 S 连接。任何这样的三元关系称为 R 与 S 的连接。如果 R、S 是二元关系，使得 $π_2(R) &#x3D; π_1(S)$，则 R 可以与 S 连接。</p><p>在这种情况下始终存在的一个连接是 R 与 S 的自然连接，其定义为$ R<em>S &#x3D; {(a,b,c):R(a,b) \and S(b,c)}$，其中如果 (a, b) 是 R 的成员，则 R (a, b) 的值为 true，对于 S (b, c) 也是如此。立即得出 $\pi_{12} (R</em>S) &#x3D; R$ 且 $\pi_{23} (R*S) &#x3D; S$。</p><p>请注意，图 6 中所示的连接是图 5 中 R 与 S 的自然连接。图 7 中显示了另一个连接。</p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241025191236483.png" alt="image-20241025191236483"></p><p>检查这些关系会发现域部分（要进行连接的域）的一个元素（元素 1），其属性是它在 R 和 S 下都拥有多个关系。正是这个元素产生了多个连接。连接域中的这种元素被称为 R 与 S 连接的歧义点。</p><p>如果 $\pi_{21} (R)$ 或 S 是函数，则在连接 R 和 S 时不会出现歧义。在这种情况下，R 和 S 的自然连接是 R 和 S 的唯一连接。请注意，重申“R 和 S”的限定是必要的，因为 S 可能可以与 R 连接（以及 R 和 S 连接），并且这种连接将是一个完全独立的考虑。在图 5 中，关系$ R、\pi_{21} (R)、S、\pi_{21} (S)$ 都不是函数。</p><p>R 和 S 连接中的歧义有时可以通过其他关系来解决。假设我们得到或可以从独立于 R 和 S 的来源推导出域 project 和 supplier 上的关系 T，具有以下属性：<br>$$<br>\left( 1 \right) \ \pi _1\left( T \right) &#x3D;\pi _2\left( S \right) ,<br>$$<br>$$<br>\left( 2 \right) ,,\pi _2\left( T \right) &#x3D;\pi _1\left( R \right) ,<br>$$<br>$$<br>\left( 3 \right) \ T\left( j,s \right) \rightarrow \exists p\left( R\left( S,p \right) \land S\left( p,j \right) \right) ,<br>$$<br>$$<br>\left( 4 \right) ,,R\left( s,p \right) \rightarrow \exists j\left( S\left( p,j \right) \land T\left( j,s \right) \right) ,<br>$$<br>$$<br>\left( 5 \right) ,,S\left( p,j \right) \rightarrow \exists s\left( T\left( j,s \right) \land R\left( s,p \right) \right) ,<br>$$</p><p>那么我们可以形成 R、S、T 的三向连接；也就是说，三元关系如下：<br>$$<br>\pi _{12}\left( U \right) &#x3D;R,\ \pi _{23}\left( U \right) &#x3D;S,\ \pi _{31}\left( U \right) &#x3D;T<br>$$<br>这种连接将被称为循环 3 连接，以区别于线性 3 连接，后者是四元关系 V<br>$$<br>\pi _{12}\left( V \right) &#x3D;R,\ \pi _{23}\left( V \right) &#x3D;S,\ \pi _{34}\left( V \right) &#x3D;T<br>$$<br>虽然可能存在多个循环 3 连接（参见图 8、9 的示例），但发生这种情况的情况需要更严格的约束</p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241026154407269.png" alt="image-20241026154407269"></p><p>比多个 2-连接更复杂。具体来说，关系 R、S、T 必须具有关于连接 R 与 S（例如点 x）、S 与 T（例如y ）以及 T 与 R（例如 z）的歧义点，而且，y 必须是 S 下 x 的亲属，z 必须是 T 下 y 的亲属，x 必须是 R 下 z 的亲属。请注意，在图 8 中，点 $x &#x3D; a; y &#x3D; d; z &#x3D; 2 $具有此属性</p><p>三个二元关系 R、S、T 的自然线性 3 连接由以下公式给出<br>$$<br>\pi _{12}\left( U \right) &#x3D;R,\ \pi _{23}\left( U \right) &#x3D;S,\ \pi _{31}\left( U \right) &#x3D;T<br>$$<br>其中左侧不需要括号，因为自然的 2 连接 (*) 是结合的。为了获得循环对应项，我们引入运算符 .y，它通过将 n 度关系的两端连接在一起，从 n 度关系生成 n-ary关系。因此，如果 R 是 n 元关系 (n &gt; 2)，则 R 的连接由以下等式定义<br>$$<br>\pi _{12}\left( U \right) &#x3D;R,\ \pi _{23}\left( U \right) &#x3D;S,\ \pi _{31}\left( U \right) &#x3D;T<br>$$<br>将线性和循环 3 连接及其自然对应概念扩展到 n 个二元关系（其中 n &gt; 3）的连接是显而易见的。不过，关于不一定是二元的关系的连接，可能还需要说几句话。考虑两个关系 R（度 r）、S（度 s）的情况，它们要在它们的域 p 上连接（p &lt; r，p &lt; s）。为简单起见，假设这 p 个域是 R 的 r 个域中的最后一个 p，以及 S 的 s 个域中的第一个 p。如果不是这样，我们总是可以应用适当的排列来实现这一点。现在，取 R 的前 r-p 个域的笛卡尔积，并将这个新域称为 A。取 R 的最后 p 个域的笛卡尔积，并将其称为 B。取 S 的最后 s-p 个域的笛卡尔积，并将其称为 C。</p><p>我们可以将 R 视为域 A、B 上的二元关系。同样，我们可以将 S 视为域 B、C 上的二元关系。线性和循环 3 连接的概念现在可直接应用。可以对不同程度的 n 个关系的线性和循环 n 连接采取类似的方法</p><h4 id="2-1-4-组合"><a href="#2-1-4-组合" class="headerlink" title="2.1.4. 组合"></a>2.1.4. 组合</h4><p>读者可能熟悉组合概念在函数中的应用。我们将讨论该概念的泛化，并首先将其应用于二元关系。我们对组合和可组合性的定义非常直接地基于上面给出的连接和可连接性的定义。</p><p>假设我们给定两个关系 R、S。如果存在 R 与 S 的连接 U 使得 $T &#x3D; \pi_{13} (U)$，则 T 是 R 与 S 的组合。因此，当且仅当两个关系可连接时，它们才是可组合的。但是，R 与 S 存在多个连接并不意味着 R 与 S 存在多个组合</p><p>与 R 与 S 的自然连接相对应的是 R 与 S 的自然组合，其定义如下<br>$$<br>R \cdot S &#x3D; \pi_{13}(R*S)<br>$$<br>以图 5 中的关系 R、S 为例，它们的自然组合如图 10 所示，而另一种组合如图 11 所示（源自图 7 所示的连接）。</p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241101141758636.png" alt="image-20241101141758636"></p><p>当存在两个或多个连接时，不同组合的数量可能少至一个，也可能多至与不同连接的数量一样多。图 12 显示了两个关系的示例，它们具有多个连接但只有一个组合。<br>请注意，由于通过点 a、b、d、e 建立了明确的关联，因此在将 R 与 S 组合时，点 c 的歧义性会消失。</p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241101141851476.png" alt="image-20241101141851476"></p><p>将组合扩展到不一定是二元的（并且可能具有不同程度）关系对，其模式与将成对连接扩展到此类关系的模式相同。</p><p>由于缺乏对关系组合的理解，一些系统设计人员陷入了所谓的连接陷阱。可以用以下示例来描述此陷阱。假设每个供应商描述都通过指向该供应商提供的每个零件的描述的指针链接，并且每个零件描述同样链接到使用该零件的每个项目的描述。现在得出一个结论，该结论通常是错误的：即，如果从给定供应商通过他提供的零件到使用这些零件的项目遵循所有可能的路径，则将获得该供应商提供的所有项目的有效集合。这样的结论仅在非常特殊的情况下才是正确的，即项目和供应商之间的目标关系实际上是其他两个关系的自然组合——我们通常必须添加短语“永远”，因为这通常隐含在有关路径跟踪技术的权利要求中。</p><h4 id="2-1-5-限制。"><a href="#2-1-5-限制。" class="headerlink" title="2.1.5. 限制。"></a>2.1.5. 限制。</h4><p>关系的子集是关系。关系 S 作用于关系 R 以生成 R 的子集的一种方式是通过对 R 进行 S 操作限制。此操作是将函数限制为其域的子集的推广，定义如下。</p><p>假设 L, M 为等长索引列表，且$ L &#x3D; i_1,i_2, … i_k, M &#x3D; j_1,j_2,…,j_k，$其中 k 小于等于 R 的度数，k 小于等于 S 的度数。则 L, M 对 R 的限制（记为 $R_{L|M}S$）为 R 的最大子集 R’，且<br>$$<br>\pi_{L}(R’)&#x3D;\pi_M(S)<br>$$<br>仅当对于所有 $h &#x3D; 1, 2, • • •, k$，$ \pi_{i_h}(R)$ 中的元素与 $\pi_{j_h} (S)$ 中的元素之间相等时，该运算才有定义。</p><p>图 13 中的三个关系 R、S、R’ 满足方程 $R’&#x3D;R_{(2,3)|(1.2)}S$。</p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241101142736775.png" alt="image-20241101142736775"></p><p>我们现在可以考虑这些操作在关系上的各种应用。</p><h3 id="2-2-冗余"><a href="#2-2-冗余" class="headerlink" title="2.2. 冗余"></a>2.2. 冗余</h3><p>命名关系集中的冗余必须与存储表示集中的冗余区分开来。我们主要关注前者。<br>首先，我们需要一个精确的关系可导性概念。</p><p>假设 $\theta$是关系操作的集合，每个操作都具有从其操作数产生唯一关系的属性（因此自然连接是合格的，但连接不是）。如果存在来自集合 0 的操作序列，该序列在所有时间内从 S 的成员产生 R，则关系 R 可以从关系集 S 中 $\theta-derivable$ 导出。<br>之所以使用“所有时间”一词，是因为我们正在处理随时间变化的关系，我们感兴趣的是可导性，该可导性在相当长的一段时间内成立。对于非推理系统中的命名关系集，似乎适当的集合 $\theta_1$ 包含以下操作：投影、自然连接、绑定和限制。<br>置换无关紧要，自然组合也无需包括在内，因为它可以通过自然连接然后投影获得。对于存储的表示集，足够的操作集合 ~ 将包括置换和与子集和合并关系以及排序和连接其元素有关的附加操作。</p><h4 id="2-2-1-强冗余"><a href="#2-2-1-强冗余" class="headerlink" title="2.2.1. 强冗余"></a>2.2.1. 强冗余</h4><p>如果一组关系至少包含一个关系，该关系具有可从该集合中其他关系投影导出的投影，则该组关系为强冗余。以下两个示例旨在解释为什么以这种方式定义强冗余，并展示其实际用途。在第一个示例中，关系集合仅由以下关系组成：</p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241104162719166.png" alt="image-20241104162719166"></p><p>以 serial# 作为主键，manager# 作为外键。我们用 ,~ 表示活动域，并假设</p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241104162751479.png" alt="image-20241104162751479"></p><p>对于所有时间 t。在这种情况下，冗余是显而易见的：域管理器名称是不必要的。为了看出它是如上定义的强冗余，我们观察到<br>$$<br>\pi_{34}(employee)&#x3D;\pi_{12}(employee)_{1|1}\pi_3(employee)<br>$$<br>在第二个示例中，关系集合包括关系 S（使用主键 s# 描述供应商）、关系 D（使用主键 d# 描述部门）、关系 J（使用主键 j# 描述项目）以及以下关系：</p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241104162809915.png" alt="image-20241104162809915"></p><p>其中，在每种情况下，表示除 s#、d#、j# 之外的域。假设已知以下条件 C 与时间无关：供应商 s 供应部门 d（关系 P），当且仅当供应商 s 供应某个项目 j（关系 Q），而 d 被分配到该项目 j（关系 R）。然后，我们可以写出方程<br>$$<br>\pi_{12}(P)&#x3D;\pi_{12}(Q) \cdot \pi_{21}(R)<br>$$<br>从而表现出很强的冗余度。</p><p>命名关系集中存在强冗余的一个重要原因是用户的便利性。一个特殊的例子是保留命名集中的半过时关系，以便通过名称引用它们的旧程序可以继续正确运行。了解命名集中存在强冗余使系统或数据库管理员在选择存储表示时有更大的自由度，以更有效地应对当前流量。如果命名集中的强冗余直接反映在存储集中的强冗余中（或者如果将其他强冗余引入存储集中），那么一般来说，会消耗额外的存储空间和更新时间，从而可能减少某些查询的查询时间和中央处理单元的负载。</p><h4 id="2-2-2-弱冗余"><a href="#2-2-2-弱冗余" class="headerlink" title="2.2.2. 弱冗余"></a>2.2.2. 弱冗余</h4><p>可能存在第二种类型的冗余。与强冗余相反，它不以方程式为特征。如果关系集合包含一个关系，该关系具有一个投影，该投影不能从其他成员中导出，但始终是集合中其他关系投影的某个连接的投影，则该关系集合是弱冗余的。</p><p>我们可以通过采用第二个强冗余示例（上面引用）来展示弱冗余，现在假设条件 C 并不总是成立。关系 $\pi_{12} (P)、\pi_{12} (Q)、\pi_{12} (R)$ 是复杂的 l° 关系，在任意两个关系的潜在连接中，可能会不时出现歧义点。在这种情况下，它们都不能从其他两个关系中推导出来。然而，它们之间确实存在约束，因为每个约束都是它们三个的某个循环连接的投影。弱冗余之一可以用以下语句来描述：对于所有时间，$\pi_{12} (P)$ 都是$\pi_{12} (Q)$ 与 $\pi_{21} (R)$ 的某种组合。所讨论的组合在某个时刻可能是自然的，而在另一个时刻可能是非自然的。</p><p>一般而言，弱冗余是用户群体逻辑需求所固有的。系统或数据库管理员无法移除它们。如果它们出现，它们会同时出现在命名集和存储的表示集中。</p><h3 id="2-3-一致性"><a href="#2-3-一致性" class="headerlink" title="2.3. 一致性"></a>2.3. 一致性</h3><p>每当命名关系集在任何意义上是冗余的，我们将与该集合关联一组语句，这些语句定义了成员关系之间独立于时间的所有冗余。如果信息系统缺乏（而且很可能缺乏）关于每个命名关系的详细语义信息，它就无法推断出适用于命名集的冗余。它可能会在一段时间内尝试引入冗余，但这种尝试可能会出错</p><p>给定一个随时间变化的关系集合 C、一个相关的约束语句集 Z 和一个 C 的瞬时值 V，我们将根据 V 是否满足 Z 来称状态 (C, Z, V) 是一致的还是不一致的。<br>例如，给定存储的关系 R、S、T 和约束语句$\pi_{12}(T)$ 是 $\pi_{12}(R)$ 与 $\pi_{12} (S)$ 的组合”，我们可以不时地检查存储的 R、S、T 的值是否满足此约束。进行此检查的算法将检查 R、S、T 的前两列（无论它们在系统中以何种方式表示），并确定是否</p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241101145641771.png" alt="image-20241101145641771"></p><p>在对一系列关系进行即时快照时，存在一些实际问题（我们在此不讨论），其中一些关系可能非常大且高度可变</p><p>值得注意的是，如上定义的一致性是数据库瞬时状态的属性，与该状态如何产生无关。因此，具体而言，不会根据用户是否因疏忽或故意而产生不一致做出区分。通过一个简单的例子，我们将展示这种（可能非常规的）一致性方法的合理性。</p><p>假设命名集合 C 包括第 2.2 节示例中的关系 $S、J、D、P、Q、R$，并且 $P、Q、R$ 具有其中描述的强冗余或弱冗余（在现在考虑的特定情况下，发生哪种冗余并不重要）。此外，假设在某个时间 t，数据库状态一致且不包含项目 j，因此供应商 2 供应项目 j，并且 j 被分配给部门 5。因此，$\pi_{12}(P)$中没有元素 (2, 5)。现在，用户通过将某个适当的元素插入 P 中，将元素 (2, 5) 引入 $\pi_{12}(P)$。数据库状态现在不一致。<br>如果输入 (2, 5) 正确，并且确实存在项目 j，供应商 2 供应 j，并且 j 被分配给部门 5，则不一致可能是由于疏忽造成的。在这种情况下，用户很可能打算在不久的将来将元素插入 Q 和 R，这将导致将 (2, j) 引入 $\pi_{12}(Q)$ 和将 (5, j) 引入 $\pi_{12}(Q)$。另一方面，输入 (2, 5) 可能有误。用户可能打算将其他元素插入 P——插入该元素会将一致状态转变为一致状态。关键在于，系统通常无法在不询问其环境（可能是造成不一致的用户）的情况下解决这个问题</p><p>当然，系统可以通过多种方式检测不一致并做出响应。在一种方法中，系统会在插入、删除或密钥更新时检查可能的不一致。当然，这种检查会减慢这些操作的速度。如果产生了不一致，则会在内部记录详细信息，如果在合理的时间间隔内未纠正，则会通知用户或负责数据安全性和完整性的人员。另一种方法是每天一次或更少地以批处理操作的形式进行一致性检查。如果系统维护所有状态变化交易的日志，则可以追踪检查时数据库中仍存在不一致的输入。如果发生的非暂时性不一致很少，后一种方法肯定会更好。</p><h3 id="2-4-总结"><a href="#2-4-总结" class="headerlink" title="2.4. 总结"></a>2.4. 总结</h3><p>在第 1 节中，我们提出了一种关系数据模型，作为保护格式化数据系统用户免受数据库增长和流量变化导致的数据表示形式可能出现的破坏性变化的基础。<br>介绍了一种随时间变化的关系集合的范式。</p><p>第 2 节定义了关系操作和两种类型的冗余，并将其应用于维护数据一致性的问题。随着越来越多不同类型的数据集成到公共数据库中，这必将成为一个严重的实际问题。</p><p>提出了许多问题，但这些问题尚未得到解答。例如，第 1.4 节中只提到了数据子语言的一些更重要的属性。既没有讨论这种语言的纯语言细节，也没有讨论实现问题。尽管如此，所提供的材料应该足以让经验丰富的系统程序员直观地了解几种方法。还希望本文能够提高格式化数据系统工作的精确度。</p><p>致谢。IBM Poughkeepsie 的 C. T. Davies 说服了作者未来信息系统中数据独立性的必要性。作者要感谢他以及 IBM 圣何塞研究实验室的 F. P. Palermo、C. P. Wang、E. B. Altman 和 M. E. Senko 的有益讨论。</p>]]></content>
    
    
    <categories>
      
      <category>论文导读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MarsCode-二分数字组合</title>
    <link href="/2024/11/03/Marscode-%E4%BA%8C%E5%88%86%E6%95%B0%E5%AD%97%E7%BB%84%E5%90%88/"/>
    <url>/2024/11/03/Marscode-%E4%BA%8C%E5%88%86%E6%95%B0%E5%AD%97%E7%BB%84%E5%90%88/</url>
    
    <content type="html"><![CDATA[<h1 id="二分数字组合"><a href="#二分数字组合" class="headerlink" title="二分数字组合"></a>二分数字组合</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>小F面临一个有趣的挑战：给定一个数组，她需要将数组中的数字分为两组。分组的目标是使得一组数字的和的个位数等于给定的 A，另一组数字的和的个位数等于给定的 B。除此之外，还有一种特殊情况允许其中一组为空，但剩余数字和的个位数必须等于 A 或 B。小F需要计算所有可能的划分方式。</p><p>例如，对于数组 <code>[1, 1, 1]</code> 和目标 A &#x3D; 1，B &#x3D; 2，可行的划分包括三种：每个 1 单独作为一组，其余两个 1 形成另一组。如果 A &#x3D; 3，B &#x3D; 5，当所有数字加和的个位数为 3 或 5 时，可以有一组为非空，另一组为空。</p><hr><h2 id="测试样例"><a href="#测试样例" class="headerlink" title="测试样例"></a>测试样例</h2><p><em><strong>样例1：</strong></em></p><blockquote><p>输入：<code>n = 3,A = 1,B = 2,array_a = [1, 1, 1]</code><br>输出：<code>3</code></p></blockquote><p><em><strong>样例2：</strong></em></p><blockquote><p>输入：<code>n = 3,A = 3,B = 5,array_a = [1, 1, 1]</code><br>输出：<code>1</code></p></blockquote><p><em><strong>样例3：</strong></em></p><blockquote><p>输入：<code>n = 2,A = 1,B = 1,array_a = [1, 1]</code><br>输出：<code>2</code></p></blockquote><p><em><strong>样例4：</strong></em></p><blockquote><p>输入：<code>n = 5,A = 3,B = 7,array_a = [2, 3, 5, 7, 9]</code><br>输出：<code>0</code></p></blockquote><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="解法一-DFS"><a href="#解法一-DFS" class="headerlink" title="解法一 DFS"></a>解法一 DFS</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">solution</span>(<span class="hljs-params">n, A, B, array_a</span>):    <br>    <span class="hljs-comment"># 处理特殊情况：如果一组可以为空</span><br>    total_sum = <span class="hljs-built_in">sum</span>(array_a) % <span class="hljs-number">10</span><br>    <span class="hljs-keyword">if</span> total_sum == A <span class="hljs-keyword">or</span> total_sum == B:<br>        result = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">else</span>:<br>        result = <span class="hljs-number">0</span><br>    <br>    <span class="hljs-comment"># 使用 DFS 处理一般情况</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">index, sumA, sumB</span>):<br>        <span class="hljs-comment"># 如果已经处理到末尾</span><br>        <span class="hljs-keyword">if</span> index == n:<br>            <span class="hljs-keyword">if</span> sumA % <span class="hljs-number">10</span> == A <span class="hljs-keyword">and</span> sumB % <span class="hljs-number">10</span> == B:<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <br>        current_number = array_a[index]<br><br>        <span class="hljs-keyword">return</span> dfs(index + <span class="hljs-number">1</span>, sumA + current_number, sumB)+dfs(index + <span class="hljs-number">1</span>, sumA, sumB + current_number)<br><br>    <span class="hljs-comment"># 加上一般情况的结果</span><br>    result += dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br><br>    <span class="hljs-keyword">return</span> result<br><br><span class="hljs-comment"># 测试用例</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]) == <span class="hljs-number">3</span>)<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]) == <span class="hljs-number">1</span>)<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]) == <span class="hljs-number">2</span>)<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>, [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>]) == <span class="hljs-number">0</span>)<br><br></code></pre></td></tr></table></figure><p>时间复杂度$O(2^n)$，出现超时</p><h3 id="解法二-动态规划"><a href="#解法二-动态规划" class="headerlink" title="解法二 动态规划"></a>解法二 动态规划</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">solution</span>(<span class="hljs-params">n, A, B, array_a</span>):<br>    <span class="hljs-comment"># Please write your code here</span><br>    <span class="hljs-comment"># 先处理特殊情况，即一组为空</span><br>    total_sum = <span class="hljs-built_in">sum</span>(array_a)<br>    total_sum_mod = total_sum % <span class="hljs-number">10</span><br>    <span class="hljs-keyword">if</span> total_sum_mod == A <span class="hljs-keyword">or</span> total_sum_mod == B:<br>        result = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">else</span>:<br>        result = <span class="hljs-number">0</span><br><br>    <span class="hljs-comment"># 初始化动态规划表，dp[i][modA][modB] 表示前 i 个元素，A 和 B 组个位数分别为 modA 和 modB 的方式数</span><br>    dp = [[[<span class="hljs-number">0</span>] * <span class="hljs-number">10</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n + <span class="hljs-number">1</span>)]<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>  <span class="hljs-comment"># 初始化条件：没有元素时，和为 0</span><br>    <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>        num = array_a[i - <span class="hljs-number">1</span>] % <span class="hljs-number">10</span>  <span class="hljs-comment"># 当前数字取个位数</span><br>        <span class="hljs-keyword">for</span> modA <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>            <span class="hljs-keyword">for</span> modB <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>                <span class="hljs-keyword">if</span> dp[i - <span class="hljs-number">1</span>][modA][modB] &gt; <span class="hljs-number">0</span>:<br>                    <span class="hljs-comment"># 选择将当前数字加入到 A 组</span><br>                    new_modA = (modA + num) % <span class="hljs-number">10</span><br>                    dp[i][new_modA][modB] += dp[i - <span class="hljs-number">1</span>][modA][modB]<br>                    <br>                    <span class="hljs-comment"># 选择将当前数字加入到 B 组</span><br>                    new_modB = (modB + num) % <span class="hljs-number">10</span><br>                    dp[i][modA][new_modB] += dp[i - <span class="hljs-number">1</span>][modA][modB]<br>                    <br>    result += dp[n][A][B]<br>    <span class="hljs-keyword">return</span> result<br></code></pre></td></tr></table></figure><p><strong>时间复杂度</strong>：<code>O(n * 10 * 10)</code>，因为我们需要遍历每个数字，并在 10 个 <code>modA</code> 和 10 个 <code>modB</code> 状态中更新。</p><p><strong>空间复杂度</strong>：<code>O(n * 10 * 10)</code>，存储动态规划表。</p>]]></content>
    
    
    <categories>
      
      <category>MarsCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HUST-SE数字图像处理复习</title>
    <link href="/2024/10/31/HUST-SE%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%A4%8D%E4%B9%A0/"/>
    <url>/2024/10/31/HUST-SE%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="HUST-SE-DIP2024考试"><a href="#HUST-SE-DIP2024考试" class="headerlink" title="HUST SE-DIP2024考试"></a>HUST SE-DIP2024考试</h1><blockquote><p>基本和老师划的重点一致，需要理解和背诵。</p></blockquote><h2 id="简答"><a href="#简答" class="headerlink" title="简答"></a>简答</h2><p>数据量的计算</p><p>5个纹理描述子</p><p>同时对比度，原因</p><p>自适应局部降噪滤波，优点</p><p>基于区域生长的彩色图像分割方法</p><p>离散傅里叶卷积变化公式和应用傅里叶描述子描述纹理的方法</p><h2 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h2><p>通过概率密度函数解释直方图均衡化原理，直方图均衡化步骤，具体数值的均衡化</p><p>二维离散卷积的公式，计算步骤，具体数值的操作</p><h2 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h2><p>消除椒盐噪声的方法，消除周期性噪声的方法，opencv代码（图像的读取，显示，处理，保存）</p><h1 id="数字图像处理复习重点"><a href="#数字图像处理复习重点" class="headerlink" title="数字图像处理复习重点"></a>数字图像处理复习重点</h1><h2 id="一-图像处理的基本概念与术语"><a href="#一-图像处理的基本概念与术语" class="headerlink" title="一. 图像处理的基本概念与术语"></a>一. 图像处理的基本概念与术语</h2><ol><li>数字图像：以二位数字形式表现的图像，其单元为像元</li><li>数字图像处理：利用计算机进行图像处理</li><li><strong>亮度函数 入射分量 反射分量</strong> $I&#x3D;f(x,y,z,\gamma,t), i(x,y), r(x,y)$</li><li><strong>图像分辨率 图像深度 灰度级 动态范围</strong> ：图像中可分辨的最小细节 在位图图像中，表示各像素点亮度或彩色信息的二进制位数 2的整数次幂 灰度跨越的值域</li><li>色彩的基本属性 RGB <strong>HSI</strong> ：红绿蓝三原色（加色混合模型） 色调，饱和度，亮度</li><li>主观颜色 安全色 ： 216种安全色</li><li><strong>灰度直方图 累计直方图</strong> 连续图像幅度的密度函数，幅度分布函数 ：横坐标为灰度级的值，纵坐标为某个灰度级出现的次数的统计图 </li><li>点运算 代数运算 几何运算：比如改变亮度，对比度等 图像之间的点对点运算 设计到空间位置变化，如灰度插值</li><li>双线性插值：使用4个最近邻的灰度来计算给定位置的灰度</li><li>线性系统 移不变系统 <strong>线性移不变系统</strong>：叠加原理和齐次原理 如果输入序列进行移位，则输出序列进行相应的移位 具有移不变特性的线性系统</li><li>单位冲击 单位冲击响应：狄拉克函数 系统的输入是单位冲击时得到的输出</li><li><strong>卷积</strong></li><li><strong>图像幅值信息量 信息熵</strong> </li><li>积分变换</li><li><strong>傅里叶变换对 傅里叶振幅谱 傅里叶相位谱 傅里叶能量谱</strong> ：振幅谱$|F(u,v)|$相位谱$\phi(u,v)&#x3D;arctg\frac{I(u,v)}{R(u,v)}$能量谱$E(u,v)&#x3D;|F(u,v)|^2$</li><li><del>快速傅里叶变换FFT</del></li><li>图像增强技术 图像复原技术：主观 客观</li><li><strong>动态范围 灰度级</strong></li><li><strong>直方图均衡化</strong> 直方图规定化 图像平滑 图像锐化</li><li>空域增强（滤波） 频域增强（滤波） 同态增强（滤波）</li><li><del>数字压缩图像的均方信噪比</del></li><li><del>香农信息保持定理 图像冗余度 编码效率</del></li><li><del>有损压缩 无损压缩</del></li><li><del>率失真理论</del></li><li>假色彩与伪色彩</li><li><del>影像融合</del></li><li>图像腐蚀、膨胀、闭操作、开操作、边界提取、区域填充、连通区域提取</li></ol><h2 id="二-典型图像处理的基本过程及相关硬件设备、主要内容"><a href="#二-典型图像处理的基本过程及相关硬件设备、主要内容" class="headerlink" title="二. 典型图像处理的基本过程及相关硬件设备、主要内容"></a>二. 典型图像处理的基本过程及相关硬件设备、主要内容</h2><h2 id="三-数字图像处理的基本运算（点运算、代数运算、几何运算），图像合成"><a href="#三-数字图像处理的基本运算（点运算、代数运算、几何运算），图像合成" class="headerlink" title="三. 数字图像处理的基本运算（点运算、代数运算、几何运算），图像合成"></a>三. 数字图像处理的基本运算（点运算、代数运算、几何运算），图像合成</h2><h2 id="四-数字图像处理所设计的主要数学工具"><a href="#四-数字图像处理所设计的主要数学工具" class="headerlink" title="四. 数字图像处理所设计的主要数学工具"></a>四. 数字图像处理所设计的主要数学工具</h2><ol><li>直方图 幅度密度函数 概率分布</li><li><strong>卷积</strong></li><li>积分变换（傅里叶变换、<del>DCT等</del>）</li><li>形态学图像处理</li></ol><h2 id="五-图像增强的基本方法"><a href="#五-图像增强的基本方法" class="headerlink" title="五. 图像增强的基本方法"></a>五. 图像增强的基本方法</h2><ol><li>直方图增强（均衡，规定），包括基本原理</li><li><strong>平滑：均值滤波 中值滤波 低通滤波 多图像平均法 自适应滤波器（局部降噪、中值滤波）修改的阿尔法均值滤波器</strong></li><li><strong>锐化：微分锐化 高通锐化</strong></li><li>同态滤波</li></ol><h2 id="六-图像退化的数学模型及复原中的主要问题"><a href="#六-图像退化的数学模型及复原中的主要问题" class="headerlink" title="六. 图像退化的数学模型及复原中的主要问题"></a>六. 图像退化的数学模型及复原中的主要问题</h2><p><strong>运动模糊图像复原方法</strong></p><p><strong>噪声估计</strong></p><h2 id="七-图像压缩与编码（不考）"><a href="#七-图像压缩与编码（不考）" class="headerlink" title="七. 图像压缩与编码（不考）"></a>七. 图像压缩与编码（不考）</h2><h2 id="八-形态学图像处理"><a href="#八-形态学图像处理" class="headerlink" title="八. 形态学图像处理"></a>八. 形态学图像处理</h2><p>膨胀、腐蚀、闭操作、开操作、<strong>填充、边缘提取、击中与击不中</strong></p><p>膨胀结构元必须先反射</p><p>闭操作：填充空洞，恢复目标尺寸</p><p>开操作：去除毛刺，恢复目标尺寸</p><h2 id="九-图像分割"><a href="#九-图像分割" class="headerlink" title="九. 图像分割"></a>九. 图像分割</h2><p>图像分割：把图像分成各具特性的区域并提取出感兴趣目标的技术和过程</p><p>点检测与线检测</p><p>边缘检测： 梯度算子 拉普拉斯算子 <strong>高斯拉普拉斯算子 Canny算子</strong></p><p>门限值分割：<strong>全局门限 局部门限 <del>自适应门限</del> 自动确定门槛值的方法</strong>：$T&#x3D;\frac{u_1+u_2}{2}$</p><p>彩色图像分割方法 （RGB与HSI空间分割）</p><p>区域生长，区域分裂与合并</p><p>形态学分水岭算法</p><h2 id="十-图像表示"><a href="#十-图像表示" class="headerlink" title="十. 图像表示"></a>十. 图像表示</h2><p>链码 <strong>形状数</strong> 边界描述方法 纹理描述子 灰度共生矩阵 傅里叶描述子（边界、纹理）</p><h1 id="真题演练"><a href="#真题演练" class="headerlink" title="真题演练"></a>真题演练</h1><blockquote><p>参考<a href="https://blog.csdn.net/weixin_50321513/article/details/127678847">https://blog.csdn.net/weixin_50321513/article/details/127678847</a></p></blockquote><h2 id="简答题-5-4"><a href="#简答题-5-4" class="headerlink" title="简答题(5*4)"></a>简答题(5*4)</h2><p>1.图像灰度分辨率是什么？灰度分辨率低有什么影响？</p><p>灰度级中可分辨的最小变化（<strong>图像中可以区分的灰度级别数量</strong>）。减小文件大小和处理实践，但会降低图像的精细程度和色彩还原的准确性。</p><p>2.安全色是什么？有什么作用？</p><p><strong>安全色是一组特定的颜色值，它们在所有主流浏览器和平台上都能保持一致性</strong>。以确保在不同的设备和平台上都能呈现出一致的颜色效果</p><p>216种稳定色中RGB的值分别为：0，51，102，153，204，255；这样6*6*6&#x3D;216种颜色。</p><p>3.什么是线性移不变系统？它与卷积之间的关系是什么？</p><p>具有移不变系统的线性系统成为线性移不变系统。移不变：如果输入序列进行移位，则输出序列进行相应的移位。线性：满足叠加原理和齐次原理。</p><p>线性移不变系统的输出可以通过输入信号与该系统的冲击响应的卷积得到。</p><p>4.什么是灰度动态范围？当图像动态范围低的时候，怎么扩张图像的灰度动态范围？</p><p>灰度动态范围：灰度级取值范围</p><p>直方图均衡化</p><h2 id="问答题-8-5"><a href="#问答题-8-5" class="headerlink" title="问答题(8*5)"></a>问答题(8*5)</h2><p><strong>根据给定条件计算均值滤波，写出计算均值滤波的过程。</strong></p><p>均值滤波的过程：</p><p>在图像上对待处理的像素给一个模板，该模板包括了其周围的邻近像素。将模板中的全体像素的均值来替代原来像素值。</p><p><strong>某图像受到线性移不变系统 h(x,y)的影响，以及加性噪声 n(x,y)，最终得到 g(x,y)， 请写出还原原始图像 f(x,y)的模型，以及需要注意的两个点。</strong></p><p>线性移不变的图像退化模型：<br>$$<br>g(x,y)&#x3D;f(x,y)\circledast h(x,y)+n(x,y)<br>$$<br>其中$\circledast $为卷积运算。<br>$$<br>G(x,y)&#x3D;F(u,v) \cdot H(u,v)+N(u,v)<br>$$</p><ol><li>确定引起退化的点扩散函数困难</li><li>由于收到噪声影响，是一个病态的积分方程。</li></ol><p><strong>写出形态学中图像填充的步骤以及迭代算法</strong></p><ol><li>所有非边界（背景）点设为0，将1赋给p开始</li><li>$X_k &#x3D; (X_{k-1}\oplus B)\cap A^c$，$X_0&#x3D;p, B$为结构元素</li><li>迭代直到$X_k&#x3D;X_k-1$时，结束</li></ol><p><strong>什么是全局阈值分割？写出自适应得到分割阈值T的一个算法。</strong></p><p>全局阈值分割：通过判断图像每一个像素的灰度值，实现目标与背景的区分。</p><ol><li>初始化T</li><li>用T分割图像，生成两组数据$G_1,G_2$</li><li>求两组数据的平均灰度值$u_1,u_2$</li><li>计算新的门限值$T&#x3D;(u_1+u_2)&#x2F;2$</li><li>重复2-4，知到迭代得到的T值之差小于参数$t_0$</li><li>解释初始值和参数$t_0$的选择</li></ol><p><strong>请写出四个以上的纹理描述子</strong></p><p>均值、标准差、平滑度、一致性、熵、灰度共生矩阵</p><h2 id="计算题（16）"><a href="#计算题（16）" class="headerlink" title="计算题（16）"></a>计算题（16）</h2><p><strong>给定了一个直方图，进行均衡化（8分） 规定化（8分）</strong></p><h2 id="综合题（5-5-5-9）"><a href="#综合题（5-5-5-9）" class="headerlink" title="综合题（5+5+5+9）"></a>综合题（5+5+5+9）</h2><p><strong>一阶差分求图像边缘，过程</strong></p><p>Roberts算子、Prewitt算子和Sobel算子</p><p><strong>二阶差分算子求图像边缘过程，与高斯拉普拉斯算子的联系</strong></p><p>Laplacian算子</p><p>联系：高斯拉普拉斯算子先用高斯算子对图像进行平滑，抑制噪声，然后对平滑后的图像使用拉普拉斯算子求边缘</p><p><strong>使用Canny算子计算图像边缘，过程</strong></p><ol><li>高斯滤波</li><li>计算梯度幅值和方向</li><li>梯度非极大值抑制（NMS）</li><li>双阈值提取边缘</li></ol><p><strong>使用python-opencv处理图像的过程（包括图片读入、处理、展示、存储的过程）</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy<br><br><span class="hljs-comment"># 读入</span><br>img = cv2.imread(<span class="hljs-string">&#x27;test.jpg&#x27;</span>， <span class="hljs-number">0</span>)<br><span class="hljs-comment"># 处理</span><br>new_img = cv2.add(img, <span class="hljs-number">80</span>) <span class="hljs-comment"># 亮度增加80</span><br><span class="hljs-comment"># 展示</span><br>cv2.imshow(<span class="hljs-string">&#x27;image&#x27;</span>, img)<br>cv2.imshow(<span class="hljs-string">&#x27;new_image&#x27;</span>, new_img)<br><span class="hljs-comment"># 存储</span><br>cv2.imwrite(<span class="hljs-string">&#x27;new_test.jpg&#x27;</span>, new_img)<br><span class="hljs-comment"># 关闭所有窗口</span><br>cv2.waitKey(<span class="hljs-number">0</span>)<br>cv2.destroyAllWindows()<br></code></pre></td></tr></table></figure><p>2023年程序题为图像模板匹配</p><h1 id="Open-CV常用函数代码"><a href="#Open-CV常用函数代码" class="headerlink" title="Open-CV常用函数代码"></a>Open-CV常用函数代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 视频读取</span><br>cv2.VideoCapture()<br><span class="hljs-comment"># 视频保存</span><br>fourcc = cv2.VideoWriter_fourcc(*<span class="hljs-string">&#x27;XVID&#x27;</span>)<span class="hljs-comment">#  注意编码器</span><br>cv2.VideoWrite(<span class="hljs-string">&#x27;output.avi&#x27;</span>,fourcc, <span class="hljs-number">20.0</span>, (<span class="hljs-number">640</span>,<span class="hljs-number">480</span>))<br><span class="hljs-comment"># 绘图</span><br>cv2.line(img,(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>),(<span class="hljs-number">511</span>,<span class="hljs-number">511</span>),(<span class="hljs-number">255</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>),<span class="hljs-number">5</span>)<br>cv2.circle(img,(<span class="hljs-number">447</span>,<span class="hljs-number">63</span>), <span class="hljs-number">63</span>, (<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">255</span>), -<span class="hljs-number">1</span>)<br>cv2.rectangle(img,(<span class="hljs-number">384</span>,<span class="hljs-number">0</span>),(<span class="hljs-number">510</span>,<span class="hljs-number">128</span>),(<span class="hljs-number">0</span>,<span class="hljs-number">255</span>,<span class="hljs-number">0</span>),<span class="hljs-number">3</span>)<br>cv2.ellipse(img,(<span class="hljs-number">256</span>,<span class="hljs-number">256</span>),(<span class="hljs-number">100</span>,<span class="hljs-number">50</span>),<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">180</span>,<span class="hljs-number">255</span>,-<span class="hljs-number">1</span>)<br>cv2.putText(img,<span class="hljs-string">&#x27;OpenCV&#x27;</span>,(<span class="hljs-number">10</span>,<span class="hljs-number">500</span>), font, <span class="hljs-number">4</span>,(<span class="hljs-number">255</span>,<span class="hljs-number">255</span>,<span class="hljs-number">255</span>),<span class="hljs-number">2</span>)<br><span class="hljs-comment"># 创建窗口</span><br>cv2.nameWindow(<span class="hljs-string">&#x27;frame&#x27;</span>)<br><span class="hljs-comment"># 处理鼠标点击事件</span><br>cv2.setMouseCallback(<span class="hljs-string">&#x27;frame&#x27;</span>,caption)<br><span class="hljs-comment"># 图像加法（减法）</span><br>cv2.addWeighted(img1,<span class="hljs-number">0.7</span>,img2,<span class="hljs-number">0.3</span>,<span class="hljs-number">0</span>)<br><span class="hljs-comment"># 亮度增减</span><br>cv2.add(img,<span class="hljs-number">80</span>)<br>cv2.substract(img,<span class="hljs-number">80</span>)<br><span class="hljs-comment"># 图像乘法</span><br>cv2.multiply(img,<span class="hljs-number">1.5</span>)<br><span class="hljs-comment"># 绘制直方图</span><br>plt.hist(img.ravel(),<span class="hljs-number">256</span>,[<span class="hljs-number">0</span>,<span class="hljs-number">256</span>])<br><span class="hljs-comment"># 直方图均衡化</span><br>equ = cv2.equalizeHist(img)<br>res = np.hstack((img,equ))<br><span class="hljs-comment"># 均值滤波</span><br>cv2.blur(img,(<span class="hljs-number">3</span>,<span class="hljs-number">3</span>))<br><span class="hljs-comment"># 中值滤波</span><br>cv2.medianBlur(img,<span class="hljs-number">5</span>)<br><span class="hljs-comment"># 高斯滤波</span><br>cv2.GaussianBlur(img,(<span class="hljs-number">5</span>,<span class="hljs-number">5</span>),<span class="hljs-number">0</span>)<br><span class="hljs-comment"># 锐化</span><br>laplacian=cv2.Laplacian(img,cv2.CV_64F)<br>sobelx=cv2.Sobel(img,cv2.CV_64F,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,ksize=<span class="hljs-number">5</span>)<br><span class="hljs-comment"># 图像匹配</span><br>cv2.matchTemplate(img,template,method)<br><span class="hljs-comment"># FFT IFFT</span><br>f = np.fft.fft2(img)<br>fshift = np.fft.fftshift(f)<br><span class="hljs-comment"># 中间处理</span><br>f_ishift = np.fft.ifftshift(fshift)<br>img_back = np.fft.ifft2(f_ishift)<br><span class="hljs-comment"># 腐蚀</span><br>kernel = np.ones((<span class="hljs-number">5</span>,<span class="hljs-number">5</span>),np.uint8)<br>erosion = cv2.erode(img,kernel,iterations = <span class="hljs-number">1</span>)<br><span class="hljs-comment"># 膨胀</span><br>dilation = cv2.dilate(img,kernel,iterations = <span class="hljs-number">1</span>)<br><span class="hljs-comment"># 开运算</span><br>opening = cv2.morphologyEx(img, cv2.MORPH_OPEN, kernel)<br><span class="hljs-comment"># 闭运算</span><br>closing = cv2.morphologyEx(img, cv2.MORPH_CLOSE, kernel)<br><span class="hljs-comment"># 形态学梯度</span><br>gradient = cv2.morphologyEx(img, cv2.MORPH_GRADIENT, kernel)<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>考试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字图像处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NLP-Spell Correction</title>
    <link href="/2024/10/25/NLP-Spell%20Correction/"/>
    <url>/2024/10/25/NLP-Spell%20Correction/</url>
    
    <content type="html"><![CDATA[<h1 id="Spell-Correction"><a href="#Spell-Correction" class="headerlink" title="Spell Correction"></a>Spell Correction</h1><p>拼写检查任务，实现语言模型和通道模型，并利用tkinter实现GUI</p><h2 id="I．Environment"><a href="#I．Environment" class="headerlink" title="I．Environment"></a>I．Environment</h2><p>Python 3.10.9</p><p>Package: nltk 3.7 and numpy 1.26.4</p><h2 id="II．Theory"><a href="#II．Theory" class="headerlink" title="II．Theory"></a>II．Theory</h2><p>Spell-checking involves distinguishing between non-word errors and real-word errors. Non-word errors occur when a word is spelled incorrectly to the extent that it does not exist, such as spelling “giraffe” as “graffe.” Real-word errors, on the other hand, involve correctly spelled words that are used incorrectly within a given context.</p><p>Detection of non-word spelling errors primarily relies on dictionary lookup to determine whether a word exists. Correcting non-word errors typically involves two main steps: first, generating candidate words that are similar to the misspelled word and correct; second, selecting the best correction from these candidates. The selection of the best correction can be achieved through methods such as calculating the weighted edit distance between the misspelled word and each candidate word, choosing the candidate with the shortest distance as the correction, or calculating noisy channel probabilities and selecting the highest probability candidate.</p><p>Handling real-word spelling errors involves generating a set of candidate corrections for each word w. Candidates can be generated based on similar pronunciation or spelling to w, ensuring that w itself is included in the candidate set. The best correction is then chosen from these candidates, often using methods like edit distance to select the candidate with the smallest distance from w, or applying a noisy channel model to choose the candidate with the highest posterior probability. These approaches are combined to select the candidate with the highest probability among candidates with equal edit distances.</p><p>This framework ensures effective handling of spelling errors in natural language processing applications.</p><h2 id="III．Data"><a href="#III．Data" class="headerlink" title="III．Data"></a>III．Data</h2><p><strong>Training corpus</strong></p><p>Reuters Corpus</p><p><strong>Test dataset</strong></p><p>testdata.txt</p><h2 id="IV．Model-Development"><a href="#IV．Model-Development" class="headerlink" title="IV．Model Development"></a>IV．Model Development</h2><h3 id="Language-model"><a href="#Language-model" class="headerlink" title="Language model"></a>Language model</h3><p>Language models evaluate the naturalness and grammatical correctness of sentences by assessing the probability of word occurrences in text. The sentence probability calculation formula is derived from the chain rule.</p><p>​<img src="https://raw.githubusercontent.com/Further509/Picture/main/wps1.png" alt="img"></p><p>Introducing the Markov assumption, given the previous k words, each word’s generation depends solely on these k preceding words. The formula then transforms into</p><p>​<img src="https://raw.githubusercontent.com/Further509/Picture/main/wps2.png" alt="img"></p><p>In natural language processing, the method where each word’s generation depends on the preceding N words is called N-gram. The 0th order is Unigram, 1st order is Bigram, and 2nd order is Trigram.</p><p>In language modeling, the issue of encountering probabilities of zero often arises, necessitating the use of smoothing methods. Here, I combine Add-k smoothing and interpolation smoothing for handling this issue.</p><p>interpolation smoothing：</p><p>​<img src="https://raw.githubusercontent.com/Further509/Picture/main/wps3.png" alt="img"></p><p>Among them : <img src="https://raw.githubusercontent.com/Further509/Picture/main/wps4.png" alt="img">.</p><p>For calculating unigram, bigram, and trigram probabilities, we use Add-k smoothing.<img src="https://raw.githubusercontent.com/Further509/Picture/main/wps5.png" alt="img"></p><h3 id="Edit-Distance"><a href="#Edit-Distance" class="headerlink" title="Edit Distance"></a>Edit Distance</h3><p>Based on edit distance, the system can generate a list of candidate words similar to the original word. By constraining the edit distance within a reasonable range, we ensure that the generated candidate words include possible correct spelling forms. We filter out candidate words where the edit distance is less than or equal to 2 to obtain the list of candidates.</p><h3 id="Noisy-channel-model"><a href="#Noisy-channel-model" class="headerlink" title="Noisy channel model"></a>Noisy channel model</h3><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241025224526553.png" alt="Noisy channel model"></p><p>The system combines the candidate word list generated using edit distance with a noisy channel model to weight and evaluate the probability of each candidate word. This approach helps to exclude spelling suggestions that are unreasonable in context and improves the accuracy of selecting the correct correction by the system.</p><p>Assume word x has a spelling error. Now, to find the best candidate from the set V, the following calculation method can be used.</p><p>​<img src="https://raw.githubusercontent.com/Further509/Picture/main/wps7.png"></p><p>Where P(x|w) is derived from the noisy channel model, and P(w) is derived from the language model.</p><p>The channel model also employs Add-k smoothing to smooth the probabilities.</p><h2 id="V．Code-Implementation"><a href="#V．Code-Implementation" class="headerlink" title="V．Code Implementation"></a>V．Code Implementation</h2><p><strong>Data preprocessing</strong></p><p>preprocessing(ngram, cate)</p><p>Read the vocabulary from vocab.txt, read and preprocess the test data from testdata.txt, and process the corpus to form n-gram information.</p><p><strong>Load confusion matrix</strong></p><p>Here, we use the data from the paper ‘A Spelling Correction Program Based on a Noisy Channel Model’</p><p>loadConfusionMatrix():</p><p>Obtain addmatrix, submatrix, revmatrix, and delmatrix respectively.</p><p><strong>Language model</strong></p><p>interpolated_language_model(gram_count, V, data, lambdas, K&#x3D;0.0001)</p><p>Language model combining Add-k smoothing and interpolated smoothing</p><p><strong>Edit distance</strong></p><p>editType(candidate, word)</p><p>Identify the type of edit relative to the original word for candidate words.</p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/wps8.jpg" alt="img"> </p><p><strong>Retrieve candidate words</strong></p><p>get_candidate(trie, word, edit_distance&#x3D;2)</p><p>Retrieve words from the dictionary with an edit distance of less than or equal to 2 as candidate words.</p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/wps9.jpg" alt="img"> </p><p><strong>Noisy channel model</strong></p><p>channelModel(x, y, edit, corpus, k&#x3D;0.1)</p><p>Calculate channel model error probability</p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/wps10.jpg" alt="img"> </p><p><strong>Perform spell correction</strong></p><p>spell_correct(vocab, testdata, gram_count, corpus, V, trie, lambdas)</p><p>Perform spell correction on the test data, first addressing non-word errors, then handling real-word errors.</p><h2 id="VI．Result"><a href="#VI．Result" class="headerlink" title="VI．Result"></a>VI．Result</h2><p>Obtained by multiple adjustments of various parameter values:</p><table><thead><tr><th>Interpolated combination weights</th><th>Add-1</th><th>Add-k</th></tr></thead><tbody><tr><td>0.90  0.05  0.05</td><td>82.9%</td><td>88.8%</td></tr><tr><td>0.05  0.90  0.05</td><td>85.5%</td><td>89.2%</td></tr><tr><td>0.05  0.05  0.90</td><td>85.4%</td><td>89.2%</td></tr><tr><td>0.01  0.80  0.19</td><td>85.6%</td><td>89.7%</td></tr><tr><td>0.20  0.30  0.50</td><td>84.8%</td><td>89.3%</td></tr><tr><td>0.10  0.30  0.60</td><td>85.3%</td><td>89.5%</td></tr><tr><td>0.10  0.60  0.30</td><td>85.2%</td><td>89.4%</td></tr><tr><td>0.40  0.40  0.20</td><td>84.3%</td><td>89.2%</td></tr></tbody></table><p>The highest accuracy is <strong>89.7%</strong>, with interpolated combination weights of <strong>0.01, 0.80, and 0.19</strong>, using <strong>Add-k</strong> smoothing.</p><h2 id="VII．GUI"><a href="#VII．GUI" class="headerlink" title="VII．GUI"></a>VII．GUI</h2><p>The packaged executable file “main_script.exe” is located in “&#x2F;GUI&#x2F;dist&#x2F;main_script”. Double-click to run it.</p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/wps11.jpg" alt="img"> </p><h2 id="VIII．Reference"><a href="#VIII．Reference" class="headerlink" title="VIII．Reference"></a>VIII．Reference</h2><p>[1] Kernighan, M. D., Church, K., &amp; Gale, W. A. (1990). A spelling correction program based on a noisy channel model. In COLING 1990 Volume 2: Papers presented to the 13th International Conference on Computational Linguistics.</p><p>[2] Jayanthi, S. M., Pruthi, D., &amp; Neubig, G. (2020). Neuspell: A neural spelling correction toolkit. arXiv preprint arXiv:2010.11085.</p><p>[3] <a href="https://blog.csdn.net/BeforeEasy/article/details/104104731">如何写一个拼写纠错器 – how to write a spelling corrector-CSDN博客</a></p><p>[4] <a href="https://blog.csdn.net/qq_36134437/article/details/103146390">https://blog.csdn.net/qq_36134437/article/details/103146390</a></p><p>[5] <a href="https://blog.csdn.net/qq_41230076/article/details/105474437">NLP-拼写纠错（spell correction）实战_nlp correction插件-CSDN博客</a></p><h2 id="IX-Code"><a href="#IX-Code" class="headerlink" title="IX. Code"></a>IX. Code</h2><p>main.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> nltk<br><span class="hljs-keyword">from</span> nltk.tokenize <span class="hljs-keyword">import</span> word_tokenize<br><span class="hljs-keyword">from</span> nltk.corpus <span class="hljs-keyword">import</span> reuters<br><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> Counter<br><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> defaultdict, deque<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> ast<br><br><br><span class="hljs-comment">#预处理函数，测试数据，语料库和词典</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">preprocessing</span>(<span class="hljs-params">ngram, cate</span>):<br>    <span class="hljs-comment"># 读取词汇表</span><br>    vocabpath = <span class="hljs-string">&#x27;./vocab.txt&#x27;</span><br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(vocabpath, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> vocabfile:<br>        <span class="hljs-comment"># 从词汇表文件中读取每一行，去掉首尾空格后存储到 vocab_list 列表中</span><br>        vocab_list = [line.strip() <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> vocabfile]<br>    <br>    <span class="hljs-comment"># 读取测试数据</span><br>    testpath = <span class="hljs-string">&#x27;./testdata.txt&#x27;</span><br>    testdata = []<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(testpath, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> testfile:<br>        <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> testfile:<br>            <span class="hljs-comment"># 将每行数据用制表符拆分成三个部分：句子标识符、错误计数和实际句子</span><br>            item = line.split(<span class="hljs-string">&#x27;\t&#x27;</span>)<br>            <span class="hljs-comment"># 对句子进行分词</span><br>            item[<span class="hljs-number">2</span>] = word_tokenize(item[<span class="hljs-number">2</span>])<br>            <span class="hljs-comment"># 在句子的开头和结尾添加特殊标记 &lt;s&gt; 和 &lt;/s&gt;</span><br>            item[<span class="hljs-number">2</span>] = [<span class="hljs-string">&#x27;&lt;s&gt;&#x27;</span>] + item[<span class="hljs-number">2</span>] + [<span class="hljs-string">&#x27;&lt;/s&gt;&#x27;</span>]<br>            <span class="hljs-comment"># 将处理后的句子添加到 testdata 列表中</span><br>            testdata.append(item)<br>    <br>    <span class="hljs-comment"># 预处理语料库</span><br>    corpus_raw_text = reuters.sents(categories=cate)<br>    corpus_text = []<br>    gram_count = defaultdict(<span class="hljs-built_in">int</span>)<br>    vocab_corpus = <span class="hljs-built_in">set</span>()<br><br>    <span class="hljs-keyword">for</span> sents <span class="hljs-keyword">in</span> corpus_raw_text:<br>        <span class="hljs-comment"># 在每个句子的开头和结尾添加特殊标记 &lt;s&gt; 和 &lt;/s&gt;</span><br>        sents = [<span class="hljs-string">&#x27;&lt;s&gt;&#x27;</span>] + sents + [<span class="hljs-string">&#x27;&lt;/s&gt;&#x27;</span>]<br>        <span class="hljs-comment"># 将处理后的句子添加到 corpus_text 中</span><br>        corpus_text.extend(sents)<br>        <span class="hljs-comment"># 更新词汇集合 vocab_corpus</span><br>        vocab_corpus.update(sents)<br>        <br>        <span class="hljs-comment"># 统计不同长度的 n-grams</span><br>        <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, ngram + <span class="hljs-number">2</span>):<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n, <span class="hljs-built_in">len</span>(sents) + <span class="hljs-number">1</span>):<br>                <span class="hljs-comment"># 提取 n-gram</span><br>                gram = <span class="hljs-string">&#x27; &#x27;</span>.join(sents[i - n: i])<br>                <span class="hljs-comment"># 统计 n-gram 的频率</span><br>                gram_count[gram] += <span class="hljs-number">1</span><br><br>    <span class="hljs-comment"># 计算语料库中的独特词汇数量</span><br>    V = <span class="hljs-built_in">len</span>(vocab_corpus)<br>    <span class="hljs-comment"># 返回词汇表、测试数据、n-gram 统计信息、词汇集合、处理后的语料库和词汇数量</span><br>    <span class="hljs-keyword">return</span> vocab_list, testdata, gram_count, <span class="hljs-built_in">list</span>(vocab_corpus), corpus_text, V<br><br><br><br><span class="hljs-comment">#路透社语料库</span><br>cate = reuters.categories()<br><br><br><span class="hljs-comment">#结合语料库进行预处理</span><br>vocab, testdata, gram_count, vocab_corpus, corpus_text, V = preprocessing(<span class="hljs-number">2</span>, cate)  <span class="hljs-comment"># 使用trigram</span><br><br><br><span class="hljs-comment"># 从外部数据文件加载混淆矩阵</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">loadConfusionMatrix</span>():<br>    <span class="hljs-comment"># 加载添加操作的混淆矩阵</span><br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;addconfusion.data&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>        addmatrix = ast.literal_eval(f.read())<br>    <br>    <span class="hljs-comment"># 加载替换操作的混淆矩阵</span><br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;subconfusion.data&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>        submatrix = ast.literal_eval(f.read())<br>    <br>    <span class="hljs-comment"># 加载颠倒操作的混淆矩阵</span><br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;revconfusion.data&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>        revmatrix = ast.literal_eval(f.read())<br>    <br>    <span class="hljs-comment"># 加载删除操作的混淆矩阵</span><br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;delconfusion.data&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>        delmatrix = ast.literal_eval(f.read())<br>    <br>    <span class="hljs-comment"># 返回所有混淆矩阵</span><br>    <span class="hljs-keyword">return</span> addmatrix, submatrix, revmatrix, delmatrix<br><br><br><br><span class="hljs-comment">#获取混淆矩阵</span><br>addmatrix, submatrix, revmatrix, delmatrix = loadConfusionMatrix()<br><br><span class="hljs-comment"># %%</span><br>END = <span class="hljs-string">&#x27;$&#x27;</span>  <span class="hljs-comment"># 用于表示单词结束的特殊标记</span><br><br><span class="hljs-comment"># 创建字典树（trie）</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">make_trie</span>(<span class="hljs-params">vocab</span>):<br>    trie = &#123;&#125;  <span class="hljs-comment"># 初始化空字典树</span><br>    <span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> vocab:<br>        t = trie  <span class="hljs-comment"># 从根节点开始插入单词</span><br>        <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> word:<br>            <span class="hljs-keyword">if</span> c <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> t:<br>                t[c] = &#123;&#125;  <span class="hljs-comment"># 如果当前字符不在当前节点中，创建一个新的子节点</span><br>            t = t[c]  <span class="hljs-comment"># 移动到当前字符的子节点</span><br>        t[END] = &#123;&#125;  <span class="hljs-comment"># 在单词的末尾添加结束标记</span><br>    <span class="hljs-keyword">return</span> trie  <span class="hljs-comment"># 返回构建好的字典树</span><br><br><br><br><span class="hljs-comment">#将词典创建字典树，加快查找效率</span><br>trie = make_trie(vocab)<br><br><br><span class="hljs-comment">#候选词和原词的编辑类型</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">editType</span>(<span class="hljs-params">candidate, word</span>):<br>    <span class="hljs-comment"># 如果候选词和原词长度相等</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(candidate) == <span class="hljs-built_in">len</span>(word):<br>        <span class="hljs-comment"># 检查字符替换错误</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(candidate)):<br>            <span class="hljs-keyword">if</span> candidate[i] != word[i]:<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;sub&#x27;</span>, candidate[i], word[i], (candidate[i], word[i])<br>    <span class="hljs-comment"># 如果候选词长度比原词短1</span><br>    <span class="hljs-keyword">elif</span> <span class="hljs-built_in">len</span>(candidate) + <span class="hljs-number">1</span> == <span class="hljs-built_in">len</span>(word):<br>        <span class="hljs-comment"># 检查字符删除错误</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(candidate)):<br>            <span class="hljs-keyword">if</span> candidate[i] != word[i]:<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;del&#x27;</span>, candidate[i], word[i], (candidate[i], word[i + <span class="hljs-number">1</span>])<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;del&#x27;</span>, candidate[-<span class="hljs-number">1</span>], <span class="hljs-string">&#x27;&#x27;</span>, (candidate[-<span class="hljs-number">1</span>], <span class="hljs-string">&#x27;&#x27;</span>)<br>    <span class="hljs-comment"># 如果候选词长度比原词长1</span><br>    <span class="hljs-keyword">elif</span> <span class="hljs-built_in">len</span>(candidate) == <span class="hljs-built_in">len</span>(word) + <span class="hljs-number">1</span>:<br>        <span class="hljs-comment"># 检查字符添加错误</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(word)):<br>            <span class="hljs-keyword">if</span> candidate[i] != word[i]:<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;add&#x27;</span>, candidate[i], word[i], (candidate[i], word[i])<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;add&#x27;</span>, candidate[-<span class="hljs-number">1</span>], <span class="hljs-string">&#x27;&#x27;</span>, (candidate[-<span class="hljs-number">1</span>], <span class="hljs-string">&#x27;&#x27;</span>)<br>    <span class="hljs-comment"># 如果候选词和原词长度相等（再次检查字符调换错误）</span><br>    <span class="hljs-keyword">elif</span> <span class="hljs-built_in">len</span>(candidate) == <span class="hljs-built_in">len</span>(word):<br>        <span class="hljs-comment"># 检查字符调换错误</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(candidate) - <span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> candidate[i] != word[i] <span class="hljs-keyword">and</span> candidate[i + <span class="hljs-number">1</span>] != word[i + <span class="hljs-number">1</span>]:<br>                <span class="hljs-keyword">if</span> candidate[i] == word[i + <span class="hljs-number">1</span>] <span class="hljs-keyword">and</span> candidate[i + <span class="hljs-number">1</span>] == word[i]:<br>                    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;rev&#x27;</span>, candidate[i], word[i], (candidate[i], candidate[i + <span class="hljs-number">1</span>])<br>    <span class="hljs-comment"># 如果没有匹配的编辑类型，返回 None</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><br><br><span class="hljs-comment"># 结合加K和插值平滑的语言模型</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">interpolated_language_model</span>(<span class="hljs-params">gram_count, V, data, lambdas, K=<span class="hljs-number">0.0001</span></span>):<br>    <span class="hljs-comment"># 提取插值平滑系数</span><br>    unigram_lambda, bigram_lambda, trigram_lambda = lambdas<br>    total_log_prob = <span class="hljs-number">0</span>  <span class="hljs-comment"># 初始化总对数概率</span><br>    total_count = <span class="hljs-built_in">sum</span>(gram_count.values())  <span class="hljs-comment"># 总的 n-gram 计数</span><br>    <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(data)):<br>        unigram = data[i]  <span class="hljs-comment"># 当前词（Unigram）</span><br>        bigram = <span class="hljs-string">&#x27; &#x27;</span>.join(data[i-<span class="hljs-number">1</span>:i+<span class="hljs-number">1</span>]) <span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span>  <span class="hljs-comment"># 当前词和前一个词（Bigram）</span><br>        trigram = <span class="hljs-string">&#x27; &#x27;</span>.join(data[i-<span class="hljs-number">2</span>:i+<span class="hljs-number">1</span>]) <span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span>  <span class="hljs-comment"># 当前词和前两个词（Trigram）</span><br>        <br>        <span class="hljs-comment"># Unigram 概率计算，使用 K-平滑</span><br>        unigram_prob = (gram_count[unigram] + K) / (total_count + K * V)<br>        <br>        <span class="hljs-keyword">if</span> bigram:<br>            <span class="hljs-comment"># Bigram 概率计算，使用 K-平滑</span><br>            bigram_prob = (gram_count[bigram] + K) / (gram_count[data[i-<span class="hljs-number">1</span>]] + K * V) <span class="hljs-keyword">if</span> data[i-<span class="hljs-number">1</span>] <span class="hljs-keyword">in</span> gram_count <span class="hljs-keyword">else</span> K / V<br>        <span class="hljs-keyword">else</span>:<br>            bigram_prob = <span class="hljs-number">0</span>  <span class="hljs-comment"># 如果没有 Bigram，则概率为 0</span><br>        <br>        <span class="hljs-keyword">if</span> trigram:<br>            <span class="hljs-comment"># Trigram 概率计算，使用 K-平滑</span><br>            trigram_prob = (gram_count[trigram] + K) / (gram_count[<span class="hljs-string">&#x27; &#x27;</span>.join(data[i-<span class="hljs-number">2</span>:i])] + K * V) <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27; &#x27;</span>.join(data[i-<span class="hljs-number">2</span>:i]) <span class="hljs-keyword">in</span> gram_count <span class="hljs-keyword">else</span> K / V<br>        <span class="hljs-keyword">else</span>:<br>            trigram_prob = <span class="hljs-number">0</span>  <span class="hljs-comment"># 如果没有 Trigram，则概率为 0</span><br>        <br>        <span class="hljs-comment"># 计算插值平滑后的概率</span><br>        interpolated_prob = (unigram_lambda * unigram_prob +<br>                             bigram_lambda * bigram_prob +<br>                             trigram_lambda * trigram_prob)<br>                             <br>        <span class="hljs-comment"># 将插值平滑后的概率取对数并加到总对数概率中</span><br>        total_log_prob += np.log(interpolated_prob)<br>        <br>    <span class="hljs-keyword">return</span> total_log_prob  <span class="hljs-comment"># 返回总对数概率</span><br><br><br><span class="hljs-comment"># 获取候选词</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_candidate</span>(<span class="hljs-params">trie, word, edit_distance=<span class="hljs-number">2</span></span>):<br>    <span class="hljs-comment"># 初始化队列，包含（字典树，词，路径，编辑距离）的元组</span><br>    que = deque([(trie, word, <span class="hljs-string">&#x27;&#x27;</span>, edit_distance)])<br>    <br>    <span class="hljs-comment"># 使用广度优先搜索算法遍历队列</span><br>    <span class="hljs-keyword">while</span> que:<br>        <span class="hljs-comment"># 从队列中取出一个元素</span><br>        trie, word, path, edit_distance = que.popleft()<br>        <br>        <span class="hljs-comment"># 如果词已经处理完</span><br>        <span class="hljs-keyword">if</span> word == <span class="hljs-string">&#x27;&#x27;</span>:<br>            <span class="hljs-comment"># 如果路径在字典树中标记为结束（即一个完整单词）</span><br>            <span class="hljs-keyword">if</span> END <span class="hljs-keyword">in</span> trie:<br>                <span class="hljs-keyword">yield</span> path  <span class="hljs-comment"># 生成候选词</span><br>            <br>            <span class="hljs-comment"># 如果编辑距离还未耗尽，继续生成候选词</span><br>            <span class="hljs-keyword">if</span> edit_distance &gt; <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> trie:<br>                    <span class="hljs-keyword">if</span> k != END:  <span class="hljs-comment"># 不处理结束标记</span><br>                        <span class="hljs-comment"># 将新生成的路径和剩余编辑距离放入队列</span><br>                        que.appendleft((trie[k], <span class="hljs-string">&#x27;&#x27;</span>, path + k, edit_distance - <span class="hljs-number">1</span>))<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 如果当前字符在字典树中</span><br>            <span class="hljs-keyword">if</span> word[<span class="hljs-number">0</span>] <span class="hljs-keyword">in</span> trie:<br>                <span class="hljs-comment"># 将当前字符匹配的路径放入队列，继续处理剩余词</span><br>                que.appendleft((trie[word[<span class="hljs-number">0</span>]], word[<span class="hljs-number">1</span>:], path + word[<span class="hljs-number">0</span>], edit_distance))<br>            <br>            <span class="hljs-comment"># 如果编辑距离还未耗尽，尝试其他编辑操作生成候选词</span><br>            <span class="hljs-keyword">if</span> edit_distance &gt; <span class="hljs-number">0</span>:<br>                edit_distance -= <span class="hljs-number">1</span><br>                <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> trie.keys() - &#123;word[<span class="hljs-number">0</span>], END&#125;:<br>                    <span class="hljs-comment"># 替换字符操作</span><br>                    que.append((trie[k], word[<span class="hljs-number">1</span>:], path + k, edit_distance))<br>                    <span class="hljs-comment"># 添加字符操作</span><br>                    que.append((trie[k], word, path + k, edit_distance))<br>                <br>                <span class="hljs-comment"># 删除字符操作</span><br>                que.append((trie, word[<span class="hljs-number">1</span>:], path, edit_distance))<br>                <br>                <span class="hljs-comment"># 调换字符操作</span><br>                <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(word) &gt; <span class="hljs-number">1</span>:<br>                    que.append((trie, word[<span class="hljs-number">1</span>] + word[<span class="hljs-number">0</span>] + word[<span class="hljs-number">2</span>:], path, edit_distance))<br><br><br><span class="hljs-comment"># 计算信道模型错误概率</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">channelModel</span>(<span class="hljs-params">x, y, edit, corpus, k=<span class="hljs-number">0.01</span></span>):<br>    <span class="hljs-comment"># 将语料库转换为一个字符串，以便进行计数</span><br>    corpus_str = <span class="hljs-string">&#x27; &#x27;</span>.join(corpus)<br>    <span class="hljs-comment"># 语料库的长度</span><br>    corpus_len = <span class="hljs-built_in">len</span>(corpus)<br><br>    <span class="hljs-comment"># 处理添加字符的情况</span><br>    <span class="hljs-keyword">if</span> edit == <span class="hljs-string">&#x27;add&#x27;</span>:<br>        <span class="hljs-comment"># 获取在添加混淆矩阵中的频次</span><br>        count_xy = addmatrix.get(x + y, <span class="hljs-number">0</span>)<br>        <span class="hljs-comment"># 计算x或y的频次，根据x是否为起始标记来决定</span><br>        count_y = corpus_str.count(<span class="hljs-string">&#x27; &#x27;</span> + y) <span class="hljs-keyword">if</span> x == <span class="hljs-string">&#x27;#&#x27;</span> <span class="hljs-keyword">else</span> corpus_str.count(x)<br>        <span class="hljs-comment"># 使用加K平滑计算添加错误的概率</span><br>        <span class="hljs-keyword">return</span> (count_xy + k) / (count_y + k * corpus_len) <span class="hljs-keyword">if</span> count_y <span class="hljs-keyword">else</span> (count_xy + k) / corpus_len<br><br>    <span class="hljs-comment"># 处理替换字符的情况</span><br>    <span class="hljs-keyword">if</span> edit == <span class="hljs-string">&#x27;sub&#x27;</span>:<br>        <span class="hljs-comment"># 获取在替换混淆矩阵中的频次</span><br>        count_xy = submatrix.get((x + y)[:<span class="hljs-number">2</span>], <span class="hljs-number">0</span>)<br>        <span class="hljs-comment"># 计算y的频次</span><br>        count_y = corpus_str.count(y)<br>        <span class="hljs-comment"># 使用加K平滑计算替换错误的概率</span><br>        <span class="hljs-keyword">return</span> (count_xy + k) / (count_y + k * corpus_len) <span class="hljs-keyword">if</span> count_y <span class="hljs-keyword">else</span> (count_xy + k) / corpus_len<br><br>    <span class="hljs-comment"># 处理调换字符的情况</span><br>    <span class="hljs-keyword">if</span> edit == <span class="hljs-string">&#x27;rev&#x27;</span>:<br>        <span class="hljs-comment"># 获取在调换混淆矩阵中的频次</span><br>        count_xy = revmatrix.get(x + y, <span class="hljs-number">0</span>)<br>        <span class="hljs-comment"># 计算x和y调换后在语料库中的频次</span><br>        count_xy_in_corpus = corpus_str.count(x + y)<br>        <span class="hljs-comment"># 使用加K平滑计算调换错误的概率</span><br>        <span class="hljs-keyword">return</span> (count_xy + k) / (count_xy_in_corpus + k * corpus_len) <span class="hljs-keyword">if</span> count_xy_in_corpus <span class="hljs-keyword">else</span> (count_xy + k) / corpus_len<br><br>    <span class="hljs-comment"># 处理删除字符的情况</span><br>    <span class="hljs-keyword">if</span> edit == <span class="hljs-string">&#x27;del&#x27;</span>:<br>        <span class="hljs-comment"># 获取在删除混淆矩阵中的频次</span><br>        count_xy = delmatrix.get(x + y, <span class="hljs-number">0</span>)<br>        <span class="hljs-comment"># 计算x和y在语料库中的频次</span><br>        count_xy_in_corpus = corpus_str.count(x + y)<br>        <span class="hljs-comment"># 使用加K平滑计算删除错误的概率</span><br>        <span class="hljs-keyword">return</span> (count_xy + k) / (count_xy_in_corpus + k * corpus_len) <span class="hljs-keyword">if</span> count_xy_in_corpus <span class="hljs-keyword">else</span> (count_xy + k) / corpus_len<br><br>    <span class="hljs-comment"># 如果没有匹配的编辑操作，返回一个默认的概率</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> / corpus_len<br><br><br><span class="hljs-comment"># 拼写纠正函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">spell_correct</span>(<span class="hljs-params">vocab, testdata, gram_count, corpus, V, trie, lambdas</span>):<br>    resultpath = <span class="hljs-string">&#x27;./result.txt&#x27;</span><br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(resultpath, <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> resultfile:<br>        <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> testdata:<br>            corrected_sentence = item[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>:-<span class="hljs-number">1</span>]  <span class="hljs-comment"># 去掉&lt;s&gt; 和 &lt;/s&gt;，只保留句子部分</span><br>            error_count = <span class="hljs-built_in">int</span>(item[<span class="hljs-number">1</span>])  <span class="hljs-comment"># 错误数量</span><br>            corrected_words = <span class="hljs-number">0</span>  <span class="hljs-comment"># 纠正的单词数量</span><br>            non_word_errors = <span class="hljs-number">0</span>  <span class="hljs-comment"># 处理的非词错误数量</span><br>            modified_indices = <span class="hljs-built_in">set</span>()  <span class="hljs-comment"># 记录已经修改的索引</span><br><br>            <span class="hljs-comment"># 处理非词错误</span><br>            <span class="hljs-keyword">for</span> i, word <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(corrected_sentence):<br>                <span class="hljs-keyword">if</span> non_word_errors &gt;= error_count:<br>                    <span class="hljs-keyword">break</span><br><br>                <span class="hljs-keyword">if</span> word <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> vocab:  <span class="hljs-comment"># 如果词不在词汇表中，可能是非词错误</span><br>                    <span class="hljs-comment"># 获取编辑距离为1或2的候选词</span><br>                    candidates = <span class="hljs-built_in">list</span>(get_candidate(trie, word, edit_distance=<span class="hljs-number">1</span>)) <span class="hljs-keyword">or</span> <span class="hljs-built_in">list</span>(get_candidate(trie, word, edit_distance=<span class="hljs-number">2</span>))<br>                    candi_proba = []<br><br>                    <span class="hljs-comment"># 对每个候选词计算其概率</span><br>                    <span class="hljs-keyword">for</span> candidate <span class="hljs-keyword">in</span> candidates:<br>                        edit = editType(candidate, word)  <span class="hljs-comment"># 获取编辑类型</span><br>                        <span class="hljs-keyword">if</span> edit <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                            candi_proba.append(interpolated_language_model(gram_count, V, [candidate], lambdas))<br>                            <span class="hljs-keyword">continue</span><br><br>                        x, y = <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span><br>                        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(edit) == <span class="hljs-number">4</span>:<br>                            x, y = edit[<span class="hljs-number">3</span>][<span class="hljs-number">0</span>], edit[<span class="hljs-number">3</span>][<span class="hljs-number">1</span>]<br>                        channel_p = np.log(channelModel(x, y, edit[<span class="hljs-number">0</span>].lower(), corpus)) <span class="hljs-keyword">if</span> edit <span class="hljs-keyword">else</span> <span class="hljs-number">0</span><br><br>                        <span class="hljs-comment"># 构建前后文环境</span><br>                        word_index = i + <span class="hljs-number">1</span><br>                        pre_phase = item[<span class="hljs-number">2</span>][word_index - <span class="hljs-number">2</span>: word_index] + [candidate]<br>                        post_phase = [candidate] + item[<span class="hljs-number">2</span>][word_index + <span class="hljs-number">1</span>: word_index + <span class="hljs-number">3</span>]<br><br>                        <span class="hljs-comment"># 使用插值平滑计算概率</span><br>                        p = (<span class="hljs-number">0.4</span> * interpolated_language_model(gram_count, V, pre_phase, lambdas) +<br>                             <span class="hljs-number">0.4</span> * interpolated_language_model(gram_count, V, post_phase, lambdas) +<br>                             <span class="hljs-number">0.2</span> * channel_p)<br>                        candi_proba.append(p)<br><br>                    <span class="hljs-comment"># 选择概率最高的候选词进行纠正</span><br>                    <span class="hljs-keyword">if</span> candi_proba:<br>                        index = candi_proba.index(<span class="hljs-built_in">max</span>(candi_proba))<br>                        corrected_sentence[i] = candidates[index]<br>                        corrected_words += <span class="hljs-number">1</span><br>                        modified_indices.add(i)<br>                        non_word_errors += <span class="hljs-number">1</span><br><br>            <span class="hljs-comment"># 处理真词错误</span><br>            <span class="hljs-keyword">if</span> corrected_words &lt; error_count:<br>                <span class="hljs-keyword">for</span> i, word <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(corrected_sentence):<br>                    <span class="hljs-keyword">if</span> corrected_words &gt;= error_count:<br>                        <span class="hljs-keyword">break</span><br><br>                    <span class="hljs-keyword">if</span> i <span class="hljs-keyword">in</span> modified_indices <span class="hljs-keyword">or</span> word <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> vocab:  <span class="hljs-comment"># 已经处理过非词错误或者是真词错误</span><br>                        <span class="hljs-keyword">continue</span><br><br>                    <span class="hljs-comment"># 获取编辑距离为1或2的候选词</span><br>                    candidates = <span class="hljs-built_in">list</span>(get_candidate(trie, word, edit_distance=<span class="hljs-number">1</span>)) <span class="hljs-keyword">or</span> <span class="hljs-built_in">list</span>(get_candidate(trie, word, edit_distance=<span class="hljs-number">2</span>))<br>                    candi_proba = []<br><br>                    <span class="hljs-comment"># 对每个候选词计算其概率</span><br>                    <span class="hljs-keyword">for</span> candidate <span class="hljs-keyword">in</span> candidates:<br>                        <span class="hljs-keyword">if</span> candidate == word:<br>                            <span class="hljs-keyword">continue</span><br><br>                        edit = editType(candidate, word)<br>                        <span class="hljs-keyword">if</span> edit <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                            candi_proba.append(interpolated_language_model(gram_count, V, [candidate], lambdas))<br>                            <span class="hljs-keyword">continue</span><br><br>                        x, y = <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span><br>                        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(edit) == <span class="hljs-number">4</span>:<br>                            x, y = edit[<span class="hljs-number">3</span>][<span class="hljs-number">0</span>], edit[<span class="hljs-number">3</span>][<span class="hljs-number">1</span>]<br>                        channel_p = np.log(channelModel(x, y, edit[<span class="hljs-number">0</span>].lower(), corpus)) <span class="hljs-keyword">if</span> edit <span class="hljs-keyword">else</span> <span class="hljs-number">0</span><br><br>                        <span class="hljs-comment"># 构建前后文环境</span><br>                        word_index = i + <span class="hljs-number">1</span><br>                        pre_phase = item[<span class="hljs-number">2</span>][word_index - <span class="hljs-number">2</span>: word_index] + [candidate]<br>                        post_phase = [candidate] + item[<span class="hljs-number">2</span>][word_index + <span class="hljs-number">1</span>: word_index + <span class="hljs-number">3</span>]<br><br>                        <span class="hljs-comment"># 使用插值平滑计算概率</span><br>                        p = (<span class="hljs-number">0.4</span> * interpolated_language_model(gram_count, V, pre_phase, lambdas) +<br>                             <span class="hljs-number">0.4</span> * interpolated_language_model(gram_count, V, post_phase, lambdas) +<br>                             <span class="hljs-number">0.2</span> * channel_p)<br>                        candi_proba.append(p)<br><br>                    <span class="hljs-comment"># 选择概率最高的候选词进行纠正</span><br>                    <span class="hljs-keyword">if</span> candi_proba:<br>                        index = candi_proba.index(<span class="hljs-built_in">max</span>(candi_proba))<br>                        corrected_sentence[i] = candidates[index]<br>                        corrected_words += <span class="hljs-number">1</span><br><br>            <span class="hljs-comment"># 将纠正后的句子写入结果文件</span><br>            corrected_sentence_str = <span class="hljs-string">&#x27; &#x27;</span>.join(corrected_sentence)<br>            <span class="hljs-comment"># 修正常见的标点间距问题</span><br>            corrected_sentence_str = corrected_sentence_str.replace(<span class="hljs-string">&quot; &#x27;s&quot;</span>, <span class="hljs-string">&quot;&#x27;s&quot;</span>).replace(<span class="hljs-string">&quot; ,&quot;</span>, <span class="hljs-string">&quot;,&quot;</span>).replace(<span class="hljs-string">&quot; .&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>).replace(<span class="hljs-string">&quot; ?&quot;</span>, <span class="hljs-string">&quot;?&quot;</span>).replace(<span class="hljs-string">&quot; !&quot;</span>, <span class="hljs-string">&quot;!&quot;</span>).replace(<span class="hljs-string">&quot; ;&quot;</span>, <span class="hljs-string">&quot;;&quot;</span>).replace(<span class="hljs-string">&quot; :&quot;</span>, <span class="hljs-string">&quot;:&quot;</span>).replace(<span class="hljs-string">&quot; (&quot;</span>, <span class="hljs-string">&quot;(&quot;</span>).replace(<span class="hljs-string">&quot; )&quot;</span>, <span class="hljs-string">&quot;)&quot;</span>)<br>            resultfile.write(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;item[<span class="hljs-number">0</span>]&#125;</span>\t<span class="hljs-subst">&#123;corrected_sentence_str&#125;</span>\n&quot;</span>)<br><br><br><span class="hljs-comment"># 运行拼写纠正</span><br>lambdas = (<span class="hljs-number">0.01</span>, <span class="hljs-number">0.8</span>, <span class="hljs-number">0.19</span>)  <span class="hljs-comment"># 设定插值平滑参数</span><br>spell_correct(vocab, testdata, gram_count, corpus_text, V, trie, lambdas)<br><br></code></pre></td></tr></table></figure><p>eval.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> nltk<br>anspath=<span class="hljs-string">&#x27;./ans.txt&#x27;</span><br>resultpath=<span class="hljs-string">&#x27;./result.txt&#x27;</span><br>ansfile=<span class="hljs-built_in">open</span>(anspath,<span class="hljs-string">&#x27;r&#x27;</span>)<br>resultfile=<span class="hljs-built_in">open</span>(resultpath,<span class="hljs-string">&#x27;r&#x27;</span>)<br>count=<span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1000</span>):<br>    ansline=ansfile.readline().split(<span class="hljs-string">&#x27;\t&#x27;</span>)[<span class="hljs-number">1</span>]<br>    ansset=<span class="hljs-built_in">set</span>(nltk.word_tokenize(ansline))<br>    resultline=resultfile.readline().split(<span class="hljs-string">&#x27;\t&#x27;</span>)[<span class="hljs-number">1</span>]<br>    resultset=<span class="hljs-built_in">set</span>(nltk.word_tokenize(resultline))<br>    <span class="hljs-keyword">if</span> ansset==resultset:<br>        count+=<span class="hljs-number">1</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Accuracy is : %.2f%%&quot;</span> % (count*<span class="hljs-number">1.00</span>/<span class="hljs-number">10</span>))<br><br></code></pre></td></tr></table></figure><p>GUI.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> nltk<br><span class="hljs-keyword">from</span> nltk.tokenize <span class="hljs-keyword">import</span> word_tokenize<br><span class="hljs-keyword">from</span> nltk.corpus <span class="hljs-keyword">import</span> reuters<br><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> Counter, defaultdict, deque<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> ast<br><span class="hljs-keyword">import</span> tkinter <span class="hljs-keyword">as</span> tk<br><span class="hljs-keyword">from</span> tkinter <span class="hljs-keyword">import</span> scrolledtext<br><br><span class="hljs-comment"># 预处理函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">preprocessing</span>(<span class="hljs-params">ngram, cate</span>):<br>    <span class="hljs-comment"># 读取词汇表</span><br>    vocabpath = <span class="hljs-string">&#x27;./vocab.txt&#x27;</span><br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(vocabpath, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> vocabfile:<br>        vocab_list = [line.strip() <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> vocabfile]<br>    <br>    corpus_raw_text = reuters.sents(categories=cate)<br>    corpus_text = []<br>    gram_count = defaultdict(<span class="hljs-built_in">int</span>)<br>    vocab_corpus = <span class="hljs-built_in">set</span>()<br><br>    <span class="hljs-keyword">for</span> sents <span class="hljs-keyword">in</span> corpus_raw_text:<br>        sents = [<span class="hljs-string">&#x27;&lt;s&gt;&#x27;</span>] + sents + [<span class="hljs-string">&#x27;&lt;/s&gt;&#x27;</span>]<br>        corpus_text.extend(sents)<br>        vocab_corpus.update(sents)<br>        <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, ngram + <span class="hljs-number">2</span>):<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n, <span class="hljs-built_in">len</span>(sents) + <span class="hljs-number">1</span>):<br>                gram = <span class="hljs-string">&#x27; &#x27;</span>.join(sents[i - n: i])<br>                gram_count[gram] += <span class="hljs-number">1</span><br><br>    V = <span class="hljs-built_in">len</span>(vocab_corpus)<br>    <span class="hljs-keyword">return</span> vocab_list, gram_count, <span class="hljs-built_in">list</span>(vocab_corpus), corpus_text, V<br><br><span class="hljs-comment"># 路透社语料库</span><br>cate = reuters.categories()<br><br><span class="hljs-comment"># 结合语料库进行预处理</span><br>vocab, gram_count, vocab_corpus, corpus_text, V = preprocessing(<span class="hljs-number">2</span>, cate)<br><br><span class="hljs-comment"># 从外部数据文件加载混淆矩阵</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">loadConfusionMatrix</span>():<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;addconfusion.data&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>        addmatrix = ast.literal_eval(f.read())<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;subconfusion.data&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>        submatrix = ast.literal_eval(f.read())<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;revconfusion.data&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>        revmatrix = ast.literal_eval(f.read())<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;delconfusion.data&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>        delmatrix = ast.literal_eval(f.read())<br>    <span class="hljs-keyword">return</span> addmatrix, submatrix, revmatrix, delmatrix<br><br>addmatrix, submatrix, revmatrix, delmatrix = loadConfusionMatrix()<br><br>END = <span class="hljs-string">&#x27;$&#x27;</span>  <span class="hljs-comment"># 用于表示单词结束的特殊标记</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">make_trie</span>(<span class="hljs-params">vocab</span>):<br>    trie = &#123;&#125;<br>    <span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> vocab:<br>        t = trie<br>        <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> word:<br>            <span class="hljs-keyword">if</span> c <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> t:<br>                t[c] = &#123;&#125;<br>            t = t[c]<br>        t[END] = &#123;&#125;<br>    <span class="hljs-keyword">return</span> trie<br><br>trie = make_trie(vocab)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">editType</span>(<span class="hljs-params">candidate, word</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(candidate) == <span class="hljs-built_in">len</span>(word):<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(candidate)):<br>            <span class="hljs-keyword">if</span> candidate[i] != word[i]:<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;sub&#x27;</span>, candidate[i], word[i], (candidate[i], word[i])<br>    <span class="hljs-keyword">elif</span> <span class="hljs-built_in">len</span>(candidate) + <span class="hljs-number">1</span> == <span class="hljs-built_in">len</span>(word):<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(candidate)):<br>            <span class="hljs-keyword">if</span> candidate[i] != word[i]:<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;del&#x27;</span>, candidate[i], word[i], (candidate[i], word[i + <span class="hljs-number">1</span>])<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;del&#x27;</span>, candidate[-<span class="hljs-number">1</span>], <span class="hljs-string">&#x27;&#x27;</span>, (candidate[-<span class="hljs-number">1</span>], <span class="hljs-string">&#x27;&#x27;</span>)<br>    <span class="hljs-keyword">elif</span> <span class="hljs-built_in">len</span>(candidate) == <span class="hljs-built_in">len</span>(word) + <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(word)):<br>            <span class="hljs-keyword">if</span> candidate[i] != word[i]:<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;add&#x27;</span>, candidate[i], word[i], (candidate[i], word[i])<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;add&#x27;</span>, candidate[-<span class="hljs-number">1</span>], <span class="hljs-string">&#x27;&#x27;</span>, (candidate[-<span class="hljs-number">1</span>], <span class="hljs-string">&#x27;&#x27;</span>)<br>    <span class="hljs-keyword">elif</span> <span class="hljs-built_in">len</span>(candidate) == <span class="hljs-built_in">len</span>(word):<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(candidate) - <span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> candidate[i] != word[i] <span class="hljs-keyword">and</span> candidate[i + <span class="hljs-number">1</span>] != word[i + <span class="hljs-number">1</span>]:<br>                <span class="hljs-keyword">if</span> candidate[i] == word[i + <span class="hljs-number">1</span>] <span class="hljs-keyword">and</span> candidate[i + <span class="hljs-number">1</span>] == word[i]:<br>                    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;rev&#x27;</span>, candidate[i], word[i], (candidate[i], candidate[i + <span class="hljs-number">1</span>])<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">interpolated_language_model</span>(<span class="hljs-params">gram_count, V, data, lambdas, K=<span class="hljs-number">0.001</span></span>):<br>    unigram_lambda, bigram_lambda, trigram_lambda = lambdas<br>    total_log_prob = <span class="hljs-number">0</span><br>    total_count = <span class="hljs-built_in">sum</span>(gram_count.values())<br>    <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(data)):<br>        unigram = data[i]<br>        bigram = <span class="hljs-string">&#x27; &#x27;</span>.join(data[i-<span class="hljs-number">1</span>:i+<span class="hljs-number">1</span>]) <span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span><br>        trigram = <span class="hljs-string">&#x27; &#x27;</span>.join(data[i-<span class="hljs-number">2</span>:i+<span class="hljs-number">1</span>]) <span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span><br>        <br>        unigram_prob = (gram_count[unigram] + K) / (total_count + K * V)<br>        <br>        <span class="hljs-keyword">if</span> bigram:<br>            bigram_prob = (gram_count[bigram] + K) / (gram_count[data[i-<span class="hljs-number">1</span>]] + K * V) <span class="hljs-keyword">if</span> data[i-<span class="hljs-number">1</span>] <span class="hljs-keyword">in</span> gram_count <span class="hljs-keyword">else</span> K / V<br>        <span class="hljs-keyword">else</span>:<br>            bigram_prob = <span class="hljs-number">0</span><br>        <br>        <span class="hljs-keyword">if</span> trigram:<br>            trigram_prob = (gram_count[trigram] + K) / (gram_count[<span class="hljs-string">&#x27; &#x27;</span>.join(data[i-<span class="hljs-number">2</span>:i])] + K * V) <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27; &#x27;</span>.join(data[i-<span class="hljs-number">2</span>:i]) <span class="hljs-keyword">in</span> gram_count <span class="hljs-keyword">else</span> K / V<br>        <span class="hljs-keyword">else</span>:<br>            trigram_prob = <span class="hljs-number">0</span><br>        <br>        interpolated_prob = (unigram_lambda * unigram_prob +<br>                             bigram_lambda * bigram_prob +<br>                             trigram_lambda * trigram_prob)<br>                             <br>        total_log_prob += np.log(interpolated_prob)<br>        <br>    <span class="hljs-keyword">return</span> total_log_prob<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_candidate</span>(<span class="hljs-params">trie, word, edit_distance=<span class="hljs-number">1</span></span>):<br>    que = deque([(trie, word, <span class="hljs-string">&#x27;&#x27;</span>, edit_distance)])<br>    <br>    <span class="hljs-keyword">while</span> que:<br>        trie, word, path, edit_distance = que.popleft()<br>        <br>        <span class="hljs-keyword">if</span> word == <span class="hljs-string">&#x27;&#x27;</span>:<br>            <span class="hljs-keyword">if</span> END <span class="hljs-keyword">in</span> trie:<br>                <span class="hljs-keyword">yield</span> path<br>            <br>            <span class="hljs-keyword">if</span> edit_distance &gt; <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> trie:<br>                    <span class="hljs-keyword">if</span> k != END:<br>                        que.appendleft((trie[k], <span class="hljs-string">&#x27;&#x27;</span>, path + k, edit_distance - <span class="hljs-number">1</span>))<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">if</span> word[<span class="hljs-number">0</span>] <span class="hljs-keyword">in</span> trie:<br>                que.appendleft((trie[word[<span class="hljs-number">0</span>]], word[<span class="hljs-number">1</span>:], path + word[<span class="hljs-number">0</span>], edit_distance))<br>            <br>            <span class="hljs-keyword">if</span> edit_distance &gt; <span class="hljs-number">0</span>:<br>                edit_distance -= <span class="hljs-number">1</span><br>                <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> trie.keys() - &#123;word[<span class="hljs-number">0</span>], END&#125;:<br>                    que.append((trie[k], word[<span class="hljs-number">1</span>:], path + k, edit_distance))<br>                    que.append((trie[k], word, path + k, edit_distance))<br>                <br>                que.append((trie, word[<span class="hljs-number">1</span>:], path, edit_distance))<br>                <br>                <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(word) &gt; <span class="hljs-number">1</span>:<br>                    que.append((trie, word[<span class="hljs-number">1</span>] + word[<span class="hljs-number">0</span>] + word[<span class="hljs-number">2</span>:], path, edit_distance))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">channelModel</span>(<span class="hljs-params">x, y, edit, corpus, k=<span class="hljs-number">0.01</span></span>):<br>    corpus_str = <span class="hljs-string">&#x27; &#x27;</span>.join(corpus)<br>    corpus_len = <span class="hljs-built_in">len</span>(corpus)<br><br>    <span class="hljs-keyword">if</span> edit == <span class="hljs-string">&#x27;add&#x27;</span>:<br>        count_xy = addmatrix.get(x + y, <span class="hljs-number">0</span>)<br>        count_y = corpus_str.count(<span class="hljs-string">&#x27; &#x27;</span> + y) <span class="hljs-keyword">if</span> x == <span class="hljs-string">&#x27;#&#x27;</span> <span class="hljs-keyword">else</span> corpus_str.count(x)<br>        <span class="hljs-keyword">return</span> (count_xy + k) / (count_y + k * corpus_len) <span class="hljs-keyword">if</span> count_y <span class="hljs-keyword">else</span> (count_xy + k) / corpus_len<br><br>    <span class="hljs-keyword">if</span> edit == <span class="hljs-string">&#x27;sub&#x27;</span>:<br>        count_xy = submatrix.get((x + y)[:<span class="hljs-number">2</span>], <span class="hljs-number">0</span>)<br>        count_y = corpus_str.count(y)<br>        <span class="hljs-keyword">return</span> (count_xy + k) / (count_y + k * corpus_len) <span class="hljs-keyword">if</span> count_y <span class="hljs-keyword">else</span> (count_xy + k) / corpus_len<br><br>    <span class="hljs-keyword">if</span> edit == <span class="hljs-string">&#x27;rev&#x27;</span>:<br>        count_xy = revmatrix.get(x + y, <span class="hljs-number">0</span>)<br>        count_xy_in_corpus = corpus_str.count(x + y)<br>        <span class="hljs-keyword">return</span> (count_xy + k) / (count_xy_in_corpus + k * corpus_len) <span class="hljs-keyword">if</span> count_xy_in_corpus <span class="hljs-keyword">else</span> (count_xy + k) / corpus_len<br><br>    <span class="hljs-keyword">if</span> edit == <span class="hljs-string">&#x27;del&#x27;</span>:<br>        count_xy = delmatrix.get(x + y, <span class="hljs-number">0</span>)<br>        count_xy_in_corpus = corpus_str.count(x + y)<br>        <span class="hljs-keyword">return</span> (count_xy + k) / (count_xy_in_corpus + k * corpus_len) <span class="hljs-keyword">if</span> count_xy_in_corpus <span class="hljs-keyword">else</span> (count_xy + k) / corpus_len<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> / corpus_len<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">spell_correct_sentence</span>(<span class="hljs-params">sentence, vocab, gram_count, corpus, V, lambdas</span>):<br>    words = word_tokenize(sentence)<br>    corrected_sentence = []<br>    <br>    <span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> words:<br>        <span class="hljs-keyword">if</span> word <span class="hljs-keyword">in</span> vocab:<br>            corrected_sentence.append(word)<br>        <span class="hljs-keyword">else</span>:<br>            candidates = <span class="hljs-built_in">list</span>(get_candidate(trie, word, edit_distance=<span class="hljs-number">2</span>))<br>            best_candidate = word<br>            best_prob = <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;-inf&#x27;</span>)<br>            <br>            <span class="hljs-keyword">for</span> candidate <span class="hljs-keyword">in</span> candidates:<br>                edit = editType(candidate, word)<br>                <span class="hljs-keyword">if</span> edit:<br>                    edit_prob = channelModel(edit[<span class="hljs-number">1</span>], edit[<span class="hljs-number">2</span>], edit[<span class="hljs-number">0</span>], corpus)<br>                <span class="hljs-keyword">else</span>:<br>                    edit_prob = <span class="hljs-number">1</span><br>                <br>                candidate_sentence = corrected_sentence + [candidate] + words[<span class="hljs-built_in">len</span>(corrected_sentence) + <span class="hljs-number">1</span>:]<br>                lm_prob = interpolated_language_model(gram_count, V, candidate_sentence, lambdas)<br>                total_prob = np.log(edit_prob) + lm_prob<br>                <br>                <span class="hljs-keyword">if</span> total_prob &gt; best_prob:<br>                    best_prob = total_prob<br>                    best_candidate = candidate<br>            <br>            corrected_sentence.append(best_candidate)<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27; &#x27;</span>.join(corrected_sentence)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">correct_spelling</span>():<br>    input_sentence = input_text.get(<span class="hljs-string">&quot;1.0&quot;</span>, tk.END).strip()<br>    corrected_sentence = spell_correct_sentence(input_sentence, vocab, gram_count, corpus_text, V, (<span class="hljs-number">0.01</span>, <span class="hljs-number">0.8</span>, <span class="hljs-number">0.19</span>))<br>    output_text.delete(<span class="hljs-string">&quot;1.0&quot;</span>, tk.END)<br>    output_text.insert(tk.END, corrected_sentence)<br><br><span class="hljs-comment"># 创建主窗口</span><br>root = tk.Tk()<br>root.title(<span class="hljs-string">&quot;拼写纠正&quot;</span>)<br><br><span class="hljs-comment"># 创建文本输入框</span><br>input_text = tk.Text(root, height=<span class="hljs-number">10</span>, width=<span class="hljs-number">50</span>)<br>input_text.pack()<br><br><span class="hljs-comment"># 创建纠正按钮</span><br>correct_button = tk.Button(root, text=<span class="hljs-string">&quot;纠正&quot;</span>, command=correct_spelling)<br>correct_button.pack()<br><br><span class="hljs-comment"># 创建文本输出框</span><br>output_text = scrolledtext.ScrolledText(root, height=<span class="hljs-number">10</span>, width=<span class="hljs-number">50</span>)<br>output_text.pack()<br><br><span class="hljs-comment"># 运行主循环</span><br>root.mainloop()<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>NLP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NLP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MarsCode-贪心的小包</title>
    <link href="/2024/10/24/MarsCode-%E8%B4%AA%E5%BF%83%E7%9A%84%E5%B0%8F%E5%8C%85/"/>
    <url>/2024/10/24/MarsCode-%E8%B4%AA%E5%BF%83%E7%9A%84%E5%B0%8F%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h2 id="贪心的小包"><a href="#贪心的小包" class="headerlink" title="贪心的小包"></a>贪心的小包</h2><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>小包非常喜欢吃甜点，他收到了一次性送来的 N<em>N</em> 个甜点，每个甜点都有一个对应的喜爱值。</p><p>但是这还不够！小包让小哥连续送来了 M<em>M</em> 次相同的 N<em>N</em> 个甜点，并将这些甜点首尾相接排成一排。</p><p>现在，小包面前有 (N×M)(<em>N</em>×<em>M</em>) 个排成一排的甜点，小包希望从中选择一段连续的甜点，使得这段甜点的总喜爱值最大化。</p><p>注意：尽管小包喜欢甜食，但有些甜点可能不合口味，导致其喜爱值为<strong>负数</strong>。小包至少要选择一个甜点来满足他对甜点的贪心。</p><h2 id="输入参数"><a href="#输入参数" class="headerlink" title="输入参数"></a>输入参数</h2><ul><li>整数 ( N )：表示每次送来的甜点数量。</li><li>整数 ( M )：表示送来的次数。</li><li>数组 <code>data</code>：长度为 ( N )，表示每个甜点的喜爱值。</li></ul><h2 id="返回结果"><a href="#返回结果" class="headerlink" title="返回结果"></a>返回结果</h2><ul><li>一个整数，表示在 N×M<em>N</em>×<em>M</em> 个甜点中可以选择的连续甜点段的最大总喜爱值。</li></ul><hr><h2 id="测试样例"><a href="#测试样例" class="headerlink" title="测试样例"></a>测试样例</h2><p><em><strong>样例1：</strong></em></p><blockquote><p>输入：<code>N = 5 ,M = 1 ,data = [1, 3, -9, 2, 4]</code><br>输出：<code>6</code><br>解释：选择甜点 <code>[2, 4]</code>，最大总喜爱值为 6</p></blockquote><p><em><strong>样例2：</strong></em></p><blockquote><p>输入：<code>N = 5 ,M = 3 ,data = [1, 3, -9, 2, 4]</code><br>输出：<code>11</code><br>解释：排列后甜点为 <code>[1, 3, -9, 2, 4, 1, 3, -9, 2, 4, 1, 3, -9, 2, 4]</code>。<br>选择 <code>[2, 4, 1, 3, -9, 2, 4, 1, 3]</code> 这段连续甜点，最大总喜爱值为 <code>11</code></p></blockquote><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>动态规划（复杂度较高）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">solution</span>(<span class="hljs-params">N, M, data</span>):<br>    <span class="hljs-comment"># Edit your code here</span><br>    extended_data = data * M<br>    <span class="hljs-comment"># 求最大连续子数组和 O(N*M)^2</span><br>    lenth = <span class="hljs-built_in">len</span>(extended_data)<br>    dp = [[<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(lenth)] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(lenth)]<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(lenth):<br>        dp[i][i] = extended_data[i]<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(lenth):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i+<span class="hljs-number">1</span>, lenth):<br>            dp[i][j] = dp[i][j-<span class="hljs-number">1</span>] + extended_data[j]<br>    ans = -<span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(lenth):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i, lenth):<br>            <span class="hljs-keyword">if</span> ans &lt; dp[i][j]:<br>                ans = dp[i][j]<br>    <span class="hljs-keyword">return</span> ans<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-comment"># Add your test cases here</span><br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">5</span>, <span class="hljs-number">1</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, -<span class="hljs-number">9</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>]) == <span class="hljs-number">6</span>)<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, -<span class="hljs-number">9</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>]) == <span class="hljs-number">11</span>)<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>MarsCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MarsCode-贪心猫的鱼干大分配</title>
    <link href="/2024/10/24/MarsCode-%E8%B4%AA%E5%BF%83%E7%8C%AB%E7%9A%84%E9%B1%BC%E5%B9%B2%E5%A4%A7%E5%88%86%E9%85%8D/"/>
    <url>/2024/10/24/MarsCode-%E8%B4%AA%E5%BF%83%E7%8C%AB%E7%9A%84%E9%B1%BC%E5%B9%B2%E5%A4%A7%E5%88%86%E9%85%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="贪心猫的鱼干大分配"><a href="#贪心猫的鱼干大分配" class="headerlink" title="贪心猫的鱼干大分配"></a>贪心猫的鱼干大分配</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在猫星球上，小R负责给一行排队的猫分发鱼干。每只猫有一个等级，等级越高的猫应该得到更多的鱼干。规则如下：</p><ol><li>每只猫至少得到一斤鱼干。</li><li>如果一只猫的等级高于它相邻的猫，它就应该得到比相邻的猫更多的鱼干。</li></ol><p>小R想知道，为了公平地满足所有猫的等级差异，他至少需要准备多少斤鱼干。</p><hr><h2 id="测试样例"><a href="#测试样例" class="headerlink" title="测试样例"></a>测试样例</h2><p><em><strong>样例1：</strong></em></p><blockquote><p>输入：<code>n = 3, cats_levels = [1, 2, 2]</code><br>输出：<code>4</code></p></blockquote><p><em><strong>样例2：</strong></em></p><blockquote><p>输入：<code>n = 6, cats_levels = [6, 5, 4, 3, 2, 16]</code><br>输出：<code>17</code></p></blockquote><p><em><strong>样例3：</strong></em></p><blockquote><p>输入：<code>n = 20, cats_levels = [1, 2, 2, 3, 3, 20, 1, 2, 3, 3, 2, 1, 5, 6, 6, 5, 5, 7, 7, 4]</code><br>输出：<code>35</code></p></blockquote><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">solution</span>(<span class="hljs-params">n, cats_levels</span>):<br>    <span class="hljs-comment"># Please write your code here</span><br>    fish = [<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)] <br>    <span class="hljs-comment"># 从左到右遍历，再从右到左遍历</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n):<br>        <span class="hljs-keyword">if</span> cats_levels[i] &gt; cats_levels[i-<span class="hljs-number">1</span>]:<br>            fish[i] = fish[i-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n-<span class="hljs-number">2</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">if</span> cats_levels[i] &gt; cats_levels[i+<span class="hljs-number">1</span>] <span class="hljs-keyword">and</span> fish[i] &lt;= fish[i+<span class="hljs-number">1</span>]:<br>            fish[i] = fish[i+<span class="hljs-number">1</span>]+<span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(fish)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-comment">#  You can add more test cases here</span><br>    cats_levels1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>]<br>    cats_levels2 = [<span class="hljs-number">6</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">16</span>]<br>    cats_levels3 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">20</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">7</span>, <span class="hljs-number">4</span>]<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">3</span>, cats_levels1) == <span class="hljs-number">4</span>)<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">6</span>, cats_levels2) == <span class="hljs-number">17</span>)<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">20</span>, cats_levels3) == <span class="hljs-number">35</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>MarsCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>循环</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MarsCode-最大相等分割红包金额</title>
    <link href="/2024/10/24/MarsCode-%E6%9C%80%E5%A4%A7%E7%9B%B8%E7%AD%89%E5%88%86%E5%89%B2%E7%BA%A2%E5%8C%85%E9%87%91%E9%A2%9D/"/>
    <url>/2024/10/24/MarsCode-%E6%9C%80%E5%A4%A7%E7%9B%B8%E7%AD%89%E5%88%86%E5%89%B2%E7%BA%A2%E5%8C%85%E9%87%91%E9%A2%9D/</url>
    
    <content type="html"><![CDATA[<h1 id="最大相等分割红包金额"><a href="#最大相等分割红包金额" class="headerlink" title="最大相等分割红包金额"></a>最大相等分割红包金额</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>小U在公司年会上运气极佳，赢得了一等奖。作为一等奖得主，他有机会在一排红包中做两次切割，将红包分成三部分，要求第一部分和第三部分的红包总金额相等。他可以获得的金额是第一部分红包的总金额。帮小U计算出他能从这些红包中拿到的最大奖金金额。</p><hr><h2 id="测试样例"><a href="#测试样例" class="headerlink" title="测试样例"></a>测试样例</h2><p><em><strong>样例1：</strong></em></p><blockquote><p>输入：<code>redpacks = [1, 3, 4, 6, 7, 14]</code><br>输出：<code>14</code></p></blockquote><p><em><strong>样例2：</strong></em></p><blockquote><p>输入：<code>redpacks = [10000]</code><br>输出：<code>0</code></p></blockquote><p><em><strong>样例3：</strong></em></p><blockquote><p>输入：<code>redpacks = [10, 10, 10, 10]</code><br>输出：<code>20</code></p></blockquote><p><em><strong>样例4：</strong></em></p><blockquote><p>输入：<code>redpacks = [5, 5, 10, 20, 10, 5, 5]</code><br>输出：<code>20</code></p></blockquote><p><em><strong>样例5：</strong></em></p><blockquote><p>输入：<code>redpacks = [7, 7, 7, 21, 7, 7]</code><br>输出：<code>14</code></p></blockquote><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>双指针解法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">solution</span>(<span class="hljs-params">redpacks</span>):<br>    <span class="hljs-comment"># Please write your code here</span><br>    <span class="hljs-comment"># 双指针</span><br>    i, j = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(redpacks)-<span class="hljs-number">1</span><br>    first, third = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>    res = []<br>    <span class="hljs-keyword">while</span> i &lt;= j :<br>        <span class="hljs-keyword">if</span> first &lt; third:<br>            first += redpacks[i]<br>            i += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">elif</span> third &lt; first:<br>            third += redpacks[j]<br>            j -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            res.append((i, j, first))<br>            <span class="hljs-keyword">if</span> i != j:<br>                first += redpacks[i]<br>                i += <span class="hljs-number">1</span><br>                third += redpacks[j]<br>                j -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">if</span> first == third <span class="hljs-keyword">and</span> i &gt; j:<br>        res.append((i, j, first))<br>    i, j, ans = res[-<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">return</span> ans<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-comment">#  You can add more test cases here</span><br>    <span class="hljs-built_in">print</span>(solution([<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>]) == <span class="hljs-number">20</span>)<br>    <span class="hljs-built_in">print</span>(solution([<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">14</span>]) == <span class="hljs-number">14</span>)<br>    <span class="hljs-built_in">print</span>(solution([<span class="hljs-number">10000</span>]) == <span class="hljs-number">0</span>)<br>    <span class="hljs-built_in">print</span>(solution([<span class="hljs-number">52</span>, <span class="hljs-number">13</span>, <span class="hljs-number">61</span>, <span class="hljs-number">64</span>, <span class="hljs-number">42</span>, <span class="hljs-number">26</span>, <span class="hljs-number">4</span>, <span class="hljs-number">27</span>, <span class="hljs-number">25</span>]) == <span class="hljs-number">52</span>)<br>    <span class="hljs-built_in">print</span>(solution([<span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">50</span>, <span class="hljs-number">30</span>, <span class="hljs-number">60</span>, <span class="hljs-number">52</span>, <span class="hljs-number">26</span>, <span class="hljs-number">5</span>, <span class="hljs-number">74</span>, <span class="hljs-number">83</span>, <span class="hljs-number">34</span>, <span class="hljs-number">96</span>, <span class="hljs-number">6</span>, <span class="hljs-number">88</span>, <span class="hljs-number">94</span>, <span class="hljs-number">80</span>, <span class="hljs-number">64</span>, <span class="hljs-number">22</span>, <span class="hljs-number">97</span>, <span class="hljs-number">47</span>, <span class="hljs-number">46</span>, <span class="hljs-number">25</span>, <span class="hljs-number">24</span>, <span class="hljs-number">43</span>, <span class="hljs-number">76</span>, <span class="hljs-number">24</span>, <span class="hljs-number">2</span>, <span class="hljs-number">42</span>, <span class="hljs-number">51</span>, <span class="hljs-number">96</span>, <span class="hljs-number">97</span>, <span class="hljs-number">87</span>, <span class="hljs-number">47</span>, <span class="hljs-number">93</span>, <span class="hljs-number">11</span>, <span class="hljs-number">98</span>, <span class="hljs-number">41</span>, <span class="hljs-number">54</span>, <span class="hljs-number">18</span>, <span class="hljs-number">16</span>, <span class="hljs-number">11</span>, <span class="hljs-number">96</span>, <span class="hljs-number">34</span>, <span class="hljs-number">36</span>, <span class="hljs-number">87</span>, <span class="hljs-number">24</span>, <span class="hljs-number">32</span>, <span class="hljs-number">27</span>, <span class="hljs-number">62</span>, <span class="hljs-number">72</span>, <span class="hljs-number">54</span>, <span class="hljs-number">14</span>, <span class="hljs-number">67</span>, <span class="hljs-number">5</span>, <span class="hljs-number">21</span>, <span class="hljs-number">20</span>, <span class="hljs-number">44</span>, <span class="hljs-number">55</span>, <span class="hljs-number">3</span>, <span class="hljs-number">82</span>, <span class="hljs-number">19</span>, <span class="hljs-number">45</span>, <span class="hljs-number">1</span>, <span class="hljs-number">52</span>, <span class="hljs-number">14</span>, <span class="hljs-number">44</span>, <span class="hljs-number">46</span>, <span class="hljs-number">39</span>, <span class="hljs-number">83</span>, <span class="hljs-number">27</span>, <span class="hljs-number">30</span>, <span class="hljs-number">87</span>, <span class="hljs-number">61</span>, <span class="hljs-number">56</span>, <span class="hljs-number">59</span>, <span class="hljs-number">10</span>, <span class="hljs-number">83</span>, <span class="hljs-number">80</span>, <span class="hljs-number">42</span>, <span class="hljs-number">44</span>, <span class="hljs-number">75</span>, <span class="hljs-number">39</span>, <span class="hljs-number">43</span>, <span class="hljs-number">41</span>, <span class="hljs-number">23</span>, <span class="hljs-number">93</span>, <span class="hljs-number">73</span>, <span class="hljs-number">50</span>, <span class="hljs-number">94</span>, <span class="hljs-number">94</span>, <span class="hljs-number">82</span>, <span class="hljs-number">46</span>, <span class="hljs-number">87</span>, <span class="hljs-number">60</span>, <span class="hljs-number">94</span>, <span class="hljs-number">47</span>, <span class="hljs-number">52</span>, <span class="hljs-number">67</span>, <span class="hljs-number">22</span>, <span class="hljs-number">50</span>, <span class="hljs-number">49</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">30</span>, <span class="hljs-number">62</span>, <span class="hljs-number">87</span>, <span class="hljs-number">13</span>, <span class="hljs-number">11</span>]) == <span class="hljs-number">2627</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>MarsCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Pytorch入门</title>
    <link href="/2024/10/22/PyTorch%E5%85%A5%E9%97%A8/"/>
    <url>/2024/10/22/PyTorch%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="PyTorch入门"><a href="#PyTorch入门" class="headerlink" title="PyTorch入门"></a>PyTorch入门</h1><blockquote><p>来源于bilibili土堆视频笔记</p></blockquote><h2 id="加载数据"><a href="#加载数据" class="headerlink" title="加载数据"></a>加载数据</h2><p>Dataset类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#read_data.py</span><br><span class="hljs-keyword">from</span> torch.utils.data <span class="hljs-keyword">import</span> Dataset<br><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<br><span class="hljs-keyword">import</span> os<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyData</span>(<span class="hljs-title class_ inherited__">Dataset</span>):<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, root_dir, label_dir</span>):<br>        self.root_dir = root_dir<br>        self.label_dir = label_dir<br>        self.path = os.path.join(self.root_dir,self.label_dir)<br>        self.img_path = os.listdir(self.path)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getitem__</span>(<span class="hljs-params">self, idx</span>):<br>        img_name = self.img_path[idx]<br>        img_item_path = os.path.join(self.root_dir,self.label_dir, img_name)<br>        img = Image.<span class="hljs-built_in">open</span>(img_item_path)<br>        label = self.label_dir<br>        <span class="hljs-keyword">return</span> img, label<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__len__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(self.img_path)<br><br><br>root_dir = <span class="hljs-string">&quot;dataset/train&quot;</span><br>ants_label_dir = <span class="hljs-string">&quot;ants&quot;</span><br>bees_label_dir = <span class="hljs-string">&quot;bees&quot;</span><br>ants_dataset = MyData(root_dir, ants_label_dir)<br>bees_dataset = MyData(root_dir, bees_label_dir)<br><br>train_dataset = ants_dataset + bees_dataset<br><br></code></pre></td></tr></table></figure><h2 id="Tensorboard的使用"><a href="#Tensorboard的使用" class="headerlink" title="Tensorboard的使用"></a>Tensorboard的使用</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tensorboard --logdir=logs --port=6007<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20240610122550969.png" alt="image-20240610122550969"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> torch.utils.tensorboard <span class="hljs-keyword">import</span> SummaryWriter<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<br><br>writer = SummaryWriter(<span class="hljs-string">&quot;logs&quot;</span>)<br>image_path = <span class="hljs-string">&quot;data/train/bees_image/16838648_415acd9e3f.jpg&quot;</span><br>img_PIL = Image.<span class="hljs-built_in">open</span>(image_path)<br>img_array = np.array(img_PIL)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(img_array))<br><span class="hljs-built_in">print</span>(img_array.shape)<br><br>writer.add_image(<span class="hljs-string">&quot;test&quot;</span>, img_array, <span class="hljs-number">2</span>, dataformats=<span class="hljs-string">&#x27;HWC&#x27;</span>)<br><br><span class="hljs-comment"># y = 2x</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>):<br>    writer.add_scalar(<span class="hljs-string">&quot;y=2`x&quot;</span>, <span class="hljs-number">2</span>*i, i)<br><br>writer.close()<br></code></pre></td></tr></table></figure><h2 id="Transformes"><a href="#Transformes" class="headerlink" title="Transformes"></a>Transformes</h2><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20240610212315403.png" alt="image-20240610212315403"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<br><span class="hljs-keyword">from</span> torch.utils.tensorboard <span class="hljs-keyword">import</span> SummaryWriter<br><span class="hljs-keyword">from</span> torchvision <span class="hljs-keyword">import</span> transforms<br><br><span class="hljs-comment"># tensor数据类型</span><br><span class="hljs-comment"># 通过transforms.ToTensor解决两个问题</span><br><span class="hljs-comment"># 1.transforms如何使用</span><br><span class="hljs-comment"># 2.tensor数据</span><br><br>img_path = <span class="hljs-string">&quot;data/train/ants_image/0013035.jpg&quot;</span><br>img = Image.<span class="hljs-built_in">open</span>(img_path)<br><br>writer = SummaryWriter(<span class="hljs-string">&quot;logs&quot;</span>)<br><br>tensor_trans = transforms.ToTensor()<br>tensor_img = tensor_trans(img)<br><br>writer.add_image(<span class="hljs-string">&quot;Tensor_img&quot;</span>, tensor_img)<br><br>writer.close()<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20240620210452723.png" alt="image-20240620210452723"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<br><span class="hljs-keyword">from</span> torch.utils.tensorboard <span class="hljs-keyword">import</span> SummaryWriter<br><span class="hljs-keyword">from</span> torchvision <span class="hljs-keyword">import</span> transforms<br><br>writer = SummaryWriter(<span class="hljs-string">&quot;logs&quot;</span>)<br>img = Image.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;images/5650366_e22b7e1065.jpg&quot;</span>)<br><span class="hljs-built_in">print</span>(img)<br><br><span class="hljs-comment"># ToTensor</span><br>trans_totensor = transforms.ToTensor()<br>img_tensor = trans_totensor(img)<br>writer.add_image(<span class="hljs-string">&quot;ToTensor&quot;</span>,img_tensor)<br><br><span class="hljs-comment"># Normalize</span><br><span class="hljs-built_in">print</span>(img_tensor[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>])<br>trans_norm = transforms.Normalize([<span class="hljs-number">6</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">9</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>])<br>img_norm = trans_norm(img_tensor)<br><span class="hljs-comment"># print(img_norm[0][0][0])</span><br>writer.add_image(<span class="hljs-string">&quot;Normalize&quot;</span>,img_norm,<span class="hljs-number">2</span>)<br><br><span class="hljs-comment"># Resize</span><br><span class="hljs-built_in">print</span>(img.size)<br>trans_resize = transforms.Resize((<span class="hljs-number">256</span>, <span class="hljs-number">256</span>))<br><span class="hljs-comment"># img PIL -&gt; resize -&gt; img_resize PIL</span><br>img_resize = trans_resize(img)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(img_resize))<br><br><span class="hljs-comment"># img_resize PIL -&gt; totensor -&gt; img_resize tensor</span><br>img_resize = trans_totensor(img_resize)<br>writer.add_image(<span class="hljs-string">&quot;Resize&quot;</span>,img_resize,<span class="hljs-number">0</span>)<br><br><br><span class="hljs-comment"># Compose - resize - 2</span><br>trans_resize_2 = transforms.Resize(<span class="hljs-number">256</span>)<br>trans_compose = transforms.Compose([trans_resize_2, trans_totensor])<br>img_resize_2 = trans_compose(img)<br>writer.add_image(<span class="hljs-string">&quot;Compose&quot;</span>,img_resize_2,<span class="hljs-number">1</span>)<br><br><span class="hljs-comment"># RandomCrop</span><br>trans_random = transforms.RandomCrop(<span class="hljs-number">256</span>)<br>trans_compose_2 = transforms.Compose([trans_random, trans_totensor])<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>    img_crop = trans_compose_2(img)<br>    writer.add_image(<span class="hljs-string">&quot;RandomCrop&quot;</span>, img_crop, i)<br><br>writer.close()<br><br></code></pre></td></tr></table></figure><h2 id="torchvision中数据集的使用"><a href="#torchvision中数据集的使用" class="headerlink" title="torchvision中数据集的使用"></a>torchvision中数据集的使用</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torchvision<br><span class="hljs-keyword">from</span> torch.utils.tensorboard <span class="hljs-keyword">import</span> SummaryWriter<br><br>dataset_transform = torchvision.transforms.Compose([<br>    torchvision.transforms.ToTensor()<br>])<br>train_set = torchvision.datasets.CIFAR10(root=<span class="hljs-string">&quot;./dataset1&quot;</span>, train=<span class="hljs-literal">True</span>, download=<span class="hljs-literal">True</span>)<br>test_set = torchvision.datasets.CIFAR10(root=<span class="hljs-string">&quot;./dataset1&quot;</span>, train=<span class="hljs-literal">False</span>, download=<span class="hljs-literal">True</span>)<br><br><span class="hljs-comment"># print(test_set[0])</span><br><span class="hljs-comment"># print(test_set.classes)</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># img, target = test_set[0]</span><br><span class="hljs-comment"># print(img)</span><br><span class="hljs-comment"># print(target)</span><br><span class="hljs-comment"># print(test_set.classes[target])</span><br><span class="hljs-comment"># img.show()</span><br><br>writer = SummaryWriter(<span class="hljs-string">&quot;p14&quot;</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>    img, target = test_set[i]<br>    writer.add_image(<span class="hljs-string">&quot;test_set&quot;</span>, img, i)<br><br>writer.close()<br><br></code></pre></td></tr></table></figure><h2 id="DataLoader"><a href="#DataLoader" class="headerlink" title="DataLoader"></a>DataLoader</h2> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torchvision<br><br><span class="hljs-comment"># 准备的测试数据集</span><br><span class="hljs-keyword">from</span> torch.utils.data <span class="hljs-keyword">import</span> DataLoader<br><span class="hljs-keyword">from</span> torch.utils.tensorboard <span class="hljs-keyword">import</span> SummaryWriter<br><br>test_data = torchvision.datasets.CIFAR10(<span class="hljs-string">&quot;./dataset1&quot;</span>,<br>                                         train=<span class="hljs-literal">False</span>,<br>                                         transform=torchvision.transforms.ToTensor(),<br>                                         )<br><br>test_loader = DataLoader(dataset=test_data,<br>                         batch_size=<span class="hljs-number">64</span>,<br>                         shuffle=<span class="hljs-literal">True</span>,<br>                         num_workers=<span class="hljs-number">0</span>,<br>                         drop_last=<span class="hljs-literal">False</span>)<br><br>img, target = test_data[<span class="hljs-number">0</span>]<br><span class="hljs-built_in">print</span>(img.shape)<br><span class="hljs-built_in">print</span>(target)<br><br>writer = SummaryWriter(<span class="hljs-string">&quot;dataloader&quot;</span>)<br><br><span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>):<br>    step = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> data <span class="hljs-keyword">in</span> test_loader:<br>        imgs, targets = data<br>        writer.add_images(<span class="hljs-string">f&quot;Epoch<span class="hljs-subst">&#123;epoch&#125;</span>&quot;</span>, imgs, step)<br>        step = step + <span class="hljs-number">1</span><br><br>writer.close()<br><br></code></pre></td></tr></table></figure><h2 id="神经网络的基本骨架-nn-Module"><a href="#神经网络的基本骨架-nn-Module" class="headerlink" title="神经网络的基本骨架-nn.Module"></a>神经网络的基本骨架-nn.Module</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">from</span> torch <span class="hljs-keyword">import</span> nn<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Tudui</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-built_in">super</span>().__init__()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, <span class="hljs-built_in">input</span></span>):<br>        output = <span class="hljs-built_in">input</span> + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> output<br><br><br>tudui = Tudui()<br>x = torch.tensor(<span class="hljs-number">1.0</span>)<br>output = tudui(x)<br><span class="hljs-built_in">print</span>(output)<br><br></code></pre></td></tr></table></figure><h2 id="卷积操作"><a href="#卷积操作" class="headerlink" title="卷积操作"></a>卷积操作</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.nn.functional <span class="hljs-keyword">as</span> F<br><br><span class="hljs-built_in">input</span> = torch.tensor([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>],<br>                      [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>],<br>                      [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],<br>                      [<span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>],<br>                      [<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>]])<br><br>kernel = torch.tensor([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>],<br>                       [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>],<br>                       [<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>]])<br><span class="hljs-built_in">input</span> = torch.reshape(<span class="hljs-built_in">input</span>, (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>))<br>kernel = torch.reshape(kernel, (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>))<br><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">input</span>.shape)<br><span class="hljs-built_in">print</span>(kernel.shape)<br><span class="hljs-comment"># 步进stride</span><br>output = F.conv2d(<span class="hljs-built_in">input</span>, kernel, stride=<span class="hljs-number">1</span>)<br><span class="hljs-built_in">print</span>(output)<br><br>output = F.conv2d(<span class="hljs-built_in">input</span>, kernel, stride=<span class="hljs-number">2</span>)<br><span class="hljs-built_in">print</span>(output)<br><span class="hljs-comment"># padding</span><br>output = F.conv2d(<span class="hljs-built_in">input</span>, kernel, stride=<span class="hljs-number">1</span>, padding=<span class="hljs-number">1</span>)<br><span class="hljs-built_in">print</span>(output)<br><br></code></pre></td></tr></table></figure><h2 id="卷积层"><a href="#卷积层" class="headerlink" title="卷积层"></a>卷积层</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torchvision<br><span class="hljs-keyword">from</span> torch <span class="hljs-keyword">import</span> nn<br><span class="hljs-keyword">from</span> torch.nn <span class="hljs-keyword">import</span> Conv2d<br><span class="hljs-keyword">from</span> torch.utils.data <span class="hljs-keyword">import</span> DataLoader<br><span class="hljs-keyword">from</span> torch.utils.tensorboard <span class="hljs-keyword">import</span> SummaryWriter<br><br>dataset = torchvision.datasets.CIFAR10(<span class="hljs-string">&quot;./dataset1&quot;</span>,<br>                                       train=<span class="hljs-literal">False</span>,<br>                                       transform=torchvision.transforms.ToTensor(),<br>                                       download=<span class="hljs-literal">True</span>)<br>dataloader = DataLoader(dataset, batch_size=<span class="hljs-number">64</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Tudui</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>(Tudui, self).__init__()<br>        self.conv1 = Conv2d(in_channels=<span class="hljs-number">3</span>, out_channels=<span class="hljs-number">6</span>, kernel_size=<span class="hljs-number">3</span>, stride=<span class="hljs-number">1</span>, padding=<span class="hljs-number">0</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):<br>        <span class="hljs-keyword">return</span> self.conv1(x)<br><br><br>tudui = Tudui()<br><br>writer = SummaryWriter(<span class="hljs-string">&quot;dataloader&quot;</span>)<br>step = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> data <span class="hljs-keyword">in</span> dataloader:<br>    imgs, target = data<br>    output = tudui(imgs)<br>    <span class="hljs-built_in">print</span>(imgs.shape)<br>    <span class="hljs-built_in">print</span>(output.shape)<br>    writer.add_images(<span class="hljs-string">&quot;input&quot;</span>, imgs, step)<br><br>    output = torch.reshape(output, (-<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">30</span>, <span class="hljs-number">30</span>))<br>    writer.add_images(<span class="hljs-string">&quot;output&quot;</span>, output, step)<br><br>    step = step + <span class="hljs-number">1</span><br><br>writer.close()<br><br></code></pre></td></tr></table></figure><h2 id="最大池化的使用"><a href="#最大池化的使用" class="headerlink" title="最大池化的使用"></a>最大池化的使用</h2><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20240712111134822.png" alt="image-20240712111134822"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torchvision<br><span class="hljs-keyword">from</span> torch <span class="hljs-keyword">import</span> nn<br><span class="hljs-keyword">from</span> torch.nn <span class="hljs-keyword">import</span> MaxPool2d<br><span class="hljs-keyword">from</span> torch.utils.data <span class="hljs-keyword">import</span> DataLoader<br><span class="hljs-keyword">from</span> torch.utils.tensorboard <span class="hljs-keyword">import</span> SummaryWriter<br><br>dataset = torchvision.datasets.CIFAR10(<span class="hljs-string">&quot;./dataset1&quot;</span>,<br>                                       train=<span class="hljs-literal">False</span>,<br>                                       download=<span class="hljs-literal">True</span>,<br>                                       transform=torchvision.transforms.ToTensor())<br>dataloader = DataLoader(dataset, batch_size=<span class="hljs-number">64</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Tudui</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-built_in">super</span>().__init__()<br>        self.maxpool1 = MaxPool2d(kernel_size=<span class="hljs-number">3</span>,<br>                                  ceil_mode=<span class="hljs-literal">False</span>, )<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, <span class="hljs-built_in">input</span></span>):<br>        output = self.maxpool1(<span class="hljs-built_in">input</span>)<br>        <span class="hljs-keyword">return</span> output<br><br><br>tudui = Tudui()<br><br>writer = SummaryWriter(<span class="hljs-string">&quot;logs_maxpool&quot;</span>)<br>step = <span class="hljs-number">0</span><br><br><span class="hljs-keyword">for</span> data <span class="hljs-keyword">in</span> dataloader:<br>    imgs, targets = data<br>    writer.add_images(<span class="hljs-string">&quot;input&quot;</span>, imgs, step)<br>    output = tudui(imgs)<br>    writer.add_images(<span class="hljs-string">&quot;output&quot;</span>, output, step)<br>    step = step + <span class="hljs-number">1</span><br><br>writer.close()<br><br></code></pre></td></tr></table></figure><h2 id="非线性激活"><a href="#非线性激活" class="headerlink" title="非线性激活"></a>非线性激活</h2><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20240712113254623.png" alt="image-20240712113254623"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torchvision<br><span class="hljs-keyword">from</span> torch <span class="hljs-keyword">import</span> nn<br><span class="hljs-keyword">from</span> torch.nn <span class="hljs-keyword">import</span> ReLU, Sigmoid<br><span class="hljs-keyword">from</span> torch.utils.data <span class="hljs-keyword">import</span> DataLoader<br><span class="hljs-keyword">from</span> torch.utils.tensorboard <span class="hljs-keyword">import</span> SummaryWriter<br><br><span class="hljs-built_in">input</span> = torch.tensor([[<span class="hljs-number">1</span>, -<span class="hljs-number">0.5</span>],<br>                      [-<span class="hljs-number">1</span>, <span class="hljs-number">3</span>]])<br><br>output = torch.reshape(<span class="hljs-built_in">input</span>, (-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>))<br><span class="hljs-built_in">print</span>(output.shape)<br><br>dataset = torchvision.datasets.CIFAR10(<span class="hljs-string">&quot;./dataset1&quot;</span>,<br>                                       train=<span class="hljs-literal">False</span>,<br>                                       download=<span class="hljs-literal">True</span>,<br>                                       transform=torchvision.transforms.ToTensor())<br>dataloader = DataLoader(dataset, batch_size=<span class="hljs-number">64</span>)<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Tudui</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-built_in">super</span>().__init__()<br>        self.relu1 = ReLU()<br>        self.sigmoid1 = Sigmoid()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, <span class="hljs-built_in">input</span></span>):<br>        output = self.sigmoid1(<span class="hljs-built_in">input</span>)<br>        <span class="hljs-keyword">return</span> output<br><br>tudui = Tudui()<br><br>writer = SummaryWriter(<span class="hljs-string">&quot;logs_relu&quot;</span>)<br>step = <span class="hljs-number">0</span><br><br><span class="hljs-keyword">for</span> data <span class="hljs-keyword">in</span> dataloader:<br>    imgs, targets = data<br>    writer.add_images(<span class="hljs-string">&quot;input&quot;</span>, imgs, global_step=step)<br>    output = tudui(imgs)<br>    writer.add_images(<span class="hljs-string">&quot;output&quot;</span>, output, global_step=step)<br>    step = step + <span class="hljs-number">1</span><br><br>writer.close()<br></code></pre></td></tr></table></figure><h2 id="线性层和其他层"><a href="#线性层和其他层" class="headerlink" title="线性层和其他层"></a>线性层和其他层</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torchvision<br><span class="hljs-keyword">from</span> torch <span class="hljs-keyword">import</span> nn<br><span class="hljs-keyword">from</span> torch.nn <span class="hljs-keyword">import</span> Linear<br><span class="hljs-keyword">from</span> torch.utils.data <span class="hljs-keyword">import</span> DataLoader<br><span class="hljs-keyword">import</span> torch<br><br>dataset = torchvision.datasets.CIFAR10(<span class="hljs-string">&quot;./dataset1&quot;</span>,<br>                                       train=<span class="hljs-literal">False</span>,<br>                                       download=<span class="hljs-literal">True</span>,<br>                                       transform=torchvision.transforms.ToTensor())<br>dataloader = DataLoader(dataset, batch_size=<span class="hljs-number">64</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Tudui</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-built_in">super</span>().__init__()<br>        self.linear1 = Linear(<span class="hljs-number">196608</span>, <span class="hljs-number">10</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, <span class="hljs-built_in">input</span></span>):<br>        output = self.linear1(<span class="hljs-built_in">input</span>)<br>        <span class="hljs-keyword">return</span> output<br><br><br>tudui = Tudui()<br><br><span class="hljs-keyword">for</span> data <span class="hljs-keyword">in</span> dataloader:<br>    imgs, targets = data<br>    <span class="hljs-built_in">print</span>(imgs.shape)<br>    output = torch.flatten(imgs)<br>    <span class="hljs-built_in">print</span>(output.shape)<br>    output = tudui(output)<br>    <span class="hljs-built_in">print</span>(output.shape)<br><br></code></pre></td></tr></table></figure><h2 id="神经网络搭建实战和Sequential"><a href="#神经网络搭建实战和Sequential" class="headerlink" title="神经网络搭建实战和Sequential"></a>神经网络搭建实战和Sequential</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">from</span> torch <span class="hljs-keyword">import</span> nn<br><span class="hljs-keyword">from</span> torch.nn <span class="hljs-keyword">import</span> Conv2d, MaxPool2d, Flatten, Linear, Sequential<br><span class="hljs-keyword">from</span> torch.utils.tensorboard <span class="hljs-keyword">import</span> SummaryWriter<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Tudui</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>(Tudui, self).__init__()<br>        self.model1 = Sequential(<br>            Conv2d(<span class="hljs-number">3</span>, <span class="hljs-number">32</span>, <span class="hljs-number">5</span>, padding=<span class="hljs-number">2</span>),<br>            MaxPool2d(<span class="hljs-number">2</span>),<br>            Conv2d(<span class="hljs-number">32</span>, <span class="hljs-number">32</span>, <span class="hljs-number">5</span>, padding=<span class="hljs-number">2</span>),<br>            MaxPool2d(<span class="hljs-number">2</span>),<br>            Conv2d(<span class="hljs-number">32</span>, <span class="hljs-number">64</span>, <span class="hljs-number">5</span>, padding=<span class="hljs-number">2</span>),<br>            MaxPool2d(<span class="hljs-number">2</span>),<br>            Flatten(),<br>            Linear(<span class="hljs-number">1024</span>, <span class="hljs-number">64</span>),<br>            Linear(<span class="hljs-number">64</span>, <span class="hljs-number">10</span>)<br>        )<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):<br>        x = self.model1(x)<br>        <span class="hljs-keyword">return</span> x<br><br><br>tudui = Tudui()<br><span class="hljs-built_in">print</span>(tudui)<br><span class="hljs-built_in">input</span> = torch.ones((<span class="hljs-number">64</span>, <span class="hljs-number">3</span>, <span class="hljs-number">32</span>, <span class="hljs-number">32</span>))<br>output = tudui(<span class="hljs-built_in">input</span>)<br><span class="hljs-built_in">print</span>(output.shape)<br><br>writer = SummaryWriter(<span class="hljs-string">&quot;logs_seq&quot;</span>)<br>writer.add_graph(tudui, <span class="hljs-built_in">input</span>)<br>writer.close()<br><br></code></pre></td></tr></table></figure><h2 id="损失函数与反向传播"><a href="#损失函数与反向传播" class="headerlink" title="损失函数与反向传播"></a>损失函数与反向传播</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torchvision.datasets<br><span class="hljs-keyword">from</span> torch <span class="hljs-keyword">import</span> nn<br><span class="hljs-keyword">from</span> torch.nn <span class="hljs-keyword">import</span> Conv2d, MaxPool2d, Flatten, Linear, Sequential<br><span class="hljs-keyword">from</span> torch.utils.data <span class="hljs-keyword">import</span> DataLoader<br><br>dataset = torchvision.datasets.CIFAR10(<span class="hljs-string">&quot;./dataset1&quot;</span>,<br>                                       train=<span class="hljs-literal">False</span>,<br>                                       download=<span class="hljs-literal">True</span>,<br>                                       transform=torchvision.transforms.ToTensor())<br>dataloader = DataLoader(dataset, batch_size=<span class="hljs-number">1</span>)<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Tudui</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>(Tudui, self).__init__()<br>        self.model1 = Sequential(<br>            Conv2d(<span class="hljs-number">3</span>, <span class="hljs-number">32</span>, <span class="hljs-number">5</span>, padding=<span class="hljs-number">2</span>),<br>            MaxPool2d(<span class="hljs-number">2</span>),<br>            Conv2d(<span class="hljs-number">32</span>, <span class="hljs-number">32</span>, <span class="hljs-number">5</span>, padding=<span class="hljs-number">2</span>),<br>            MaxPool2d(<span class="hljs-number">2</span>),<br>            Conv2d(<span class="hljs-number">32</span>, <span class="hljs-number">64</span>, <span class="hljs-number">5</span>, padding=<span class="hljs-number">2</span>),<br>            MaxPool2d(<span class="hljs-number">2</span>),<br>            Flatten(),<br>            Linear(<span class="hljs-number">1024</span>, <span class="hljs-number">64</span>),<br>            Linear(<span class="hljs-number">64</span>, <span class="hljs-number">10</span>)<br>        )<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):<br>        x = self.model1(x)<br>        <span class="hljs-keyword">return</span> x<br><br><br>loss = nn.CrossEntropyLoss()<br>tudui = Tudui()<br><span class="hljs-keyword">for</span> data <span class="hljs-keyword">in</span> dataloader:<br>    imgs, targets = data<br>    outputs = tudui(imgs)<br>    result_loss = loss(outputs, targets)<br>    <span class="hljs-built_in">print</span>(result_loss)<br>    result_loss.backward()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;ok&#x27;</span>)<br><br></code></pre></td></tr></table></figure><h2 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch.optim<br><span class="hljs-keyword">import</span> torchvision.datasets<br><span class="hljs-keyword">from</span> torch <span class="hljs-keyword">import</span> nn<br><span class="hljs-keyword">from</span> torch.nn <span class="hljs-keyword">import</span> Conv2d, MaxPool2d, Flatten, Linear, Sequential<br><span class="hljs-keyword">from</span> torch.utils.data <span class="hljs-keyword">import</span> DataLoader<br><br>dataset = torchvision.datasets.CIFAR10(<span class="hljs-string">&quot;./dataset1&quot;</span>,<br>                                       train=<span class="hljs-literal">False</span>,<br>                                       download=<span class="hljs-literal">True</span>,<br>                                       transform=torchvision.transforms.ToTensor())<br>dataloader = DataLoader(dataset, batch_size=<span class="hljs-number">1</span>)<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Tudui</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>(Tudui, self).__init__()<br>        self.model1 = Sequential(<br>            Conv2d(<span class="hljs-number">3</span>, <span class="hljs-number">32</span>, <span class="hljs-number">5</span>, padding=<span class="hljs-number">2</span>),<br>            MaxPool2d(<span class="hljs-number">2</span>),<br>            Conv2d(<span class="hljs-number">32</span>, <span class="hljs-number">32</span>, <span class="hljs-number">5</span>, padding=<span class="hljs-number">2</span>),<br>            MaxPool2d(<span class="hljs-number">2</span>),<br>            Conv2d(<span class="hljs-number">32</span>, <span class="hljs-number">64</span>, <span class="hljs-number">5</span>, padding=<span class="hljs-number">2</span>),<br>            MaxPool2d(<span class="hljs-number">2</span>),<br>            Flatten(),<br>            Linear(<span class="hljs-number">1024</span>, <span class="hljs-number">64</span>),<br>            Linear(<span class="hljs-number">64</span>, <span class="hljs-number">10</span>)<br>        )<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):<br>        x = self.model1(x)<br>        <span class="hljs-keyword">return</span> x<br><br><br>loss = nn.CrossEntropyLoss()<br>tudui = Tudui()<br>optim = torch.optim.SGD(tudui.parameters(), lr=<span class="hljs-number">0.01</span>)<br><span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">20</span>):<br>    running_loss = <span class="hljs-number">0.0</span><br>    <span class="hljs-keyword">for</span> data <span class="hljs-keyword">in</span> dataloader:<br>        imgs, targets = data<br>        outputs = tudui(imgs)<br>        result_loss = loss(outputs, targets)<br>        optim.zero_grad()<br>        result_loss.backward()<br>        optim.step()<br>        running_loss = running_loss + result_loss<br>    <span class="hljs-built_in">print</span>(running_loss)<br><br></code></pre></td></tr></table></figure><h2 id="现有网络模型的使用和修改"><a href="#现有网络模型的使用和修改" class="headerlink" title="现有网络模型的使用和修改"></a>现有网络模型的使用和修改</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torchvision<br><span class="hljs-keyword">from</span> torch <span class="hljs-keyword">import</span> nn<br><br>vgg16_false = torchvision.models.vgg16(pretrained=<span class="hljs-literal">False</span>)<br>vgg16_true = torchvision.models.vgg16(pretrained=<span class="hljs-literal">True</span>)<br><br><span class="hljs-built_in">print</span>(vgg16_true)<br><br>train_data = torchvision.datasets.CIFAR10(<span class="hljs-string">&quot;./dataset1&quot;</span>,<br>                                          train=<span class="hljs-literal">True</span>,<br>                                          download=<span class="hljs-literal">True</span>,<br>                                          transform=torchvision.transforms.ToTensor())<br>vgg16_true.add_module(<span class="hljs-string">&#x27;add_linear&#x27;</span>,nn.Linear(<span class="hljs-number">1000</span>, <span class="hljs-number">10</span>))<br><span class="hljs-built_in">print</span>(vgg16_true)<br><br><span class="hljs-built_in">print</span>(vgg16_false)<br>vgg16_false.classifier[<span class="hljs-number">6</span>] = nn.Linear(<span class="hljs-number">4096</span>, <span class="hljs-number">10</span>)<br><span class="hljs-built_in">print</span>(vgg16_false)<br><br></code></pre></td></tr></table></figure><h2 id="模型的保存和加载"><a href="#模型的保存和加载" class="headerlink" title="模型的保存和加载"></a>模型的保存和加载</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torchvision<br><span class="hljs-keyword">from</span> torch <span class="hljs-keyword">import</span> nn<br><br>vgg16 = torchvision.models.vgg16(pretrained=<span class="hljs-literal">False</span>)<br><span class="hljs-comment"># 保存方式1 模型结构+模型参数</span><br>torch.save(vgg16, <span class="hljs-string">&quot;models/vgg16_method1.pth&quot;</span>)<br><br><span class="hljs-comment"># 保存方式2 模型参数（官方推荐）</span><br>torch.save(vgg16.state_dict(), <span class="hljs-string">&quot;models/vgg16_method2.pth&quot;</span>)<br><br><span class="hljs-comment"># 陷阱</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Tudui</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>().__init__()<br>        self.conv1 = nn.Conv2d(<span class="hljs-number">3</span>, <span class="hljs-number">64</span>, kernel_size=<span class="hljs-number">5</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):<br>        x = self.conv1(x)<br>        <span class="hljs-keyword">return</span> x<br><br><br>tudui = Tudui()<br>torch.save(tudui, <span class="hljs-string">&quot;models/tudui_method1.pth&quot;</span>)<br><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torchvision<br><span class="hljs-keyword">from</span> model_save <span class="hljs-keyword">import</span> *<br><br><span class="hljs-comment"># 方式1，加载模型</span><br>model = torch.load(<span class="hljs-string">&quot;models/vgg16_method1.pth&quot;</span>)<br><span class="hljs-comment"># print(model)</span><br><br><span class="hljs-comment"># 方法2，加载模型</span><br>vgg16 = torchvision.models.vgg16(pretrained=<span class="hljs-literal">False</span>)<br>vgg16.load_state_dict(torch.load(<span class="hljs-string">&quot;models/vgg16_method2.pth&quot;</span>))<br><span class="hljs-built_in">print</span>(vgg16)<br><br><span class="hljs-comment"># 陷阱1</span><br>model = torch.load(<span class="hljs-string">&quot;models/tudui_method1.pth&quot;</span>)<br><span class="hljs-built_in">print</span>(model)<br><br></code></pre></td></tr></table></figure><h2 id="完整模型训练套路"><a href="#完整模型训练套路" class="headerlink" title="完整模型训练套路"></a>完整模型训练套路</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 搭建神经网络</span><br><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">from</span> torch <span class="hljs-keyword">import</span> nn<br><span class="hljs-keyword">from</span> torch.nn <span class="hljs-keyword">import</span> Sequential, Conv2d, MaxPool2d, Flatten, Linear<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Tudui</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>(Tudui, self).__init__()<br>        self.model = Sequential(<br>            Conv2d(<span class="hljs-number">3</span>, <span class="hljs-number">32</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, padding=<span class="hljs-number">2</span>),<br>            MaxPool2d(<span class="hljs-number">2</span>),<br>            Conv2d(<span class="hljs-number">32</span>, <span class="hljs-number">32</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, padding=<span class="hljs-number">2</span>),<br>            MaxPool2d(<span class="hljs-number">2</span>),<br>            Conv2d(<span class="hljs-number">32</span>, <span class="hljs-number">64</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, padding=<span class="hljs-number">2</span>),<br>            MaxPool2d(<span class="hljs-number">2</span>),<br>            Flatten(),<br>            Linear(<span class="hljs-number">1024</span>, <span class="hljs-number">64</span>),<br>            Linear(<span class="hljs-number">64</span>, <span class="hljs-number">10</span>)<br>        )<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):<br>        x = self.model(x)<br>        <span class="hljs-keyword">return</span> x<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    tudui = Tudui()<br>    <span class="hljs-built_in">input</span> = torch.ones((<span class="hljs-number">64</span>, <span class="hljs-number">3</span>, <span class="hljs-number">32</span>, <span class="hljs-number">32</span>))<br>    output = tudui(<span class="hljs-built_in">input</span>)<br>    <span class="hljs-built_in">print</span>(output.shape)<br><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torchvision<br><span class="hljs-keyword">from</span> torch.utils.tensorboard <span class="hljs-keyword">import</span> SummaryWriter<br><br><span class="hljs-keyword">from</span> model <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> torch.utils.data <span class="hljs-keyword">import</span> DataLoader<br><br><span class="hljs-comment"># 准备数据集</span><br>train_data = torchvision.datasets.CIFAR10(root=<span class="hljs-string">&quot;./dataset1&quot;</span>,<br>                                          train=<span class="hljs-literal">True</span>,<br>                                          transform=torchvision.transforms.ToTensor(),<br>                                          download=<span class="hljs-literal">True</span>)<br>test_data = torchvision.datasets.CIFAR10(root=<span class="hljs-string">&quot;./dataset1&quot;</span>,<br>                                         train=<span class="hljs-literal">False</span>,<br>                                         transform=torchvision.transforms.ToTensor(),<br>                                         download=<span class="hljs-literal">True</span>)<br><span class="hljs-comment"># 长度</span><br>train_data_size = <span class="hljs-built_in">len</span>(train_data)<br>test_data_size = <span class="hljs-built_in">len</span>(test_data)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;训练数据集的长度为:&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(train_data_size))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;测试数据集的长度为:&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(test_data_size))<br><br><span class="hljs-comment"># 利用DataLoader加载数据集</span><br>train_dataloader = DataLoader(train_data, batch_size=<span class="hljs-number">64</span>)<br>test_dataloader = DataLoader(test_data, batch_size=<span class="hljs-number">64</span>)<br><br><span class="hljs-comment"># 创建网络模型</span><br>tudui = Tudui()<br><br><span class="hljs-comment"># 损失函数</span><br>loss_fn = nn.CrossEntropyLoss()<br><br><span class="hljs-comment"># 优化器</span><br>learning_rate = <span class="hljs-number">1e-2</span><br>optimizer = torch.optim.SGD(tudui.parameters(), lr=learning_rate)<br><br><span class="hljs-comment"># 设置训练网络的一些参数</span><br><span class="hljs-comment"># 记录训练的次数</span><br>total_train_step = <span class="hljs-number">0</span><br><span class="hljs-comment"># 记录测试的次数</span><br>total_test_step = <span class="hljs-number">0</span><br><span class="hljs-comment"># 训练的轮数</span><br>epoch = <span class="hljs-number">10</span><br><br><span class="hljs-comment"># 添加tensorboard</span><br>writer = SummaryWriter(<span class="hljs-string">&quot;./logs_train&quot;</span>)<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(epoch):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;-----第 &#123;&#125; 轮训练开始-----&quot;</span>.<span class="hljs-built_in">format</span>(i+<span class="hljs-number">1</span>))<br><br>    <span class="hljs-comment"># 训练步骤开始</span><br>    tudui.train()<br>    <span class="hljs-keyword">for</span> data <span class="hljs-keyword">in</span> train_dataloader:<br>        imgs, targets = data<br>        outputs = tudui(imgs)<br>        loss = loss_fn(outputs, targets)<br><br>        optimizer.zero_grad()<br>        loss.backward()<br>        optimizer.step()<br><br>        total_train_step = total_train_step + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> total_train_step % <span class="hljs-number">100</span> == <span class="hljs-number">0</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;训练次数：&#123;&#125;, Loss: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(total_train_step, loss.item()))<br>            writer.add_scalar(<span class="hljs-string">&quot;train_loss&quot;</span>, loss.item(), total_train_step)<br><br>    <span class="hljs-comment"># 测试步骤开始</span><br>    tudui.<span class="hljs-built_in">eval</span>()<br>    total_test_loss = <span class="hljs-number">0</span><br>    total_accuracy = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">with</span> torch.no_grad():<br>        <span class="hljs-keyword">for</span> data <span class="hljs-keyword">in</span> test_dataloader:<br>            imgs, targets = data<br>            outputs = tudui(imgs)<br>            loss = loss_fn(outputs, targets)<br>            total_test_loss += loss.item()<br>            accuracy = (outputs.argmax(<span class="hljs-number">1</span>) == targets).<span class="hljs-built_in">sum</span>()<br>            total_accuracy += accuracy<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;整体测试集上的Loss: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(total_test_loss))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;整体测试集上的正确率: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(total_accuracy/test_data_size))<br>    writer.add_scalar(<span class="hljs-string">&quot;test_loss&quot;</span>, total_test_loss, total_test_step)<br>    writer.add_scalar(<span class="hljs-string">&quot;test_accuracy&quot;</span>, total_accuracy/test_data_size, total_test_step)<br>    total_test_step += <span class="hljs-number">1</span><br><br>    torch.save(tudui, <span class="hljs-string">&quot;models/tudui_&#123;&#125;.pth&quot;</span>.<span class="hljs-built_in">format</span>(i))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;模型已保存&quot;</span>)<br><br>writer.close()<br><br></code></pre></td></tr></table></figure><h2 id="使用GPU训练"><a href="#使用GPU训练" class="headerlink" title="使用GPU训练"></a>使用GPU训练</h2><p>方法1： <code>.cuda</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torchvision<br><span class="hljs-keyword">from</span> torch <span class="hljs-keyword">import</span> nn<br><span class="hljs-keyword">from</span> torch.nn <span class="hljs-keyword">import</span> Sequential, Conv2d, MaxPool2d, Flatten, Linear<br><span class="hljs-keyword">from</span> torch.utils.tensorboard <span class="hljs-keyword">import</span> SummaryWriter<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> torch.utils.data <span class="hljs-keyword">import</span> DataLoader<br><br><span class="hljs-comment"># 准备数据集</span><br>train_data = torchvision.datasets.CIFAR10(root=<span class="hljs-string">&quot;./dataset1&quot;</span>,<br>                                          train=<span class="hljs-literal">True</span>,<br>                                          transform=torchvision.transforms.ToTensor(),<br>                                          download=<span class="hljs-literal">True</span>)<br>test_data = torchvision.datasets.CIFAR10(root=<span class="hljs-string">&quot;./dataset1&quot;</span>,<br>                                         train=<span class="hljs-literal">False</span>,<br>                                         transform=torchvision.transforms.ToTensor(),<br>                                         download=<span class="hljs-literal">True</span>)<br><span class="hljs-comment"># 长度</span><br>train_data_size = <span class="hljs-built_in">len</span>(train_data)<br>test_data_size = <span class="hljs-built_in">len</span>(test_data)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;训练数据集的长度为:&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(train_data_size))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;测试数据集的长度为:&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(test_data_size))<br><br><span class="hljs-comment"># 利用DataLoader加载数据集</span><br>train_dataloader = DataLoader(train_data, batch_size=<span class="hljs-number">64</span>)<br>test_dataloader = DataLoader(test_data, batch_size=<span class="hljs-number">64</span>)<br><br><span class="hljs-comment"># 创建网络模型</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Tudui</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>(Tudui, self).__init__()<br>        self.model = Sequential(<br>            Conv2d(<span class="hljs-number">3</span>, <span class="hljs-number">32</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, padding=<span class="hljs-number">2</span>),<br>            MaxPool2d(<span class="hljs-number">2</span>),<br>            Conv2d(<span class="hljs-number">32</span>, <span class="hljs-number">32</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, padding=<span class="hljs-number">2</span>),<br>            MaxPool2d(<span class="hljs-number">2</span>),<br>            Conv2d(<span class="hljs-number">32</span>, <span class="hljs-number">64</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, padding=<span class="hljs-number">2</span>),<br>            MaxPool2d(<span class="hljs-number">2</span>),<br>            Flatten(),<br>            Linear(<span class="hljs-number">1024</span>, <span class="hljs-number">64</span>),<br>            Linear(<span class="hljs-number">64</span>, <span class="hljs-number">10</span>)<br>        )<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):<br>        x = self.model(x)<br>        <span class="hljs-keyword">return</span> x<br><br><br>tudui = Tudui()<br>tudui = tudui.cuda()<br><br><span class="hljs-comment"># 损失函数</span><br>loss_fn = nn.CrossEntropyLoss()<br>loss_fn = loss_fn.cuda()<br><br><span class="hljs-comment"># 优化器</span><br>learning_rate = <span class="hljs-number">1e-2</span><br>optimizer = torch.optim.SGD(tudui.parameters(), lr=learning_rate)<br><br><span class="hljs-comment"># 设置训练网络的一些参数</span><br><span class="hljs-comment"># 记录训练的次数</span><br>total_train_step = <span class="hljs-number">0</span><br><span class="hljs-comment"># 记录测试的次数</span><br>total_test_step = <span class="hljs-number">0</span><br><span class="hljs-comment"># 训练的轮数</span><br>epoch = <span class="hljs-number">20</span><br><br><span class="hljs-comment"># 添加tensorboard</span><br>writer = SummaryWriter(<span class="hljs-string">&quot;./logs_train&quot;</span>)<br>start_time = time.time()<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(epoch):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;-----第 &#123;&#125; 轮训练开始-----&quot;</span>.<span class="hljs-built_in">format</span>(i+<span class="hljs-number">1</span>))<br><br>    <span class="hljs-comment"># 训练步骤开始</span><br>    tudui.train()<br>    <span class="hljs-keyword">for</span> data <span class="hljs-keyword">in</span> train_dataloader:<br>        imgs, targets = data<br>        imgs = imgs.cuda()<br>        targets = targets.cuda()<br>        outputs = tudui(imgs)<br>        loss = loss_fn(outputs, targets)<br><br>        optimizer.zero_grad()<br>        loss.backward()<br>        optimizer.step()<br><br>        total_train_step = total_train_step + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> total_train_step % <span class="hljs-number">100</span> == <span class="hljs-number">0</span>:<br>            end_time = time.time()<br>            <span class="hljs-built_in">print</span>(end_time - start_time)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;训练次数：&#123;&#125;, Loss: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(total_train_step, loss.item()))<br>            writer.add_scalar(<span class="hljs-string">&quot;train_loss&quot;</span>, loss.item(), total_train_step)<br><br>    <span class="hljs-comment"># 测试步骤开始</span><br>    tudui.<span class="hljs-built_in">eval</span>()<br>    total_test_loss = <span class="hljs-number">0</span><br>    total_accuracy = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">with</span> torch.no_grad():<br>        <span class="hljs-keyword">for</span> data <span class="hljs-keyword">in</span> test_dataloader:<br>            imgs, targets = data<br>            imgs = imgs.cuda()<br>            targets = targets.cuda()<br>            outputs = tudui(imgs)<br>            loss = loss_fn(outputs, targets)<br>            total_test_loss += loss.item()<br>            accuracy = (outputs.argmax(<span class="hljs-number">1</span>) == targets).<span class="hljs-built_in">sum</span>()<br>            total_accuracy += accuracy<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;整体测试集上的Loss: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(total_test_loss))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;整体测试集上的正确率: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(total_accuracy/test_data_size))<br>    writer.add_scalar(<span class="hljs-string">&quot;test_loss&quot;</span>, total_test_loss, total_test_step)<br>    writer.add_scalar(<span class="hljs-string">&quot;test_accuracy&quot;</span>, total_accuracy/test_data_size, total_test_step)<br>    total_test_step += <span class="hljs-number">1</span><br><br>    torch.save(tudui, <span class="hljs-string">&quot;models/tudui_&#123;&#125;.pth&quot;</span>.<span class="hljs-built_in">format</span>(i))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;模型已保存&quot;</span>)<br><br>writer.close()<br><br></code></pre></td></tr></table></figure><p>方法2 <code>device = torch.device(&quot;cuda&quot; if torch.cuda.is_available() else &quot;cpu&quot;)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torchvision<br><span class="hljs-keyword">from</span> torch <span class="hljs-keyword">import</span> nn<br><span class="hljs-keyword">from</span> torch.nn <span class="hljs-keyword">import</span> Sequential, Conv2d, MaxPool2d, Flatten, Linear<br><span class="hljs-keyword">from</span> torch.utils.tensorboard <span class="hljs-keyword">import</span> SummaryWriter<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> torch.utils.data <span class="hljs-keyword">import</span> DataLoader<br><br><span class="hljs-comment"># 定义设备</span><br>device = torch.device(<span class="hljs-string">&quot;cuda&quot;</span> <span class="hljs-keyword">if</span> torch.cuda.is_available() <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;cpu&quot;</span>)<br><span class="hljs-built_in">print</span>(device)<br><br><span class="hljs-comment"># 准备数据集</span><br>train_data = torchvision.datasets.CIFAR10(root=<span class="hljs-string">&quot;./dataset1&quot;</span>,<br>                                          train=<span class="hljs-literal">True</span>,<br>                                          transform=torchvision.transforms.ToTensor(),<br>                                          download=<span class="hljs-literal">True</span>)<br>test_data = torchvision.datasets.CIFAR10(root=<span class="hljs-string">&quot;./dataset1&quot;</span>,<br>                                         train=<span class="hljs-literal">False</span>,<br>                                         transform=torchvision.transforms.ToTensor(),<br>                                         download=<span class="hljs-literal">True</span>)<br><span class="hljs-comment"># 长度</span><br>train_data_size = <span class="hljs-built_in">len</span>(train_data)<br>test_data_size = <span class="hljs-built_in">len</span>(test_data)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;训练数据集的长度为:&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(train_data_size))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;测试数据集的长度为:&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(test_data_size))<br><br><span class="hljs-comment"># 利用DataLoader加载数据集</span><br>train_dataloader = DataLoader(train_data, batch_size=<span class="hljs-number">64</span>)<br>test_dataloader = DataLoader(test_data, batch_size=<span class="hljs-number">64</span>)<br><br><span class="hljs-comment"># 创建网络模型</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Tudui</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>(Tudui, self).__init__()<br>        self.model = Sequential(<br>            Conv2d(<span class="hljs-number">3</span>, <span class="hljs-number">32</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, padding=<span class="hljs-number">2</span>),<br>            MaxPool2d(<span class="hljs-number">2</span>),<br>            Conv2d(<span class="hljs-number">32</span>, <span class="hljs-number">32</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, padding=<span class="hljs-number">2</span>),<br>            MaxPool2d(<span class="hljs-number">2</span>),<br>            Conv2d(<span class="hljs-number">32</span>, <span class="hljs-number">64</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, padding=<span class="hljs-number">2</span>),<br>            MaxPool2d(<span class="hljs-number">2</span>),<br>            Flatten(),<br>            Linear(<span class="hljs-number">1024</span>, <span class="hljs-number">64</span>),<br>            Linear(<span class="hljs-number">64</span>, <span class="hljs-number">10</span>)<br>        )<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):<br>        x = self.model(x)<br>        <span class="hljs-keyword">return</span> x<br><br><br>tudui = Tudui()<br>tudui = tudui.to(device)<br><br><span class="hljs-comment"># 损失函数</span><br>loss_fn = nn.CrossEntropyLoss()<br>loss_fn = loss_fn.to(device)<br><br><span class="hljs-comment"># 优化器</span><br>learning_rate = <span class="hljs-number">1e-2</span><br>optimizer = torch.optim.SGD(tudui.parameters(), lr=learning_rate)<br><br><span class="hljs-comment"># 设置训练网络的一些参数</span><br><span class="hljs-comment"># 记录训练的次数</span><br>total_train_step = <span class="hljs-number">0</span><br><span class="hljs-comment"># 记录测试的次数</span><br>total_test_step = <span class="hljs-number">0</span><br><span class="hljs-comment"># 训练的轮数</span><br>epoch = <span class="hljs-number">20</span><br><br><span class="hljs-comment"># 添加tensorboard</span><br>writer = SummaryWriter(<span class="hljs-string">&quot;./logs_train&quot;</span>)<br>start_time = time.time()<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(epoch):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;-----第 &#123;&#125; 轮训练开始-----&quot;</span>.<span class="hljs-built_in">format</span>(i+<span class="hljs-number">1</span>))<br><br>    <span class="hljs-comment"># 训练步骤开始</span><br>    tudui.train()<br>    <span class="hljs-keyword">for</span> data <span class="hljs-keyword">in</span> train_dataloader:<br>        imgs, targets = data<br>        imgs = imgs.to(device)<br>        targets = targets.to(device)<br>        outputs = tudui(imgs)<br>        loss = loss_fn(outputs, targets)<br><br>        optimizer.zero_grad()<br>        loss.backward()<br>        optimizer.step()<br><br>        total_train_step = total_train_step + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> total_train_step % <span class="hljs-number">100</span> == <span class="hljs-number">0</span>:<br>            end_time = time.time()<br>            <span class="hljs-built_in">print</span>(end_time - start_time)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;训练次数：&#123;&#125;, Loss: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(total_train_step, loss.item()))<br>            writer.add_scalar(<span class="hljs-string">&quot;train_loss&quot;</span>, loss.item(), total_train_step)<br><br>    <span class="hljs-comment"># 测试步骤开始</span><br>    tudui.<span class="hljs-built_in">eval</span>()<br>    total_test_loss = <span class="hljs-number">0</span><br>    total_accuracy = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">with</span> torch.no_grad():<br>        <span class="hljs-keyword">for</span> data <span class="hljs-keyword">in</span> test_dataloader:<br>            imgs, targets = data<br>            imgs = imgs.to(device)<br>            targets = targets.to(device)<br>            outputs = tudui(imgs)<br>            loss = loss_fn(outputs, targets)<br>            total_test_loss += loss.item()<br>            accuracy = (outputs.argmax(<span class="hljs-number">1</span>) == targets).<span class="hljs-built_in">sum</span>()<br>            total_accuracy += accuracy<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;整体测试集上的Loss: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(total_test_loss))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;整体测试集上的正确率: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(total_accuracy/test_data_size))<br>    writer.add_scalar(<span class="hljs-string">&quot;test_loss&quot;</span>, total_test_loss, total_test_step)<br>    writer.add_scalar(<span class="hljs-string">&quot;test_accuracy&quot;</span>, total_accuracy/test_data_size, total_test_step)<br>    total_test_step += <span class="hljs-number">1</span><br><br>    torch.save(tudui, <span class="hljs-string">&quot;models/tudui_&#123;&#125;.pth&quot;</span>.<span class="hljs-built_in">format</span>(i))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;模型已保存&quot;</span>)<br><br>writer.close()<br><br></code></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torchvision<br><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<br><span class="hljs-keyword">from</span> torch <span class="hljs-keyword">import</span> nn<br><span class="hljs-keyword">from</span> torch.nn <span class="hljs-keyword">import</span> Sequential, Conv2d, MaxPool2d, Flatten, Linear<br><br><span class="hljs-comment"># 使用GPU</span><br>device = torch.device(<span class="hljs-string">&quot;cuda&quot;</span> <span class="hljs-keyword">if</span> torch.cuda.is_available() <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;cpu&quot;</span>)<br><br>img_path = <span class="hljs-string">&quot;./imgs/img.png&quot;</span><br>image = Image.<span class="hljs-built_in">open</span>(img_path)<br><span class="hljs-built_in">print</span>(image)<br><br>transform = torchvision.transforms.Compose([torchvision.transforms.Resize((<span class="hljs-number">32</span>, <span class="hljs-number">32</span>)),<br>                                            torchvision.transforms.ToTensor()])<br>image = transform(image)<br><span class="hljs-built_in">print</span>(image.shape)<br><br><span class="hljs-comment"># 创建网络模型</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Tudui</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>(Tudui, self).__init__()<br>        self.model = Sequential(<br>            Conv2d(<span class="hljs-number">3</span>, <span class="hljs-number">32</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, padding=<span class="hljs-number">2</span>),<br>            MaxPool2d(<span class="hljs-number">2</span>),<br>            Conv2d(<span class="hljs-number">32</span>, <span class="hljs-number">32</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, padding=<span class="hljs-number">2</span>),<br>            MaxPool2d(<span class="hljs-number">2</span>),<br>            Conv2d(<span class="hljs-number">32</span>, <span class="hljs-number">64</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, padding=<span class="hljs-number">2</span>),<br>            MaxPool2d(<span class="hljs-number">2</span>),<br>            Flatten(),<br>            Linear(<span class="hljs-number">1024</span>, <span class="hljs-number">64</span>),<br>            Linear(<span class="hljs-number">64</span>, <span class="hljs-number">10</span>)<br>        )<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):<br>        x = self.model(x)<br>        <span class="hljs-keyword">return</span> x<br><br><br>model = torch.load(<span class="hljs-string">&quot;models/tudui_19.pth&quot;</span>, map_location=torch.device(<span class="hljs-string">&#x27;cpu&#x27;</span>))<br>image = torch.reshape(image, (<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">32</span>, <span class="hljs-number">32</span>))<br><br>model.<span class="hljs-built_in">eval</span>()<br><span class="hljs-keyword">with</span> torch.no_grad():<br>    output = model(image)<br><span class="hljs-built_in">print</span>(output)<br><br><span class="hljs-built_in">print</span>(output.argmax(<span class="hljs-number">1</span>))<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Pytorch</tag>
      
      <tag>深度学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HUST-SE软件体系结构复习</title>
    <link href="/2024/10/22/HUST-SE%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0/"/>
    <url>/2024/10/22/HUST-SE%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="软件体系结构复习"><a href="#软件体系结构复习" class="headerlink" title="软件体系结构复习"></a>软件体系结构复习</h1><h2 id="1-认识体系结构"><a href="#1-认识体系结构" class="headerlink" title="1.认识体系结构"></a>1.认识体系结构</h2><p>体系结构简称架构或构架。</p><p><strong>Architecture和Structure有什么不同？</strong></p><p> 结构(structure)：从某个角度（视角）对组成整体的各部分的搭配和安排。构架（architecture）：建筑的结构的集合，形成设计整体。</p><p>architecture &#x3D; structures</p><p><strong>Safety和Security有什么不同？</strong></p><p>security”它有一些目的性，我故意要给你找点麻烦。“safety”是谁也不愿意让它发生但是它发生了，谁都不愿意，你也不愿意，我也不愿意，监管者也不愿意。比如，汽车安全带叫“safety belt”，没人希望车祸发生。我们在机场进行不叫“safety check”，叫“security check”，为什么叫security check？因为他针对那些有特殊目的，有恶意要干坏事情的人。</p><p><strong>为什么研究软件架构?</strong><br>思想有多远，我们就能走多远<br>高度决定思路，思路决定出路</p><p>系统的建立是为了满足组织的需求（包括功能和质量），质量需求决定了系统必须达到的特征, 包括性能, 可靠性, 互操作性以及生命周期等。随着软件系统的日益复杂，涉众对软件的要求已不局限于功能上的满足，而是更加注重质量。<br>       很少有人注意到组织（开发组织、客户等）在系统设计和系统成败上扮演的角色。<br>       系统的质量特征受到软件架构的限制，或者说构架设计的选择受到要达到的质量特征的影响。</p><h3 id="1-1-软件架构基础"><a href="#1-1-软件架构基础" class="headerlink" title="1.1 软件架构基础"></a>1.1 软件架构基础</h3><p>软件架构—在一定的设计原则基础上，从不同角度对组成系统的各部分进行搭配和安排，形成系统的多个结构而组成架构，它包括该系统的各个组件、组件的外部可见属性及组件之间的相互关系。<br>组件的外部可见属性是指其它组件可对该组件所做的假设，如该组件提供的服务、具备的质量特征、错误处理、共享资源的使用。</p><p><strong>为什么设计原则是架构的一部分？</strong></p><p>不遵循架构设计的原则，架构也容易失败</p><p>架构定义可以从下面六个方面来理解：</p><ul><li>架构应建立在一定的设计原则之上，否则很容易失败。</li><li>架构由多个结构组成，其中任何一个结构都不能与构架等同。</li><li>每个软件系统都有自己的架构。</li><li>软件架构决定了各个组件。</li><li>只要某个组件的行为可以从其它组件的角度观察到或区别开，这样的行为就是软件架构的内容。</li><li>软件架构是抽象的，它不考虑实现、算法和数据表示的细节，而集中研究“黑盒”组件的行为和交互，是设计第一步。</li></ul><h3 id="1-2-软件架构的多个结构"><a href="#1-2-软件架构的多个结构" class="headerlink" title="1.2 软件架构的多个结构"></a>1.2 软件架构的多个结构</h3><p>静态的角度：</p><ol><li><strong>模块结构</strong>—体现了任务的划分，每个模块有其接口描述、代码和测试计划等，各模块通过父子关系联系起来，在开发和维护阶段用于分配任务和资源。</li><li><strong>分析类结构</strong>—子系统图、包图。</li><li><strong>类结构</strong>—对象之间的继承或实例关系。</li></ol><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241020122447814.png" alt="image-20241020122447814"></p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241020122507186.png" alt="image-20241020122507186"></p><p>动态的角度：</p><ol><li><strong>进程结构</strong>—运行系统的动态特征，包括进程间的同步关系、缺少不能运行、存在不能运行、先后等关系，与模块结构、概念结构成垂直正交关系。</li><li><strong>数据流</strong>—模块之间可能发送数据的关系，最适合用于系统需求的追踪</li><li><strong>控制流</strong>—程序、模块或系统状态之间的“之后激活”的关系，适合于对系统功能行为和时序关系的验证。</li><li><strong>使用结构</strong>—描述过程或模块之间的联系，这种联系是“假设正确存在”的关系，用于设计可轻松扩展的系统。如果过程A的运行必须以过程B的正确运行为前提，则说过程A使用过程B。</li><li><strong>调用结构</strong>–（子）过程之间调用和被调用的关系，可用来跟踪系统的执行过程</li><li><strong>层次结构</strong>—是一种特殊的使用结构，层就是相关功能的一致集合，在严格的分层结构中，第n层仅能使用第n-1层提供的服务。</li></ol><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241020122642687.png" alt="image-20241020122642687"></p><p>使用结构</p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241020122701980.png" alt="image-20241020122701980"></p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241020122708802.png" alt="image-20241020122708802"></p><p>层次结构</p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241020122733078.png" alt="image-20241020122733078"></p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241020122744515.png" alt="image-20241020122744515"></p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241020122801331.png" alt="image-20241020122801331"></p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241020122813498.png" alt="image-20241020122813498"></p><p>部署的角度：<br><strong>物理结构</strong>—软件与硬件之间的映射关系，在分布式或并行系统中有重要意义。</p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241020122830395.png" alt="image-20241020122830395"></p><p>各种结构间的相互关系</p><ol><li>各个结构都是从不同角度考察系统，但它们并不完全独立，它们之间的联系是多对多的。</li><li>每个项目在开发时一般是注重一个结构，按照这一主要结构来考虑和运用其它结构。</li><li>经验表明，系统规模越大，这些结构之间的差异越明显。</li><li>使用结构与调用结构的区别：对于使用结构，<strong>A可以调用B，并且A使用B的结果</strong>，如在ATM机上取款，先要验证余额是否够；或者A使用B的结果，但A不直接调用B，银行结息需要读利率，但不会直接调用利率设置程序。<br>对于调用结构，<strong>A调用B，但A不使用B的结果</strong>，例如虽然网页的某个部分无法显示，但不会影响网页其它内容的显示。</li></ol><h3 id="1-3-架构定义的其他观点"><a href="#1-3-架构定义的其他观点" class="headerlink" title="1.3 架构定义的其他观点"></a>1.3 架构定义的其他观点</h3><p>…</p><p><strong>软件架构是软件系统的总体结构（是否正确？）否</strong></p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241020123008686.png" alt="image-20241020123008686"></p><h3 id="1-4-软件架构的产生"><a href="#1-4-软件架构的产生" class="headerlink" title="1.4 软件架构的产生"></a>1.4 软件架构的产生</h3><p>设计仅是系统功能需求分析的产物？<br>功能需求-设计-系统开发？</p><p><strong>否</strong></p><h4 id="1-4-1-架构受系统涉众的影响"><a href="#1-4-1-架构受系统涉众的影响" class="headerlink" title="1.4.1 架构受系统涉众的影响"></a>1.4.1 架构受系统涉众的影响</h4><p><strong>涉众</strong>—也叫<strong>风险承担者，利益相关者，他们是对构建软件系统感兴趣的人或组织，包括合同中的客户、系统最终用户、开发人员、开发组织、系统维护人员等</strong>，他们所关注的问题各不相同，但都要求系统在他们所关注的方面提供保证或优化。</p><p>事物有主要矛盾和次要矛盾之分。<br>开发系统时，首先要确定其<strong>软件构架</strong>。借助于构架，设计师可以分析众多风险承担者所提出的各种要求的优先级，并将这些要求转化为系统的各个特性，再针对它们在系统结构上做折衷，从而得到和谐的架构。</p><p>开发组织所关心的问题不同于客户，它对软件构架的影响分为3类：<br> · 直接影响<br>   如希望向产品线发展<br>·长远影响<br>  如行业布局<br>·组织结构的影响<br> 如软件外包<br> 开发组织的开发团队的经验对设计师有影响，从而间接影响架构</p><h4 id="1-4-2-架构受设计师的素质和经验的影响"><a href="#1-4-2-架构受设计师的素质和经验的影响" class="headerlink" title="1.4.2 架构受设计师的素质和经验的影响"></a>1.4.2 架构受设计师的素质和经验的影响</h4><p>​     1 熟悉.NET的设计师在设计时会考虑.NET的框架和技术。<br>​     2 熟悉J2EE的设计师在设计时会考虑J2EE的框架和技术。<br>​     3 设计师具有数据库方向的背景，系统会被认为是数据库的应用。<br>​     4 设计师具有网络安全的背景，系统的安全会被放在很突出的位置。</p><h4 id="1-4-3-构架受技术环境的影响"><a href="#1-4-3-构架受技术环境的影响" class="headerlink" title="1.4.3 构架受技术环境的影响"></a>1.4.3 构架受技术环境的影响</h4><p>​      例如：现在AI很流行，设计师在设计时往往首先考虑系统能否结合AI运行。</p><h4 id="1-4-4-设计师的沟通能力"><a href="#1-4-4-设计师的沟通能力" class="headerlink" title="1.4.4 设计师的沟通能力"></a>1.4.4 设计师的沟通能力</h4><p>设计师的沟通能力从下面三点体现：<br>1 多看别人的长处，这样才能屈身理解涉众要求。</p><p>2 姿态放低一点</p><p>3 设计师还要会讲故事</p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241020154412697.png" alt="image-20241020154412697"></p><h3 id="1-5-软件的架构不是静止的"><a href="#1-5-软件的架构不是静止的" class="headerlink" title="1.5 软件的架构不是静止的"></a>1.5 软件的架构不是静止的</h3><ol><li>软件在开发过程中或交付使用后，都可能会发生修改，这些修改往往涉及到架构的变更。因此软件版本的演进也是软件架构的演进。 </li><li>软件架构影响设计师的经验。</li><li>软件架构影响开发组织的内部结构和经营目标。</li><li>软件架构可能会影响客户对下个系统的需求</li><li>有些系统甚至会影响并实际改变软件工程的发展，以及开发人员学习和实践的技术环境，如互联网、嵌入式、手机等。</li></ol><p><strong>架构商业周期</strong>—架构是软件开发的必经之路和必要手段，它受到来自客户和开发组织的影响，也受到设计师的素质和经验以及技术环境的影响；反过来，构架也影响着被开发的系统，对客户、开发组织、构架和技术环境也都有影响，还影响着客户及其开发组织的未来目标。围绕着构架的这些影响和反馈循环构成构架商业周期。</p><h3 id="1-6-软件架构的重要性"><a href="#1-6-软件架构的重要性" class="headerlink" title="1.6 软件架构的重要性"></a>1.6 软件架构的重要性</h3><ol><li>风险承担者之间的交流平台</li><li>早期设计决策的体现</li><li>有助于实现构架级重用</li></ol><h3 id="1-7-小结"><a href="#1-7-小结" class="headerlink" title="1.7 小结"></a>1.7 小结</h3><p><strong>构架不只是功能需求的结果。</strong></p><h3 id="1-8-讨论"><a href="#1-8-讨论" class="headerlink" title="1.8 讨论"></a>1.8 讨论</h3><p>谈<strong>软件架构与建筑架构的联系与区别</strong></p><p>软件架构（Software Architecture）是指软件系统的基本<a href="https://so.csdn.net/so/search?q=%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86&spm=1001.2101.3001.7020">组成部分</a>、它们之间的关系和原则，以及这些元素是如何协同工作以完成系统功能的决策。软件架构描述了软件系统的整体结构、行为和属性，为软件开发提供了一个高层次的视角。</p><p>建筑物架构（Building Architecture）是指建筑物的形态、结构、空间安排、材料和技术等因素的整体规划和设计。建筑物架构描述了建筑物的外观、内部布局、功能和风格，为建筑设计和建造提供了一个高层次的视角。</p><p>模块化： 软件架构和建筑物架构都采用模块化的方法，将复杂系统分解</p><h2 id="2-质量属性"><a href="#2-质量属性" class="headerlink" title="2. 质量属性"></a>2. 质量属性</h2><h3 id="2-1-需求分析与架构的关系"><a href="#2-1-需求分析与架构的关系" class="headerlink" title="2.1 需求分析与架构的关系"></a>2.1 需求分析与架构的关系</h3><p>需求包括三要素：<br>        • 功能<br>        • 质量<br>        • 限制条件</p><p>需求是架构设计的基础，但在需求阶段是无法弄清全部需求的，因此需求和架构设计之间的迭代是必要和有意义的。</p><h3 id="2-2-功能和架构的关系"><a href="#2-2-功能和架构的关系" class="headerlink" title="2.2 功能和架构的关系"></a>2.2 功能和架构的关系</h3><p>功能<br><strong>功能是指系统所能完成的工作。</strong><br>功能是构架设计的必要条件而非充分条件，因为不同架构具有相同的功能，它们的差别在于质量。</p><p>随着软件开发水平的提高，如何满足功能已不是软件开发的主要矛盾，也不是构架层次上主要考虑的问题，构架设计主要考虑如何满足质量上的要求，但软件构架会限制各模块的功能划分，功能对架构设计有间接的影响。</p><h3 id="2-3-架构和质量属性的关系"><a href="#2-3-架构和质量属性的关系" class="headerlink" title="2.3 架构和质量属性的关系"></a>2.3 架构和质量属性的关系</h3><p><strong>质量属性—系统在其生命周期过程中所表现出的各种特征</strong>。</p><ol><li>架构和质量属性的关系：<br>    • <strong>架构是获取许多质量属性的基础</strong>（上梁不正下梁歪）<br>    在架构设计过程中就应考虑到这些质量属性，并在架构层次上进行评估。<br>    • <strong>质量属性既和架构有关，也和具体实现有关</strong>。<br>    例如，系统设计时一般都会考虑设置密码来提供安全性，可是如果实现时SQL语句没写好，则可能被注入攻击。</li><li>质量属性之间的关系：<br>    • <strong>一个质量属性的获取对其他质量属性可能产生正面或负面的影响</strong>。<br>    • <strong>任何质量属性都不可能在不考虑其他属性情况下单独获取</strong></li><li>质量属性可以分为两类：<br>    • <strong>运行时可见属性</strong><br>      包括：<strong>可用性、性能、安全性、易用性</strong><br>    • <strong>维护时可见属性</strong><br>      包括：<strong>可修改性、可扩展性、可移植性、可集成性</strong></li><li>质量属性的场景描述法<br>    传统关于质量属性的讨论中存在问题：<br>    • <strong>定义不具可操作性</strong><br>    • <strong>可能会关注同一问题</strong><br>    可用性、易用性和安全性都可能关心一个系统故障</li></ol><p> <strong>质量属性场景</strong>就是通过对某个实体与系统的一次交互的简要描述说明一个有关质量属性的特定需求，它由六部分组成：<br>        • <strong>刺激源</strong>：可以是风险承担者、计算机系统等。<br>        • <strong>刺激</strong>：可以看作是一个事件。<br>        • <strong>环境</strong>：系统当前的状态。<br>        • <strong>制品</strong>：系统中对事件作出反应的部分，可以是整个系统或系统的某一部分。<br>        • <strong>反应</strong>：事件到达后系统的相关行为。<br>        • <strong>反应度量</strong>：对反应结果提供某种形式的衡量。</p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241020155709196.png" alt="image-20241020155709196"></p><p> 质量属性不是处于隔离状态，只有在一定的上下文环境中才能做出有意义的评判。生成质量属性场景的<strong>目的和意义</strong>：<br>         • 帮助构架师生成有意义的质量属性需求。<br>         • 使质量属性需求的描述规范化。<br>         •  某一场景是一类场景的代表，系统将以完全相同的方式对这些场景做出反应。</p><p>质量场景创建的参与人员：<br>      · 负责软件执行的人员—<strong>最终用户</strong><br>      · 负责管理系统的人员—<strong>系统管理员</strong><br>      · 负责更改系统运行时功能的人员—<strong>维护人员</strong><br>      · 负责系统规划的单位—<strong>客户</strong><br>      · 负责项目实施的单位—<strong>开发组织</strong></p><h3 id="2-4-质量属性及其场景描述"><a href="#2-4-质量属性及其场景描述" class="headerlink" title="2.4 质量属性及其场景描述"></a>2.4 质量属性及其场景描述</h3><p><strong>可用性(Availability)<strong>是指</strong>系统正常运行时间的比例</strong>，是通过两次故障之间的时间长度或在系统崩溃情况下能够恢复正常运行的速度来衡量的。</p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241020155827712.png" alt="image-20241020155827712"></p><p> <strong>可靠性(Reliability)<strong>是指</strong>系统能够保持正常运行的能力</strong>，通常用平均无故障工作时间来衡量。可靠性和可用性都与构架密切相关。</p><p>日常生活中，洗衣机、电冰箱等是用<strong>无故障工作时间</strong>来衡量。但对故障修复时间要求很短的系统，则常用<strong>可用性</strong>来衡量，如银行、证券和航天飞行等系统。</p><p><strong>平均正常工作时间的加长</strong>是设计不易出错的系统，即在构架层次上把相关部分分离而实现。<br> <strong>平均（脱机）修复时间的缩短</strong>主要通过设计容错性较好的构架来实现，也就是通过在构架中重复设置关键处理单元及其之间的通讯信道而实现，这是通过快速确定故障症结并快速替换故障组件来实现的。因此要设计易于更改的组件、易于确定故障症结的组件。<br>下面是银行曾经使用过的双机热备份的例子。</p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241020162524531.png" alt="image-20241020162524531"></p><p><strong>可用性针对的是过错(fault)而不是失败(failure)</strong> 。</p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241020162710933.png" alt="image-20241020162710933"><strong>可修改性</strong><br>      可修改性是<strong>进行快速修改并使修改代价尽可能低的能力</strong>，这种能力直接受到构架的限制。<br>      可修改性主要是所做修改的局部性的函数。<br>      构架决定了各个组件及其职责，因此也定义了各个组件需要修改时所处的状态，这些修改可以分为3类：<br>          § 涉及一个组件的修改<br>          § 涉及几个组件的修改<br>          § 涉及整个构架的修改</p><p>对系统的更改一般是由于拥有该系统的组织的商业目的发生了变化，这些变化包括:<br>          § 功能的扩展或改变<br>          § 删除不需要的功能<br>          § 适应新的操作环境<br>          § 结构的重新调整<br>可修改性有时也称做<strong>可维护性</strong>。</p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241020162900085.png" alt="image-20241020162900085"></p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241020162938646.png" alt="image-20241020162938646"></p><p><strong>可重用性</strong><br>        可重用性是指<strong>要合理地设计系统，使系统的结构或其某些组件能够在以后的应用开发中重复使用。</strong><br>        构架的各个组件就是重用的单位，一个组件的可重用程度依赖于它与其它组件的耦合程度。<br>        Java API的应用就是复用的一个典型例子，Java API就是可复用的类集合。<br>        可重用性与构架密切相关，它还可以看作是可修改性或可集成性的特例。这相当于一个硬币的两面：建立的系统可修改导致了系统可重用。 </p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241020163045953.png" alt="image-20241020163045953"></p><p><strong>类的复用</strong></p><ul><li>对于一个已经设计好的类，可以使用继承、聚合、依赖等技术实现复用。</li><li>具体说，将新创建类直接说明为已经设计好的类（父类）的子类，通过继承和修改父类的属性与行为完成新创建类的定义；</li><li>或者，在新创建类中引进已经设计好的类的对象作为新创建类的成员变量，然后在新创建类中通过成员变量复用已经设计好的类的属性和方法；</li><li>或者，在新创建类中引进已经设计好的类的对象，作为新创建类中的方法的参数或返回类型。</li></ul><p><strong>性能</strong><br>        性能是指<strong>系统的响应能力—即对外部刺激（事件）做出反应时所需要的时间或在某段时间内所处理的事件个数。</strong><br>        在硬件条件一定的情况下，性能通常是系统中各组件间进行通信或交互的次数与数据量的函数，如函数之间的调用，参数的传递等。因此，性能与构架密切相关。<br>        我们可以通过观察服务请求的到达速率、处理时间、队列大小和延迟时间长短等指标了解系统性能。<br>        我们可以根据预计的工作负载，通过构建系统的随机队列模型来模拟该系统的性能并进行分析。</p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241020163514548.png" alt="image-20241020163514548"></p><p><strong>安全性</strong><br>        安全性是<strong>衡量系统在向合法用户正常提供服务的情况下，阻止非授权使用和抗拒拒绝服务攻击的能力</strong>。<br>        系统受到的威胁有多种，例如：<br>        § 拒绝服务<br>        § IP源地址欺骗<br>        下面场景表现了病毒攻击上网计算机时系统的安全性。</p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241020164540113.png" alt="image-20241020164540113"></p><p><strong>易用性</strong><br>    易用性可分为如下几个方面：<br>         § 可学习性<br>         § 可记忆性<br>         § 错误避免<br>         § 错误处理<br>         § 满意度<br>         易用性与构架是密不可分的。</p><p> <strong>可移植性</strong><br>       可移植性是<strong>系统能够在不同计算环境下运行的能力</strong>。这里所说的环境可能是硬件、软件或两者的组合。<br>       如果对任何特定计算环境的所有假设都仅包含在一个或几个组件中，那么就说该系统是可移植的。<br>       在构架中对与平台相关问题的封装常采用一个可移植层，它是一组软件服务的集合，使上层应用软件与其环境具有抽象接口，并且在移植时接口不变。<br>       可移植层是信息隐藏原则运用的结果。<br>       <strong>采用可移植层的缺陷是什么？ 可能不能发挥特定系统的最大效率！</strong></p><p><strong>可集成性（integrability）</strong><br>       可集成性是<strong>使独立开发的系统组件能够协同运行的能力</strong>，集成性依赖与：<br>       § 组件的外部复杂性<br>       § 组件之间的交互机制和协议<br>       § 组件功能划分的清晰程度<br>       § 组件接口的定义是否完整、合理<br>        可集成性表明了一个系统内个组件之间相互协作的能力，而互操作性（interoperability）衡量的则是一个系统与另一个系统的协作能力。</p><h3 id="2-5-限制条件"><a href="#2-5-限制条件" class="headerlink" title="2.5 限制条件"></a>2.5 限制条件</h3><p>限制条件包括商业限制、技术限制、法律限制、社会限制等。限制条件会对系统架构产生直接影响，也会对系统功能和质量产生影响。从而间接影响架构。</p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241020164803149.png" alt="image-20241020164803149"></p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241020164818269.png" alt="image-20241020164818269"></p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241020164828094.png" alt="image-20241020164828094"></p><h3 id="2-6-架构本身的质量属性"><a href="#2-6-架构本身的质量属性" class="headerlink" title="2.6 架构本身的质量属性"></a>2.6 架构本身的质量属性</h3><p><strong>• 一致性</strong></p><p>构架应该以类似的方式做类似的事情。     </p><p>迈向一致性的最重要一步是有一个系统构架师。     </p><p><strong>• 正确性和完整性</strong></p><p>构架能够满足系统的各种需求及运行时的资源要求。</p><p><strong>• 可构建性</strong>     </p><p>保证能够由指定的开发小组完成。</p><h2 id="3-软件架构的样式（风格）与框架"><a href="#3-软件架构的样式（风格）与框架" class="headerlink" title="3. 软件架构的样式（风格）与框架"></a>3. 软件架构的样式（风格）与框架</h2><h3 id="3-1-软件架构样式的概念"><a href="#3-1-软件架构样式的概念" class="headerlink" title="3.1 软件架构样式的概念"></a>3.1 软件架构样式的概念</h3><p><strong>构架样式（风格）</strong>—是<strong>对各组件类型和运行控制&#x2F;数据传送模式的描述</strong>。可以把构架样式看作是对构架的一组制约条件，即对各组件类型及其交互模式的限制条件，而这些制约条件就确定了一组或一系列能满足它们的构架。<br>可以从四个方面理解构架样式：</p><ul><li><p>一组在系统运行时执行一定功能的组件类型。</p></li><li><p>能够表明在系统运行时组件的相互关系的拓扑结构。</p></li><li><p>一组语义约束条件的集合。</p></li><li><p>一组连接件的集合，这些连接件为组件之间的通信提供中介。</p></li></ul><p>构架样式是预先定义好的，稍加修改即可在给定环境下使用的“组块”，样式代表了一组已经做出并可重用的设计决策，而且这些决策构成了一个整体。<br>样式对系统功能的要求总是模糊的，出现的形式经常变化。</p><h3 id="3-2-软件架构样式的种类"><a href="#3-2-软件架构样式的种类" class="headerlink" title="3.2 软件架构样式的种类"></a>3.2 软件架构样式的种类</h3><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241020171654470.png" alt="image-20241020171654470"></p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241020171707459.png" alt="image-20241020171707459"></p><p>以数据为中心的构架样式为我们提供了一个解决可集成性问题的结构解决方案。这种方式的优点是<strong>客户端相对独立</strong>，缺点是<strong>数据中心的性能要高，响应速度要快，并且要有灾难备份</strong>等。</p><p><strong>数据流样式</strong><br>        数据流构架的目标是实现可重用性和可更改性，它的特点是把系统看作是对相继输入数据的一系列变换。它可分成两个子样式：</p><ul><li><strong>批处理（成批顺序式）</strong>—等到一个步骤全部处理完后才能开始下一个步骤，每个处理步骤（组件）是独立的程序，在各个步骤之间，数据是作为一个整体传送的，如传统的磁带处理。</li><li><strong>管道—过滤式</strong><br>    管道负责数据传递，过滤器对数据进行渐进的转换。如UNIX系统中可以用此方法来过滤文件中一些不需要的字符。</li></ul><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241020171824786.png" alt="image-20241020171824786"></p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241020171832431.png" alt="image-20241020171832431"></p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241020171954191.png" alt="image-20241020171954191"></p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241020172007476.png" alt="image-20241020172007476"></p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241020172019550.png" alt="image-20241020172019550"></p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241020172030473.png" alt="image-20241020172030473"></p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241020172043932.png" alt="image-20241020172043932"></p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241020172052344.png" alt="image-20241020172052344"></p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241020172101278.png" alt="image-20241020172101278"></p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241020172110734.png" alt="image-20241020172110734"></p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241020172119002.png" alt="image-20241020172119002"></p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241020172128594.png" alt="image-20241020172128594"></p><p>  <strong>• 虚拟机样式</strong><br>        虚拟机构架的目标是实现可移植性。虚拟机是模拟硬件功能或抽象软件环境的构架样式。<br>        虚拟机构架常见的示例有解释程序、基于规则的系统、句法shell程序、命令语言处理器等。</p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241020172241586.png" alt="image-20241020172241586"></p><p>​    <strong>• 调用–返回风格</strong><br>​        调用返回风格一直是大型软件系统的主流构架样式，它的目标是实现系统的可更改性和可扩展性。它有多种子样式：</p><ul><li>主程序-子程序风格​        </li><li>远过程调用风格​        </li><li>面向对象风格​        </li><li>分层风格</li></ul><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241020172312968.png" alt="image-20241020172312968"></p><p>含有参数的子程序的一般调用过程如下。<br>按从右到左的顺序，计算实参各表达式的值；<br>按照位置，将实参的值一一传给形参；<br>执行被调用函数（子程序）；<br>当遇到return(表达式)语句时，计算表达式的值，并返回主调函数（主程序）。 </p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241020172336500.png" alt="image-20241020172336500"></p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241020172346782.png" alt="image-20241020172346782"></p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241020172356685.png" alt="image-20241020172356685"></p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241020172405273.png" alt="image-20241020172405273"></p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241020172417735.png" alt="image-20241020172417735"></p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241020172425665.png" alt="image-20241020172425665"></p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241020172433717.png" alt="image-20241020172433717"></p><p>​     <strong>• 独立组件样式</strong><br>​     独立组件构架由许多通过发送消息进行通讯的独立进程或对象组成，它的目标是通过解除各运算部分之间的耦合实现可更改性，如股票机、各类短信预定等。它有两类子样式：</p><ul><li>事件系统样式​     </li><li>通讯进程样式</li></ul><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241020172452058.png" alt="image-20241020172452058"></p><p>​    <strong>• C&#x2F;S样式及其演变</strong><br>​        C&#x2F;S（Client&#x2F;Server，<strong>客户机&#x2F;服务器</strong>）样式是基于资源不对等，且为实现共享而提出来的，是20世纪90年代成熟起来的技术，C&#x2F;S结构将应用一分为二，服务器（后台）负责数据管理，客户机（前台）完成与用户的交互任务。<br>​        C&#x2F;S 样式具有强大的数据操作和事务处理能力，模型思想简单，易于人们理解和接受。但随着企业规模的日益扩大，软件的复杂程度不断提高，传统的二层C&#x2F;S结构存在以下几个局限：<br>​      （1）<strong>二层C&#x2F;S结构是单一服务器且以局域网为中心的，所以难以扩展至大型企业广域网或Internet；</strong><br>​      （2）<strong>软、硬件的组合及集成能力有限；</strong><br>​      （3）<strong>服务器的负荷太重，难以管理大量的客户机，系统的性能容易变坏；</strong></p><p>​     （4）<strong>数据安全性不好</strong>。因为客户端程序可以直接访问数据库服务器，那么，在客户端计算机上的其他程序也可想办法访问数据库服务器，从而使数据库的安全性受到威胁。<br>​       正是因为二层C&#x2F;S有这么多缺点，因此，三层C&#x2F;S结构应运而生。三层C&#x2F;S结构是将应用功能分成表示层、业务层和数据层三个部分，如图所示。 </p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241020172553817.png" alt="image-20241020172553817"></p><p>​       <strong>表示层</strong>是<strong>应用的用户接口部分，它担负着用户与应用间的对话功能，用于检查用户从键盘等输入的数据，显示应用输出的数据</strong>。为使用户能直观地进行操作，一般要使用图形用户接口，操作简单、易学易用。在变更用户接口时，只需改变显示控制和数据检查程序，而不影响其他两层。检查的内容也只限于数据的形式和取值范围，不包括有关业务本身的处理逻辑。<br>​       <strong>业务层</strong>相当于应用的本体，它是<strong>将具体的业务处理逻辑编入程序中。例如，在制作订购合同时要计算合同金额，按照定好的格式配置数据、打印订购合同，而处理所需的数据则要从表示层或数据层取得</strong>。表示层和业务层之间的数据交往要尽可能简洁。例如，用户检索数据时，要设法将有关检索要求的信息一次性地传送给业务层，而由业务层处理过的检索结果数据也一次性地传送给表示层。<br>​       通常，在业务层中包含有确认用户对应用和数据库存取权限的功能以及记录系统处理日志的功能。</p><p>​       <strong>数据层</strong>主要是数<strong>据库管理系统，负责管理对数据库数据的读写</strong>。数据库管理系统必须能迅速执行大量数据的更新和检索。一般从业务层传送到数据层的要求大都使用SQL语言。<br>​       三层C&#x2F;S的解决方案是：对这三层进行明确分割，并在逻辑上使其独立。原来的数据层作为数据库管理系统已经独立出来，所以，关键是要将表示层和业务层分离成各自独立的程序，并且还要使这两层间的接口简洁明了。<br>​       与传统的二层结构相比，三层C&#x2F;S结构具有以下优点：    　<br>​      （1）<strong>允许合理地划分三层结构的功能，使之在逻辑上保持相对独立性，从而使整个系统的逻辑结构更为清晰，能提高系统的可维护性和可扩展性</strong>。<br>​      （2）<strong>允许更灵活有效地选用相应的软硬件平台，使之在处理能力和处理特性上分别适应于结构清晰的三层；并且这些平台和各个组成部分可以具有良好的可升级性和开放性。</strong></p><p>​      （3）<strong>三层C&#x2F;S结构中，各层可以并行开发，可以选择各自最适合的开发语言，维护也会更容易些。</strong><br>​      （4）<strong>允许充分利用业务层有效地隔离开表示层与数据层，未授权的用户难以绕过业务层而利用数据库工具或黑客手段去非法地访问数据层，这就为严格的安全管理奠定了坚实的基础；整个系统的管理层次也更加合理和可控制。</strong></p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241020172801394.png" alt="image-20241020172801394"></p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241020172930872.png" alt="image-20241020172930872"></p><p>​       C2样式有两方面设计规则。组成规则规定了C2以组件和连接件为基础，每一个组件和连接件都设有一个“顶域”和“底域”；组件的“顶域”与连接件的“底域”相连接；组件的“底域”与连接件的“顶域”相连接；对连接到某一个连接件上的组件数量没有限制，但组件与组件之间不能直接相连。    　<br>​     C2的通信规则规定所有组件间的通信必须通过消息来实现。组件的“顶域”定义了组件可以对哪些通知作出响应，以及可以发出哪些请求；组件的“底域”设置了可以向下层发送哪些通知，以及可以响应下层的哪些请求。每个组件只能感知层次高于自己的组件提供的服务，而不能感知层次低于自己的组件服务 。<br>​     C2构架样式最重要的特征就是“底层无关性”，这在组件的可替代性和可重用性方面具有显著的作用，即使软件组件的语言方式不同，通过一个构架，它们之间也可以方便、快捷地进行交互，这是通过以连接件为中介的异步消息交换机制来实现的。C2样式对于伸缩性的影响是正面的 。 </p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241020172950958.png" alt="image-20241020172950958"></p><p>​         C2样式可以概括为：<strong>通过连接件绑定在一起的按照一组规则运作的并行组件网络</strong>。<br>​         C2样式具有以下特点：<br>​       （1）<strong>系统中的组件可实现应用需求，并能将任意复杂度的功能封装在一起</strong>；<br>​       （2）<strong>所有组件之间的通讯是通过以连接件为中介的异步消息交换机制来实现的</strong>；<br>​       （3）<strong>组件相对独立，组件之间依赖性较少</strong>。系统中不存在某些组件将在同一地址空间内执行，或某些组件共享特定控制线程之类的相关性假设。 </p><p>​    <strong>• 正交样式</strong><br>​        正交样式由<strong>层和线索的组件</strong>构成。层是由一组具有相同抽象级别的组件构成。线索是子系统的特例，它是由完成不同层次功能的组件组成（通过相互调用来关联），每一条线索完成整个系统中相对独立的一部分功能。每一条线索的实现与其他线索的实现无关或关联很少，在同一层中的组件之间是不存在相互调用的。<br>​        如果线索是相互独立的，即不同线索中的组件之间没有相互调用，那么这个结构就是完全正交的。从以上定义，我们可以看出，正交软件体系结构是一种以垂直线索组件族为基础的层次化结构，其基本思想是把应用系统的结构按功能的正交相关性，垂直分割为若干个线索（子系统），线索又分为几个层次，每个线索由多个具有不同层次功能和不同抽象级别的组件构成。各线索的相同层次的组件具有相同的抽象级别。因此，我们可以归纳正交软件体系结构的主要特征如下：  </p><p>​       （1）正交样式由完成不同功能的n（n &gt; 1）个线索（子系统）组成；<br>​       （2）系统具有m（m &gt; 1）个不同抽象级别的层；<br>​       （3）线索之间是相互独立的（正交的）；<br>​       （4）系统有一个公共驱动层（一般为最高层）和公共数据结构（一般为最低层）。<br>​        对于大型的和复杂的软件系统，其子线索（一级子线索）还可以划分为更低一级的子线索（二级子线索），形成多级正交结构。正交软件体系结构的框架如图所示。</p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241020173027518.png" alt="image-20241020173027518"></p><p>​       上图是一个三级线索、五层结构的正交样式框架图，在该图中，ABDFK组成了一条线索，ACEJK也是一条线索。因为B、C处于同一层次中，所以不允许进行互相调用；H、J处于同一层次中，也不允许进行互相调用。一般来讲，第五层是一个物理数据库连接组件或设备组件，供整个系统公用。在软件进化过程中，系统需求会不断发生变化。在正交软件体系结构中，因线索的正交性，每一个需求变动仅影响某一条线索，而不会涉及到其他线索。这样，就把软件需求的变动局部化了，产生的影响也被限制在一定范围内，因此实现容易。<br>​        正交样式具有以下优点：<br>​      （1）<strong>结构清晰，易于理解</strong>。正交软件体系结构的形式有利于理解。由于线索功能相互独立，不进行互相调用，结构简单、清晰，组件在结构图中的位置已经说明它所实现的是哪一级抽象，担负的是什么功能。</p><p>​      （2）<strong>易修改，可维护性强</strong>。由于线索之间是相互独立的，所以对一个线索的修改不会影响到其他线索。因此，当软件需求发生变化时，可以将新需求分解为独立的子需求，然后以线索和其中的组件为主要对象分别对各个子需求进行处理，这样软件修改就很容易实现。系统功能的增加或减少，只需相应的增删线索组件族，而不影响整个正交体系结构，因此能方便地实现结构调整。<br>​      （3）<strong>可移植性强，重用粒度大</strong>。因为正交结构可以为一个领域内的所有应用程序所共享，这些软件有着相同或类似的层次和线索，可以实现体系结构级的重用。 </p><p>​    • <strong>构架的异质性</strong><br>​       实际系统的构架是异质的，既是多种样式的综合，这种异质可以分为3类：<br>​        1 局部异质<br>​        2 层次异质<br>​        3 并行异质</p><h3 id="3-3-参考模型"><a href="#3-3-参考模型" class="headerlink" title="3.3 参考模型"></a>3.3 参考模型</h3><p><strong>参考模型</strong>—是<strong>一种考虑数据流的功能划分，是对已知问题的标准分解，分解所得的各个部分相互协作，构成问题的解决方案</strong>。<br><strong>参考构架</strong>—是<strong>映射到软件组件及组件之间数据流上的参考模型</strong>。</p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241020173137203.png" alt="image-20241020173137203"></p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241020173149986.png" alt="image-20241020173149986"></p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241020173158076.png" alt="image-20241020173158076"></p><p><strong>参考构架—是映射到软件组件及组件之间数据流上的参考模型。</strong></p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241020173219647.png" alt="image-20241020173219647"></p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241020173229943.png" alt="image-20241020173229943"></p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241020173239586.png" alt="image-20241020173239586"></p><h3 id="3-4-软件架构、框架和设计模式"><a href="#3-4-软件架构、框架和设计模式" class="headerlink" title="3.4 软件架构、框架和设计模式"></a>3.4 软件架构、框架和设计模式</h3><p>框架的定义：<br>《设计模式》中对框架的定义是<strong>框架就是一组相互协作的类，对于特定的一类软件，框架构成了一种可重用的设计。</strong><br>软件框架是提取特定领域软件的共性部分形成的体系结构，不同领域的软件项目有着不同的框架类型。框架的作用在于：由于提取了特定领域软件的共性部分，因此在此领域内新项目的开发过程中代码不需要从头编写，只需要在框架的基础上进行一些开发和调整便可满足要求；对于开发过程而言，这样做会提高软件的质量，降低成本，缩短开发时间，形成良性循环。</p><p><strong>框架和平台的关系：</strong><br><strong>框架不是现成可用的应用系统</strong>。是一个半成品，需要后来的开发人员进行二次开发，实现应用系统的具体功能。框架不是“平台”，平台概念比较广泛，可以是一种操作系统，一种应用服务器，一种数据库软件，一种通讯中间件等，因此平台在应用层面主要指提供特定服务的系统软件，而框架更侧重设计和开发过程，框架可通过调用平台提供的服务而起的作用。<br><strong>框架和类库的关系：</strong><br><strong>框架不是工具包或者类库，调用API并不就是在使用框架开发，仅仅使用API是开发者完成系统的主题部分，并不时地调用类库实现特定任务</strong>。而框架构成了通用的、具有一般性的系统主体部分，二次开发人员只是像做填空一样，根据具体业务，完成特定应用系统中与众不同的特殊部分。 </p><p><strong>框架和架构的关系：</strong><br><strong>框架不是构架</strong>。构架确定了系统整体结构、层次划分、不同部分之间的协作等设计考虑。框架比架构更具体，更偏重于技术。确定框架后，其所对应的架构也随之确定，但在一个系统架构中可以集成多种框架，例如J2EE的SSH、SSM。<br><strong>框架和设计模式的关系：</strong><br><strong>设计模式和框架在软件设计中是两个不同的研究领域</strong>。设计模式研究的是一个设计问题的解决方法，一个模式可应用于不同的框架和被不同的语言所实现；而框架则是一个应用的体系结构，是一种或多种设计模式和代码的混合体虽然它们有所不同，但却共同致力于使人们的设计可以被重用，在思想上存在着统一性的特点，因而设计模式的思想可以在框架设计中进行应用。</p><ol><li>从应用领域上分，框架给出的是整个应用的体系结构；而设计模式则给出了单一设计问题的解决方案，并且这个方案可在不同的应用程序或者框架中进行应用。</li><li>从内容上分，设计模式仅是一个单纯的设计，这个设计可被不同语言以不用方式来实现；而框架则是设计和代码的一个混合体，编程者可以用各种方式对框架进行扩展，进而形成完整的不同的应用。</li><li>设计模式比框架更容易移植；框架一旦设计成形，虽然还没有构成完整的一个应用，但是以其为基础进行应用的开发显然要受制于框架的实现环境；而设计模式是与语言无关的，所以可以在更广泛的异构环境中进行应用。<br>总之，框架是软件，而设计模式是软件的知识体，提升框架的设计水平。</li></ol><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241020173742068.png" alt="image-20241020173742068"></p><h2 id="4-实现质量属性的战术"><a href="#4-实现质量属性的战术" class="headerlink" title="4. 实现质量属性的战术"></a>4. 实现质量属性的战术</h2><h3 id="4-1-战术介绍"><a href="#4-1-战术介绍" class="headerlink" title="4.1 战术介绍"></a>4.1 战术介绍</h3><p><strong>战术是对质量属性的控制产生影响的设计决策。</strong><br><strong>架构策略是架构中所采用的战术的集合。</strong><br>战术的特点：</p><ol><li>根据一种战术可以求精其他战术，并可以组织成层次的形式。如冗余战术可进一步求精为数据冗余或计算冗余。</li><li>模式可以把战术打包，如冗余战术通常还会使用同步战术。</li></ol><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241020182634903.png" alt="image-20241020182634903"></p><h3 id="4-2-可用性战术"><a href="#4-2-可用性战术" class="headerlink" title="4.2 可用性战术"></a>4.2 可用性战术</h3><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241020182659755.png" alt="image-20241020182659755"></p><h4 id="4-2-1-错误检测"><a href="#4-2-1-错误检测" class="headerlink" title="4.2.1 错误检测"></a>4.2.1 错误检测</h4><p>用于检测错误的3个战术是：<br>         • 砰&#x2F;回声<br>         • 心跳<br>         • 异常<br><strong>砰&#x2F;回声和心跳战术</strong>用来检测<strong>另一个进程的错误</strong>，<strong>异常</strong>是进<strong>程本身的错误处理</strong>。</p><h4 id="4-2-2-错误恢复"><a href="#4-2-2-错误恢复" class="headerlink" title="4.2.2 错误恢复"></a>4.2.2 错误恢复</h4><p>用于错误恢复的战术有：<br>         • 表决<br>         • 主动冗余<br>         • 被动冗余<br>         • 备件<br>         • shadow操作<br>            Windows的安全模式<br>         • 状态再同步<br>         • 检查点&#x2F;回滚</p><h4 id="4-2-3-错误预防"><a href="#4-2-3-错误预防" class="headerlink" title="4.2.3 错误预防"></a>4.2.3 错误预防</h4><p>用于错误预防的战术有：<br>         • 进程监视器<br>         • 从服务中删除<br>         • 事务</p><h3 id="4-3-可修改性的战术"><a href="#4-3-可修改性的战术" class="headerlink" title="4.3 可修改性的战术"></a>4.3 可修改性的战术</h3><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241020182835040.png" alt="image-20241020182835040"></p><h4 id="4-3-1-局部性修改"><a href="#4-3-1-局部性修改" class="headerlink" title="4.3.1 局部性修改"></a>4.3.1 局部性修改</h4><p>局部化修改的目标是在设计期间为模块分配责任，以把预期的变更限制在一定的范围内，以降低修改成本，其战术有：<br>         • 维持语义的一致性<br>         • 预期期望的变更<br>         • 泛化模块<br>         • 限制可能的选择</p><h4 id="4-3-2-防止连锁反应"><a href="#4-3-2-防止连锁反应" class="headerlink" title="4.3.2 防止连锁反应"></a>4.3.2 防止连锁反应</h4><p>修改所产生的连锁反应就是本修改没有直接影响到的模块也需要改变，这是由于模块间存在依赖关系，这种依赖关系有：<br>         • 语法<br>         • 语义<br>         • 顺序<br>防止连锁反应的战术有：<br>         • 信息隐藏<br>         • 维持现有的接口<br>               Δ 添加接口<br>               Δ 添加适配器<br>               Δ 提供一个占位程序A</p><h4 id="4-3-3-推迟绑定时间"><a href="#4-3-3-推迟绑定时间" class="headerlink" title="4.3.3 推迟绑定时间"></a>4.3.3 推迟绑定时间</h4><p>推迟绑定可以允许非开发人员进行修改，也可以延迟部署时间，其战术有：<br>         • 运行时注册—支持即插即用<br>         • 配置文件—启动时设置参数<br>         • 多态—允许方法调用的后期绑定<br>         • 组件更换 –允许载入时间绑定<br>         • 遵守已定义的协议—允许独立进程的运行时绑定</p><h3 id="4-4-实施性能的战术"><a href="#4-4-实施性能的战术" class="headerlink" title="4.4 实施性能的战术"></a>4.4 实施性能的战术</h3><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241020183035008.png" alt="image-20241020183035008"></p><p>影响响应时间的两个基本因素是：<br>         • 资源消耗<br>         • 阻塞时间<br>                Δ 资源争用<br>                Δ 资源的可用性<br>                Δ 对其他计算的依赖性</p><h4 id="4-4-1-控制对资源需求"><a href="#4-4-1-控制对资源需求" class="headerlink" title="4.4.1 控制对资源需求"></a>4.4.1 控制对资源需求</h4><p>1 减少处理一个事件所需要的资源：<br>         • 提高计算效率<br>         • 减少计算开销<br>2 减少需要同时处理事件的数量：<br>         • 管理事件率<br>         • 控制采样频率<br>3 控制资源的使用：<br>         • 限制执行时间<br>         • 限制队列的大小</p><h4 id="4-4-2-资源管理"><a href="#4-4-2-资源管理" class="headerlink" title="4.4.2 资源管理"></a>4.4.2 资源管理</h4><p>用于资源管理的战术有：<br>         • 引入并发<br>         • 维持数据或计算的多个副本<br>         • 增加可用资源</p><h4 id="4-4-3-资源仲裁"><a href="#4-4-3-资源仲裁" class="headerlink" title="4.4.3 资源仲裁"></a>4.4.3 资源仲裁</h4><p>常见的调度策略有：<br>         • 先进&#x2F;先出<br>         • 固定优先级<br>             Δ 语义重要性<br>                Δ 时限时间单调<br>                Δ 速率单调<br>         • 动态优先级调度<br>            Δ 轮转<br>               Δ 时限时间最早优先<br>         • 静态调度</p><h3 id="4-5-实施安全性的战术"><a href="#4-5-实施安全性的战术" class="headerlink" title="4.5 实施安全性的战术"></a>4.5 实施安全性的战术</h3><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241020183153727.png" alt="image-20241020183153727"></p><h4 id="4-5-1-检测攻击"><a href="#4-5-1-检测攻击" class="headerlink" title="4.5.1 检测攻击"></a>4.5.1 检测攻击</h4><p>配置网络监视器来检测和记录网络事件，网络入侵检测系统的工作方式是比较网络通信模式与数据库中的记录。通常，必须根据协议、TCP标记、有效符合大小、源或目的地地址以及端口号等，对数据包进行过滤。<br>         • 误用情况的检测是把通信模式与已知攻击的历史模式进行比较。<br>         • 异常情况的检测是把通信模式与其本身的历史基线（情况）进行比较。<br>入侵检测系统必须有检测攻击的传感器、存储事件供以后分析的数据库、用于离线报告和分析的工具、一个让分析员能够修改入侵检测操作的控制台。</p><h4 id="4-5-2-抵抗攻击"><a href="#4-5-2-抵抗攻击" class="headerlink" title="4.5.2 抵抗攻击"></a>4.5.2 抵抗攻击</h4><p>用于抵抗攻击的战术是：<br>         • 对用户进行身份验证<br>         • 对用户进行授权<br>         • 维护数据的机密性<br>         • 维护完整性<br>         • 限制暴露的信息<br>         • 限制访问<br>         • 在外部用户和提供服务的系统之间设置认证服务器。<br>         • 把要保护的系统置于通讯防火墙之后<br>         • 在某个可信内核的基础上构建系统，由该内核提供安全</p><h4 id="4-5-3-从攻击中恢复"><a href="#4-5-3-从攻击中恢复" class="headerlink" title="4.5.3 从攻击中恢复"></a>4.5.3 从攻击中恢复</h4><p>从攻击中恢复的战术分为：<br>         • 恢复状态<br>         • 识别攻击者</p><h3 id="4-6-易用性的战术"><a href="#4-6-易用性的战术" class="headerlink" title="4.6 易用性的战术"></a>4.6 易用性的战术</h3><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241020183315254.png" alt="image-20241020183315254"></p><h4 id="4-6-1-运行时战术"><a href="#4-6-1-运行时战术" class="headerlink" title="4.6.1 运行时战术"></a>4.6.1 运行时战术</h4><p>易用性的表现：系统正在做什么，用户能做什么，系统帮用户做什么。<br>人机交互的过程可以用“用户主动”、“系统主动”和“混合主动”，其中“系统主动”需要根据一定的模型来实现。<br>         • 维持<strong>任务</strong>的一个模型<br>         例如英文句子常以大写字母开头，可以纠正该位置的小写字母。某个词组多次输入后Word能保存该词组。<br>         • 维持<strong>用户</strong>的一个模型<br>         例如维持用户模型使系统以用户满意的速度滚动显示。<br>         • 维持<strong>系统</strong>的一个模型<br>         拷贝或粘贴的时间预计。</p><h4 id="4-6-2-设计时战术"><a href="#4-6-2-设计时战术" class="headerlink" title="4.6.2 设计时战术"></a>4.6.2 设计时战术</h4><p>在测试过程中，用户接口可能频繁修改，这就要求修改时保持语义的一致，该战术进一步求精为—<strong>将用户接口与应用的其余部分分离开来</strong>，从而局部化变更。支持该战术的软件构架有：<br>         • 模型-视图-控制器<br>         • 表示-抽象-控制<br>         • Seeheim<br>         • Arch&#x2F;Slinky</p><h3 id="4-7-案例：中行网上银行安全战术分析"><a href="#4-7-案例：中行网上银行安全战术分析" class="headerlink" title="4.7 案例：中行网上银行安全战术分析"></a>4.7 案例：中行网上银行安全战术分析</h3><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241020183425901.png" alt="image-20241020183425901"></p><h3 id="4-8-软件架构样式与战术的关系"><a href="#4-8-软件架构样式与战术的关系" class="headerlink" title="4.8 软件架构样式与战术的关系"></a>4.8 软件架构样式与战术的关系</h3><p>软件架构样式从<strong>战略层面</strong>解决质量问题，战术是从<strong>具体部署</strong>上给出解决质量问题的局部策略。</p><h2 id="5-设计构架"><a href="#5-设计构架" class="headerlink" title="5. 设计构架"></a>5. 设计构架</h2><h3 id="5-1-生命期中的构架"><a href="#5-1-生命期中的构架" class="headerlink" title="5.1 生命期中的构架"></a>5.1 生命期中的构架</h3><p>软件过程—对软件开发活动的组织、规范和管理<br><strong>基于构架的开发步骤</strong></p><ol><li>为软件系统构建一个商业案例</li><li>弄清系统需求</li><li>构建或选用构架</li><li>正确表述此构架，并与有关各方进行交流</li><li>对此构架进行分析和评价</li><li>实现基于构架的系统并保证与构架相一致</li><li>系统维护时，构架文档应同步维护</li></ol><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241020190601608.png" alt="image-20241020190601608"></p><p><strong>何时可以开始设计?</strong><br>        对需求有了初步了解就可以开始设计。<br>构架驱动因素的组成：<br>        比较重要的功能、质量属性、限制条件构成的某个子集<br>如何确定构架驱动因素?<br>        业务目标优先级较高的要求</p><h3 id="5-2-良好架构的评判原则"><a href="#5-2-良好架构的评判原则" class="headerlink" title="5.2 良好架构的评判原则"></a>5.2 良好架构的评判原则</h3><p>设计构架过程的建议：</p><ol><li>构架的设计应该由<strong>一位</strong>设计师来完成</li><li>设计师应全面掌握对系统的技术需求，以及对各项定性指标<strong>优先级的清单</strong></li><li>构架的文档完备，并采用所有人员认可的文档形式（至少有一个静态视图和动态视图）</li><li>构架设计方案应让各风险承担者积极参与评估</li><li>通过对构架分析，得出明确的定性与定量指标</li><li>构架设计应有助于具体实现（有助于增量式实现）</li><li>允许构架带来一定的资源争用，并给出可行的解决方案</li></ol><p>关于构架的结构的建议：</p><ol><li>构架由定义良好的模块组成，各模块的功能划分应基于信息隐藏</li><li>模块的划分应体现出相互独立的原则</li><li>把计算机基础结构的特性封装在一定的模块中</li><li>构架尽量不依赖于某个特定版本的商用产品或工具</li><li>产生数据的功能和使用数据的功能应分属于不同的模块</li><li>对并发系统，构架应充分考虑进程与模块结构的不对应</li><li>进程编写要考虑到与特定处理器的关系，并容易改变关系</li><li><strong>构架应尽量采用一些已知的设计模式</strong>。</li></ol><h3 id="5-3-架构设计的质量驱动方法"><a href="#5-3-架构设计的质量驱动方法" class="headerlink" title="5.3 架构设计的质量驱动方法"></a>5.3 架构设计的质量驱动方法</h3><p>你作为设计师对构架的设计和评价就如同一个足球教练对一场比赛的球队组织，你首先要了解自身和对手的情况，明确你这场比赛想打输、打赢或打平（质量目标），然后根据该目标设计比赛阵型，如攻击或防守阵型，再确定相关战术和人员组织（构架设计、战术选用），最后将你的设计和队员沟通，取得全体队员的共识（构架评价）</p><p><strong>属性驱动的设计(Attribute Driven Design, ADD)<strong>把一组质量属性场景作为输入，利用对质量属性实现与构架设计之间的关系的了解，对构架进行设计。<br>ADD是一种定义软件构架的方法，该方法将模块分解过程建立在软件必须满足的质量属性之上。它是一个递归的分解过程，其中在每个阶段都选择构架模式和战术来满足一组质量属性场景，然后对功能进行分配，以实例化有该模式所提供的模块类型。<br>ADD的结果是粗粒度的， ADD的结果是构架的模块分解视图和其他视图的最初的几个层次，不是视图的所有细节都是通过ADD得到。<br>由ADD得到的构架和已经为实现做好准备的构架之间的区别是，</strong>需要做出更详细的设计决策。</strong></p><p><strong>ADD构架设计的步骤</strong>如下：</p><ol><li>需求输入。</li><li>选择要分解的模块。</li><li>根据下列步骤对模块进行求精：<br> a. 从具体的质量场景和功能需求集合中选择构架驱动因素。<br> b. 选择满足构架驱动因素的构架样式（风格）、参考模型，形成参考架构、框架和设计模式。<br> c. 实例化模块并根据用例分配功能，使用多个视图进行表示。<br> d. 定义子模块的接口。<br> e. 验证用例和质量场景并对其进行求精，使它们成为子模块的限制。</li><li>对需要进一步分解的每个模块<strong>重复上述步骤</strong>。</li></ol><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241020190851517.png" alt="image-20241020190851517"></p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241020190901415.png" alt="image-20241020190901415"></p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241020190912193.png" alt="image-20241020190912193"></p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241020190921230.png" alt="image-20241020190921230"></p><h3 id="5-4-创建骨架系统"><a href="#5-4-创建骨架系统" class="headerlink" title="5.4 创建骨架系统"></a>5.4 创建骨架系统</h3><p>创建骨架系统的思想是<strong>提供一种基本能力，以一种对项目有力的顺序实现系统的功能。</strong><br>在系统开发的最初阶段创建整个系统的骨架系统是非常重要的，主要原因包括：</p><ol><li>提高开发效率，鼓舞士气。</li><li>能更早发现复杂的依赖关系。</li><li>使开发人员更多关注在设想中最难以实现的部分。</li><li>能够缩短系统集成时间，降低其成本，并使集成成本更明确。<br>便于评审和测试。</li></ol><p>创建骨架系统的步骤：</p><ol><li>实现处理构架组件交互的软件部分。</li><li>选择组件逐步添加到系统中。</li><li>逐步进行测试。</li></ol><h3 id="5-5-团队结构的形成"><a href="#5-5-团队结构的形成" class="headerlink" title="5.5 团队结构的形成"></a>5.5 团队结构的形成</h3><p>开发小组的结构反映了构架的模块结构。可以把模块看作一个小领域，再根据开发人员的专长进行安排。<br>开发小组要做到松耦合，高内聚，即小组内需要有非常便于沟通的机制，小组间的沟通尽可能少。<br>开发组织对构架也会有影响。</p><h3 id="5-6-架构师的职责"><a href="#5-6-架构师的职责" class="headerlink" title="5.6 架构师的职责"></a>5.6 架构师的职责</h3><p>架构师要和多个部门和多种人沟通，如要指导以架构为核心形成开发团队，协调团队之间的合作，解决他们之间的冲突；架构师要支持项目经理的工作，要知道开发团队的技术水平；为明确组织的业务目标，架构师需要和售前、售后部门交流，拜访客户。因此，架构师必须纵观软件过程的全局，并对不同角色相互合作的接口和时机有清晰的把握。架构师的职责包括：<br>1   了解所在组织的业务目标，使架构更好地支持业务目标<br>2   规划产品的开发与演进<br>3   规划和建设架构级的重用，如产品线等<br>4   领导并负责架构设计，定义系统的高层结构和接口<br>5   为项目管理提供支持，如技术可行性、任务划分、人员招聘 </p><p>6    领导和协调项目组的主要技术活动，对主要技术产品负责实际参与架构原型的开发实现<br>7    讲解架构、指导详细设计和开发、协调冲突以实现既定的构架目标<br>8    规划和协助软件架构的评审<br>9    评估新技术并提出采用建议</p><h2 id="6-案例分析"><a href="#6-案例分析" class="headerlink" title="6. 案例分析"></a>6. 案例分析</h2><h3 id="6-1-项目背景"><a href="#6-1-项目背景" class="headerlink" title="6.1 项目背景"></a>6.1 项目背景</h3><p>​         随着互联网的大规模普及以及近年来中国政府大力推广“互联网+”理念，让许多传统公司的经营方式从线下迁移到线上，互联网科技技术的发展促使着商业模式的剧烈转型，其中包括传统的门店销售转型成网上交易，现如今，人们已经越来越依赖网上购物，它的出现给人们的生活带来了深远的影响。<br>​         传统的门店销售，不仅需要店家前期通过市场调研寻找合适的店铺门店，而且需要支付门店开设，门店装修等费用，在前期投入中就给店家带来了巨大压力；同时还需要对商品的库存，进货，资金流水有明确的了解；顾客也需要几经辗转才能到指定的店铺购买到心怡的商品。给买卖双方带来极大的不便。而网上购物，店家不需要前期巨大投入，只需要简单的操作步骤和少许费用即可完成店铺开设，在商品的管理和订单流水上，一目了然。买家也可以不需要花费出行时间就可以挑选购买到需要的商品。</p><h3 id="6-2-需求分析"><a href="#6-2-需求分析" class="headerlink" title="6.2 需求分析"></a>6.2 需求分析</h3><p>​       创建代表“目前”业务情况的业务模型，并将此业务模型转换成“将来”的系统模型，包括功能需求和非功能需求。非功能需求又包括质量属性和各种约定。<br>​       通过对客户的当前业务的分析，我们得到当前业务的基本需求。</p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241020191122967.png" alt="image-20241020191122967"></p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241020191131295.png" alt="image-20241020191131295"></p><h4 id="6-2-1-定义系统"><a href="#6-2-1-定义系统" class="headerlink" title="6.2.1 定义系统"></a>6.2.1 定义系统</h4><p>根据业务的功能需求，该系统主要的涉众有卖家、买家、管理人员和游客，卖家会对店铺和商品信息进行相关维护，管理人员对卖家和买家信息进行相关的维护。由此得出系统角色，分析其对系统的具体要求，并找出系统的各个用例。</p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241021192156915.png" alt="image-20241021192156915"></p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241021192204606.png" alt="image-20241021192204606"></p><h4 id="6-2-2-质量场景"><a href="#6-2-2-质量场景" class="headerlink" title="6.2.2 质量场景"></a>6.2.2 质量场景</h4><p>1）性能场景：在系统处于高峰时期，保证登陆的每个顾客所作的选择和查询的响应时间能在5s以内，如果需要等待则给出有友好的提示。系统可以保证以最快速度同时响应500个用户的操作。    </p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241021192247159.png" alt="image-20241021192247159"></p><p>2）安全性场景：杜绝非法用户试图绕过应用服务器直接连接到数据库服务器的端口上，防止非法窃取注册用户个人息；屏蔽某IP短时间内的大量无意义的访问，以防被挤爆，使正常用户无法使用。保证系统数据的机密性和完整性。</p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241021192305642.png" alt="image-20241021192305642"></p><p>3）易用性场景：在该系统中，用户希望在运行时能尽快取消某操作使错误的影响降到最低，取消在1秒内发生；要求具有基本电脑操作常识的人，可以根据良好的界面设计迅速学会使用方法，让熟手用户使用快捷键。</p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241021192325555.png" alt="image-20241021192325555"></p><ol start="4"><li>可用性场景：在正常的工作时间内，系统必须具有极高的可用性，保证出故障几率最低。出现故障时系统有相应的处理机制。</li></ol><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241021192342955.png" alt="image-20241021192342955"></p><h4 id="6-2-3-约束（限制）条件"><a href="#6-2-3-约束（限制）条件" class="headerlink" title="6.2.3 约束（限制）条件"></a>6.2.3 约束（限制）条件</h4><p>​    (1) 开发周期<br>​    (2) 技术人员水平<br>​    (3) 开发费用<br>​    (4) 用户操作能力</p><h3 id="6-3-系统架构设计"><a href="#6-3-系统架构设计" class="headerlink" title="6.3 系统架构设计"></a>6.3 系统架构设计</h3><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241021192434680.png" alt="image-20241021192434680"></p><h4 id="6-3-1-样式选择、参考模型、参考架构"><a href="#6-3-1-样式选择、参考模型、参考架构" class="headerlink" title="6.3.1 样式选择、参考模型、参考架构"></a>6.3.1 样式选择、参考模型、参考架构</h4><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241021192501821.png" alt="image-20241021192501821"></p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241021192508017.png" alt="image-20241021192508017"></p><h4 id="6-3-2-体系结构的设计"><a href="#6-3-2-体系结构的设计" class="headerlink" title="6.3.2 体系结构的设计"></a>6.3.2 体系结构的设计</h4><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241021192526115.png" alt="image-20241021192526115"></p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241021192535723.png" alt="image-20241021192535723"></p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241021192543630.png" alt="image-20241021192543630"></p><h4 id="6-3-3-系统架构的分析与设计"><a href="#6-3-3-系统架构的分析与设计" class="headerlink" title="6.3.3 系统架构的分析与设计"></a>6.3.3 系统架构的分析与设计</h4><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241021192619824.png" alt="image-20241021192619824"></p><p>业务逻辑层架构设计<br>         业务逻辑层作为该系统的关键部分，对系统的灵活性实现起着决定性的 作用。在本系统的业务逻辑层架构层中，采取了MVC模式，下面简单介绍一 下MVC模式的好处：<br>       (1) 实现了客户端表示层和业务逻辑层的完全分离<br>       (2) 高效可靠的事务处理<br>       (3) 具有良好的易用性，安全性</p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241021192640948.png" alt="image-20241021192640948"></p><p>业务逻辑层架构分析：<br>        该业务逻辑层的架构是前面MVC模式的一种变形，他继承了MVC模式的优点，同时，具体到我们的架构中，它又实现了表示层与业务层的完全分离。在业务逻辑层我们使用Spring框架作为容器，以便实现业务层与表示层和数据层的松耦合。该业务逻辑层架构具备良好的易用性、安全性和性能。</p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241021192706468.png" alt="image-20241021192706468"></p><h3 id="6-4-小结"><a href="#6-4-小结" class="headerlink" title="6.4 小结"></a>6.4 小结</h3><p>本章通过案例分析描述了设计师是如何通过质量属性来驱动系统设计的过程，根据质量属性选择相应的战术以及场景来进行分析。</p><h2 id="7-构架评审的一般方法"><a href="#7-构架评审的一般方法" class="headerlink" title="7. 构架评审的一般方法"></a>7. 构架评审的一般方法</h2><h3 id="7-1-成本与收益"><a href="#7-1-成本与收益" class="headerlink" title="7.1 成本与收益"></a>7.1 成本与收益</h3><p>成本</p><ol><li><p>人员时间成本</p></li><li><p>构架评审部门的组织开销</p></li><li><p>构架评审部门要求高级设计人员参与的代价</p></li></ol><p>收益</p><ol><li>及早发现现有构架中存在的问题</li><li>构架的改进</li><li>财务收益</li><li>强制为评审做准备</li><li>捕获构架设计的基本思想</li><li>验证需求的有效性</li></ol><h3 id="7-2-评审技巧"><a href="#7-2-评审技巧" class="headerlink" title="7.2 评审技巧"></a>7.2 评审技巧</h3><p>​       所谓“<strong>定性分析</strong>”，是指<strong>凭分析者的直觉、经验，凭分析对象过去和现在的延续状况及最新的信息资料，对分析对象的性质、特点、发展变化规律作出判断的一种方法</strong>。<br>​       所谓“<strong>定量分析</strong>”，是<strong>依据实际统计数据，建立数学模型，并用数学模型计算出分析对象的各项指标及其数值的一种方法</strong>。</p><p>构架评审技巧可以分为两大类，应用不同的技巧需要付出不同的代价，也能够得到不同的信息。<br>        定性技巧—提问技巧<br>           1.<strong>场景</strong>—描述风险承担者和系统之间的具体交互<br>           2.<strong>评审清单</strong>—对同一领域的若干系统进行评估后提出的一组详细的问题<br>           3.<strong>问卷</strong>—适用于所有构架的若干问题的清单<br>        定量技巧<br>           1.<strong>指标</strong>—对构架可观察到的参数的量化解释<br>           2.<strong>模拟、原型与实验</strong></p><p>评审技巧的选用<br>        <strong>场景-&gt;评审清单-&gt;问卷调查</strong><br>        利用系统原型或模拟系统来解答与性能等相关的问题</p><h3 id="7-3-评审实践"><a href="#7-3-评审实践" class="headerlink" title="7.3 评审实践"></a>7.3 评审实践</h3><p><strong>评审前提</strong></p><ol><li>评审环境—预先规划</li><li>项目代表—风险承担者，子系统或组件负责人</li><li>评审小组<br>  • 评审小组的人员公证、客观、受尊重<br>   • 成员必须专门从事评审工作<br>   • 有对构架相关问题熟悉的人，其领导具有设计、评价经验<br>   • 至少有一位该系统所属领域的专家<br>  • 有专人负责文档、后勤，办公地点离评审对象近，有学徒</li><li>组织的期望—用合同明确<br>  • 构架评审结束时应向谁报告什么内容<br>  • 评审的标准是什么<br>  • 向评审小组提供那些资源及人力<br>  • 对评审小组和项目组以后的工作有什么期望<br>  • 预计评审持续的最长时间<br>  设定期望的目的是让所有人都理解评审结果的本质是判断可行性，而不是提供任何保证。</li><li>评审的准备—制定评审日程<br>  • 系统需求文档<br>  • 架构文档，包括架构描述及介绍构架决策思想的材料<br>  • 将系统的质量属性和功能要求按重要程度排序出前面3-5个</li></ol><p><strong>评审实施</strong><br>      • 按问题的重要性进行分类。<br>      • 强调那些与构架相符或相悖的重要问题。<br>      • 必须记载评审中所提的每个问题。<br><strong>评审结果</strong><br>       对评审中的各个问题都要做出正式的阐述，同时也要对赖以确定这些问题的数据做出相应的说明。</p><h3 id="7-4-小结"><a href="#7-4-小结" class="headerlink" title="7.4 小结"></a>7.4 小结</h3><p>构架评审的主要指导原则如下：</p><ol><li>把由独立部门实施的正规的构架评审作为项目开发周期规划的一部分。</li><li>选择评审的最佳时间，尽早预审一次。</li><li>选择恰当的评审技巧。</li><li>签署评审合同。</li><li>限制所要评审的质量属性的个数。</li><li>要保证评审小组中有构架方面的专家、领域专家、资料员及后勤员。</li><li>一定要有系统设计师。</li><li>收集各种场景数据，并在此基础上形成评审清单。</li></ol><p>评审（分析）软件架构的原因</p><ul><li><strong>架构师风险承担者交流的平台、是早期设计决策的体现、是可传递的系统抽象（架构级重用）</strong></li><li><strong>系统的质量属性不可能在系统实现的最后阶段追加上去，必须在设计之初就考虑到</strong></li></ul><h2 id="8-架构权衡分析法-ATAM"><a href="#8-架构权衡分析法-ATAM" class="headerlink" title="8. 架构权衡分析法(ATAM)"></a>8. 架构权衡分析法(ATAM)</h2><h3 id="8-1-ATAM的参与人员"><a href="#8-1-ATAM的参与人员" class="headerlink" title="8.1 ATAM的参与人员"></a>8.1 ATAM的参与人员</h3><p>ATAM(Architecture Tradeoff Analysis Method)—构架权衡分析法（基于场景的定性评审方法）。<br>ATAM方法的特点是<strong>不仅可以揭示出构架满足特定质量目标的情况，而且可以使我们更清楚地认识到质量目标之间的联系</strong>。<br>ATAM的中心问题是<strong>对用于构架评估的有限时间进行管理</strong>。<br>ATAM要求以下3个小组的参与和合作：<br>       • <strong>评估小组</strong><br>       通常由3-5人组成，每个人要扮演多个角色，其中计时员的角色辅助管理时间。</p><p>​       • 构架的主要涉众（项目决策人）<br>​         客户、项目管理人员、委托进行评审的人<br>​       • 构架的其他涉众</p><h3 id="8-2-ATAM的输入和结果"><a href="#8-2-ATAM的输入和结果" class="headerlink" title="8.2 ATAM的输入和结果"></a>8.2 ATAM的输入和结果</h3><p>软件构架评估的输入与输出<br>        输入—<strong>用场景集合捕获的质量要求</strong><br>        输出—<strong>粗糙的评价</strong>，可能包括：<br>        • 一个简洁的构架表述<br>        • 表述清楚的业务目标<br>        • 构架决策到质量需求的映射<br>        • 所确定的敏感点和权衡点集合<br>       <strong>敏感点：一个战术满足了一个质量场景</strong><br>       <strong>权衡点：一个战术满足了一个质量场景，但对另一质量场景产生了负面影响</strong></p><p>​       • 有风险决策和无风险决策<br>​        <strong>有风险决策：一个战术满足了一个质量场景，但该战术有风险</strong><br>​       • 风险主题的集合<br>​         <strong>风险主题：将有风险决策以通俗易懂的形式呈现出来</strong></p><h3 id="8-3-ATAM的阶段"><a href="#8-3-ATAM的阶段" class="headerlink" title="8.3 ATAM的阶段"></a>8.3 ATAM的阶段</h3><p>ATAM中的活动被分为四个阶段：<br>        • 评估小组和项目决策者共同确定评估细节。<br>        • 评估小组收集信息和分析。<br>        • 风险承担者参与评估。<br>        • 评估小组自我检查和改进，提交书面报告。</p><h4 id="8-3-1-评估阶段的步骤"><a href="#8-3-1-评估阶段的步骤" class="headerlink" title="8.3.1 评估阶段的步骤"></a>8.3.1 评估阶段的步骤</h4><p>ATAM的分析评估阶段由9步组成：<br>             1. ATAM方法的表述<br>             2. 商业动机的表述<br>                   任何相关的技术、管理、经济和政治限制<br>                   与该项目相关的商业目标和上下文<br>                   主要的涉众<br>                   构架的驱动因素<br>             3. 构架的表述<br>                   祥略适当，在有限时间内传达构架的本质<br>                   技术约束条件<br>             4. 对构架方法进行分类<br>                   说明构架中涉及的样式和战术对质量的影响<br>             5. 生成质量属性效用树<br>                   效用树的作用是使质量属性需求具体化，从而迫使设计师和客户代表准确地定义出他们的质量需求。<br>                               <strong>“效用”是效用树的根结点，表示系统的总体适宜性。</strong><br>                               <strong>中间结点是质量属性及其求精。</strong><br>                               <strong>叶结点是与质量属性对应的场景。</strong><br>             6. 分析构架方法<br>             7. 集体讨论并确定场景优先级<br>             8. 再次分析构架方法<br>             9. 结果的表述</p><h4 id="8-3-2-有效利用有限的评估时间"><a href="#8-3-2-有效利用有限的评估时间" class="headerlink" title="8.3.2 有效利用有限的评估时间"></a>8.3.2 有效利用有限的评估时间</h4><ol><li>业务目标被作为收集效用树场景的动机</li><li>划分分场景优先级</li><li>自顶向下生成效用树场景，自底向上进行分析</li><li>仅分析优先级高和较难实现的场景</li></ol><h3 id="8-4-小结"><a href="#8-4-小结" class="headerlink" title="8.4 小结"></a>8.4 小结</h3><p>ATAM是评估软件构架的健壮方法。在该方法中，项目决策者和风险承担者要以场景方式阐述一个准确的质量属性需求列表，说明实现高优先级场景的构架决策。然后，把这些决策确定为有风险和无风险场景，以找到构架中存在的问题。<br>但ATAM不是需求评估，不是代码评估，不包括对实际系统的测试，不是一个量化的手段。</p><h2 id="9-架构文档的写作"><a href="#9-架构文档的写作" class="headerlink" title="9. 架构文档的写作"></a>9. 架构文档的写作</h2><h3 id="9-1-编写架构文档的目的和原则"><a href="#9-1-编写架构文档的目的和原则" class="headerlink" title="9.1 编写架构文档的目的和原则"></a>9.1 编写架构文档的目的和原则</h3><p>1 构架编档的目的与作用<br>   让不同的风险承担者都能快速找到和理解他们所需要的信息。</p><p>2 构架文档写作的<strong>基本规则</strong>是：<br>   就是<strong>从读者的角度出发</strong>。</p><h3 id="9-2-选择相关结构"><a href="#9-2-选择相关结构" class="headerlink" title="9.2 选择相关结构"></a>9.2 选择相关结构</h3><p>构架编档的基本顺序是：<br>       将相关结构编成文档，然后向其中添加结构之间关系的文件。</p><ol><li><strong>产生一个候选结构列表</strong><br>先为项目建立一个风险承担者和他们感兴趣的视图表，与项目的具体情况尽可能相符。</li><li><strong>组合结构</strong></li><li><strong>划分优先级</strong><br>为了提供一个适当的结构集合，需要根据项目的具体情况确定先做什么，不需要在完成一个结构后再开始另一个结构，可采用宽度优先的方法。</li></ol><h3 id="9-3-结构编档"><a href="#9-3-结构编档" class="headerlink" title="9.3 结构编档"></a>9.3 结构编档</h3><p>没有对结构进行编档的工业标准模板。<br>在实践中，文档通常包括下面七部分内容：<br>      • 展示结构中的组件和组件之间关系的主要表示，常用图形方式。<br>      • 组件目录至少祥述在主要表示中提到的组件和组件之间的相互关系，还包括组件的接口和行为。<br>      • 系统与其环境相关的上下文图。<br>      • 可变性指南，包括：<br>             要在其中做出选择的选项<br>             做出选择的时机</p><p>​      • 解释构架设计的背景，包括：<br>​            基本原理<br>​            分析结果<br>​            设计中所反映的假定<br>​      • 结构中所选择的术语表。<br>​      • 其他信息。</p><h4 id="9-3-1-对行为进行编档"><a href="#9-3-1-对行为进行编档" class="headerlink" title="9.3.1 对行为进行编档"></a>9.3.1 对行为进行编档</h4><p>结构仅提供了系统的组成信息，并不能据此对某些系统行为进行推断，而行为描述可以提供元素间的交互顺序、并发机会以及交互的时间依赖性的信息。<br>对行为的描述可以采用不同的建模技术和表示法，这取决于所要进行的分析的类型。<br>在UML中，顺序图和状态图用于行为描述。</p><h4 id="9-3-2-对接口进行编档"><a href="#9-3-2-对接口进行编档" class="headerlink" title="9.3.2 对接口进行编档"></a>9.3.2 对接口进行编档</h4><p>接口就是两个独立的实体相遇并进行交互或通信的边界。<br>组件接口就是其他组件可对该组件所做的假设。<br>对接口进行编档的模板包括：<br>      • 接口身份<br>      • 所提供的资源<br>      • 数据类型定义<br>      • 异常定义<br>      • 该接口提供的可变性<br>      • 接口的质量属性特征<br>      • 基本原理和设计问题<br>      • 使用指南   </p><h3 id="9-4-跨结构的文档"><a href="#9-4-跨结构的文档" class="headerlink" title="9.4 跨结构的文档"></a>9.4 跨结构的文档</h3><p>结构文档看起来不应是孤立存在的，而要形成一个整体，这包括构架概述、构架的基本原理和如何安排与组织文档。<br>构架概述包括：<br>        • 系统概述<br>        • 结构之间的映射<br>        • 组件列表<br>        • 项目词汇<br>构架基本原理包括：<br>       • 设计决策<br>       • 预计可能的修改对构架的影响<br>       • 在实现解决方案中对开发人员的限制<br>       • 拒绝采用的决策方案</p><p>如何组织文档：<br>        构架文档的每个套件都需要有介绍性内容，以向经验不多的涉众介绍其组织结构，并帮助他们获得最感兴趣的信息。文档组织包括两种方式：<br>        • 结构目录<br>                   结构的名称和它说明的样式<br>                   结构中的组件类型、关系类型和属性的描述<br>                   结构目的的描述<br>                   结构文档的管理信息<br>       • 结构模板</p><h2 id="10-评审案例分析"><a href="#10-评审案例分析" class="headerlink" title="10. 评审案例分析"></a>10. 评审案例分析</h2><h3 id="10-1-ATAM方法表述"><a href="#10-1-ATAM方法表述" class="headerlink" title="10.1 ATAM方法表述"></a>10.1 ATAM方法表述</h3><p>(1) 概述<br>       ATAM（Architecture Tradeoff Analysis Method）：<br>       SEI提出的一种软件构架评估方法。ATAM评估方法的主要目的：<br>       1) 提炼出软件质量属性需求的精确描述；<br>       2) 提炼出构架设计决策的精确描述；<br>        3) 评估这些构架设计决策，并判定其是否令人满意的实现了这些质量需求。<br>       ATAM评估方法：<br>       并非把每个可以量化的质量属性都进行详尽的分析，而是使众多的风险承担者（包括经理、开发人员、测试人员、用户、客户等等）都参与进来，由此而达到上述目标的。<br>       ATAM是一种挖掘潜在风险，降低或者缓和现有风险的软件构架评估方法。因此，以下三点是评估中要特别注重的：风险、敏感点和权衡点。</p><p>(2) 构架涉众 </p><p>   ·卖家<br>   ·买家<br>   ·管理人员<br>   ·游客<br>   ·开发人员<br>   ·测试人员</p><p>(3) 评估步骤<br>ATAM主要分以下几个步骤：</p><ol><li>ATAM描述；</li><li>商业动机表述；</li><li>软件构架表述；</li><li>确定构架方式；</li><li>生成效用树；</li><li>分析构架方式；</li><li>确定场景及其优先级；</li><li>进一步分析构架方式；</li><li>得出结论。</li></ol><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241021192906085.png" alt="image-20241021192906085"></p><h3 id="10-2-商业动机的描述"><a href="#10-2-商业动机的描述" class="headerlink" title="10.2 商业动机的描述"></a>10.2 商业动机的描述</h3><p>项目经理从开发组织和客户角度，来表述在线购物系统的商业目标，综合如下：<br>从开发组织角度：开发一个模块性强、实时高效、界面良好、与外部其他系统兼容良好的系统，这使得开发组织能够把整个产品或某个模块卖给其他客户，同时由于良好的界面和业务处理效率而受市场欢迎。<br>从客户角度：系统容易操作，可维护性好、系统稳定、可以及时准确的处理用户的在线购物或查询要求。</p><p>根据上述目标，质量属性可以划分为两类：<br><strong>高优先级质量属性</strong>：<br>        1) 性能<br>        2) 安全性<br>        3) 易用性<br>        4) 可用性<br><strong>重要但优先级较低的属性</strong>：<br>        1) 可维护性<br>        2) 可修改性<br>        3) 可测试性</p><h3 id="10-3-架构表述"><a href="#10-3-架构表述" class="headerlink" title="10.3 架构表述"></a>10.3 架构表述</h3><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241021193037397.png" alt="image-20241021193037397"></p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241021193045172.png" alt="image-20241021193045172"></p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241021193053017.png" alt="image-20241021193053017"></p><h3 id="10-4-质量属性效用树"><a href="#10-4-质量属性效用树" class="headerlink" title="10.4 质量属性效用树"></a>10.4 质量属性效用树</h3><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241021193125981.png" alt="image-20241021193125981"></p><h3 id="10-5-质量场景的构架分析"><a href="#10-5-质量场景的构架分析" class="headerlink" title="10.5 质量场景的构架分析"></a>10.5 质量场景的构架分析</h3><p>​       在质量属性效用树中，我们对场景的优先级进行了划分，而同时由于分析时间宝贵，所以我们应该把宝贵的分析时间最先用于<strong>最重要且最难实现</strong>的场景上，即标注为**(H,H)**的场景。在质量属性效用树的表格中，仅在性能和可用性这2个质量属性下发现标注有(H,H)的场景，下面根据系统的体系结构和实现质量属性所采用的战术分别给出这些重要场景的构架方法分析表格。</p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241021193205398.png" alt="image-20241021193205398"></p><h3 id="10-6-对系统构架的再分析"><a href="#10-6-对系统构架的再分析" class="headerlink" title="10.6 对系统构架的再分析"></a>10.6 对系统构架的再分析</h3><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241021193226292.png" alt="image-20241021193226292"></p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241021193236700.png" alt="image-20241021193236700"></p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241021193244626.png" alt="image-20241021193244626"></p><h3 id="10-7-评审结论"><a href="#10-7-评审结论" class="headerlink" title="10.7 评审结论"></a>10.7 评审结论</h3><p>​         总体而言，通过对质量属性场景的分析，我们发现了最先提出的构架方案的不足，由此得出改进后的构架方案。采用改进后的构架方案可以获得了良好的性能、易用性、安全性、可用性等等，达到了设计目的符合质量属性需求分析的要求！</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241021170446600.png" alt="image-20241021170446600"></p><h2 id="真题演练"><a href="#真题演练" class="headerlink" title="真题演练"></a>真题演练</h2><h3 id="一-填空题"><a href="#一-填空题" class="headerlink" title="一 填空题"></a>一 填空题</h3><p>1.架构受什么影响 </p><p>答：客户和最终用户，开发组织，技术环境，设计师的经验</p><p>2.可用性的三个战术</p><p>错误检测（砰、回声&#x2F;心跳、异常）、错误恢复（表决、主动冗余…）、错误预防（ 进程监视器）</p><p>3.性能的三个战术</p><p>控制对资源需求（提高计算效率）、资源管理（引入并发…）、资源仲裁（调度策略）</p><p>4.评审方法分为（定性）和定量</p><p>  定性技巧—提问技巧<br>           1.<strong>场景</strong>—描述风险承担者和系统之间的具体交互<br>           2.<strong>评审清单</strong>—对同一领域的若干系统进行评估后提出的一组详细的问题<br>           3.<strong>问卷</strong>—适用于所有构架的若干问题的清单<br>        定量技巧<br>           1.<strong>指标</strong>—对构架可观察到的参数的量化解释<br>           2.<strong>模拟、原型与实验</strong></p><p>5.架构样式写四种</p><p>以数据为中心的样式、数据流样式、虚拟机样式、独立组件样式、C&#x2F;S、C2</p><p>6.架构自身的质量属性</p><p>概念完整性、正确性与完整性、可构建性</p><p>7.涉众</p><p>涉众就是对系统构建感兴趣的人或组织。如：客户、最终用户、开发人员、项目经理、维护人员、对系统进行市场营销活动的人。</p><p>8.安全性的战术</p><p><strong>检测攻击</strong></p><p>配置网络监视器来检测和记录网络事件<br>         • 误用情况的检测是把通信模式与已知攻击的历史模式进行比较。<br>         • 异常情况的检测是把通信模式与其本身的历史基线（情况）进行比较。</p><p><strong>抵抗攻击</strong><br>         • 对用户进行身份验证<br>         • 对用户进行授权<br>         • 维护数据的机密性<br>         • 维护完整性<br>         • 限制暴露的信息<br>         • 限制访问<br>         • 在外部用户和提供服务的系统之间设置认证服务器。<br>         • 把要保护的系统置于通讯防火墙之后<br>         • 在某个可信内核的基础上构建系统，由该内核提供安全</p><p><strong>从攻击中恢复</strong><br>         • 恢复状态<br>         • 识别攻击者</p><h3 id="二-简答题"><a href="#二-简答题" class="headerlink" title="二 简答题"></a>二 简答题</h3><p>1.什么是架构</p><p>在一定的设计原则基础上，从不同角度对组成系统的各部分进行搭配和安排，形成系统的多个结构而组成架构，它包括该系统的各个组件、组件的外部可见属性及组件之间的相互关系。</p><p>2.什么是架构样式</p><p><strong>构架样式（风格）</strong>—是<strong>对各组件类型和运行控制&#x2F;数据传送模式的描述</strong>。可以把构架样式看作是对构架的一组制约条件，即对各组件类型及其交互模式的限制条件，而这些制约条件就确定了一组或一系列能满足它们的构架。</p><p>3.什么是框架</p><p><strong>框架就是一组相互协作的类，对于特定的一类软件，框架构成了一种可重用的设计。</strong><br>软件框架是提取特定领域软件的共性部分形成的体系结构，不同领域的软件项目有着不同的框架类型。</p><p>4.请说明构架、框架和设计模式之间的联系和区别</p><ul><li>定义：软件框架使提取特定领域软件的共性部分形成的体系结构，不同领域的软件项目有着不同的框架类型</li><li>作用：开发过程中代码不需要从头编写，提高软件的质量，降低成本，缩短开发时间，形成良性循环</li></ul><p>1、框架和平台的关系：</p><ul><li>平台在应用层面主要指提供特定服务的系统软件</li><li>框架更侧重设计和开发过程，框架可通过调用平台提供的服务而起作用</li></ul><p>2、框架和类库的关系：</p><ul><li>框架构成了通用的、具有一般性的系统主体部分</li><li>二次开发人员根据具体业务，完成特定应用系统中与众不同的特殊部分</li></ul><p>3、框架和架构的关系：</p><ul><li>构架确定了系统整体结构、层次划分、不同部分之间的协作等设计考虑</li><li>框架更偏重于技术，确定框架后，其所对应的架构也随之确定，但在一个系统架构中可以集成多种框架</li></ul><p>4、框架和设计模式的关系：</p><ul><li>设计模式研究的是一个设计问题的解决方法，一个模式可应用于不同的框架和被不同的语言所实现</li><li>框架则是一个应用的体系结构，是一种或多种设计模式和代码的混合体</li></ul><p>共性：共同致力于使人们的设计可以被重用（设计模式的思想可以在框架设计中进行应用）</p><p>区别：</p><ul><li>从应用领域上分，框架给出的使整个应用的体系结构，而设计模式则给出了单一设计问题的解决方案</li><li>从内容上分，设计模式仅是一个单纯的设计；而框架则是设计和代码的一个混合体</li><li>设计模式比框架更容易移植</li></ul><p>5.请说明架构师的主要职责，架构师与项目经理的职责区别</p><p>架构师的职责如下：</p><ul><li>了解所在组织的业务目标，使架构更好地支持业务目标</li><li>规划产品的开发与演进</li><li>规划和建设架构级的重用，如产品线等</li><li>领导并负责架构设计，定义系统的高层结构和接口</li><li>为项目管理提供支持，如技术可行性、任务划分、人员招聘</li><li>领导和协调项目组的主要技术活动，对主要技术产品负责实际参与架构原型的开发实现</li><li>讲解架构、指导详细设计和开发、协调冲突以实现既定的构架目标</li><li>规划和协助软件架构的评审</li><li>评估新技术并提出采用建议</li></ul><p>项目经理的职责如下：</p><ul><li>具有过程控制能力</li><li>具备文档能力</li><li>总结汇报</li><li>擅长分解任务</li><li>具有时间观念</li><li>具有计划能力</li><li>具有跨界思维</li><li>有亲和力</li><li>组织协调</li></ul><p>区别</p><ol><li><strong>关注点</strong>：<ul><li><strong>架构师</strong>：侧重于系统的高层设计和技术方向，确保架构支持业务目标并具备可扩展性和可维护性。</li><li><strong>项目经理</strong>：专注于项目的管理和执行，确保项目按时、按预算完成。</li></ul></li><li><strong>职责范围</strong>：<ul><li><strong>架构师</strong>：负责架构设计、技术评估、指导详细设计，并参与架构原型的开发。</li><li><strong>项目经理</strong>：负责任务分解、进度控制、文档管理以及团队协调。</li></ul></li><li><strong>决策层级</strong>：<ul><li><strong>架构师</strong>：在技术决策和架构方向上具有更高的决策权，通常参与技术标准的制定。</li><li><strong>项目经理</strong>：在项目管理和资源分配上具有决策权，更侧重于团队和任务管理。</li></ul></li><li><strong>技能要求</strong>：<ul><li><strong>架构师</strong>：需要深厚的技术背景和架构设计能力，善于评估新技术并指导团队。</li><li><strong>项目经理</strong>：需具备良好的组织、协调能力和沟通技巧，强调过程控制和团队管理。</li></ul></li></ol><p>总体来说，架构师更多关注系统的技术设计，而项目经理则关注项目的整体管理与执行。</p><p>6.请说明架构评审的主要方法。</p><p>1、定性分析</p><p>是指凭分析者的直觉、经验，凭分析对象过去和现在的延续状况及最新的信息资料，对分析对象的性质、特点、发展变化规律作出判断的一种方法。</p><p>定性技巧——提问技巧：</p><ul><li>场景——描述风险承担者和系统之间的具体交互</li><li>评审清单——对同一领域的若干系统进行评估后提出的一组详细的问题</li><li>问卷——适用于所有构架的若干问题的清单</li></ul><p>2、定量分析</p><p>是依据实际统计数据，建立数学模型，并用数学模型计算出分析对象的各项指标及其数值的一种方法。</p><p>定量技巧：</p><ul><li>指标——对构架可观察到的参数的量化解释</li><li>模拟、原型与实验</li></ul><p>7.请说明以架构为中心的软件过程</p><p>软件过程—对软件开发活动的组织、规范和管理<br><strong>基于构架的开发步骤</strong></p><ol><li>为软件系统构建一个商业案例</li><li>弄清系统需求</li><li>构建或选用构架</li><li>正确表述此构架，并与有关各方进行交流</li><li>对此构架进行分析和评价</li><li>实现基于构架的系统并保证与构架相一致</li><li>系统维护时，构架文档应同步维护</li></ol><p>8.什么是参考模型</p><p>是一种考虑数据流的功能划分，是对已知问题的标准分解，分解所得的各个部分相互协作，构成问题的解决方案。</p><h3 id="三-判断题"><a href="#三-判断题" class="headerlink" title="三 判断题"></a>三 判断题</h3><p>略</p><h3 id="四-问答题"><a href="#四-问答题" class="headerlink" title="四 问答题"></a>四 问答题</h3><p>1.架构和设计模式的区别和联系</p><p><strong>区别</strong>：</p><ol><li><strong>范围</strong>：架构关注于系统的整体结构，包括组件的划分、模块的交互和技术选型，是高层次的设计决策；设计模式则是针对特定问题的解决方案，通常是低层次的、可复用的代码片段或结构。</li><li><strong>抽象层级</strong>：架构涉及系统的非功能性需求，如性能、安全性和可扩展性，设计模式则专注于解决特定的设计问题，如对象创建、行为或结构。</li></ol><p><strong>联系</strong>：</p><ol><li><strong>互补性</strong>：设计模式可以作为实现架构的工具，帮助在架构框架下解决特定的设计挑战。例如，一个系统架构可能会推荐使用某些设计模式来实现模块间的协作。</li><li><strong>影响性</strong>：设计模式的选择可以影响架构设计的灵活性和可维护性，而良好的架构可以使设计模式的应用更加有效和有意义。</li></ol><p>总的来说，架构提供了一个系统的整体视图，而设计模式则为实现这个视图提供了具体的实践方法。</p><p>2.架构师和项目经理有哪些可以配合的地方</p><p><strong>需求分析与目标对齐</strong>：</p><ul><li><strong>协作</strong>：架构师可以提供技术视角，帮助项目经理理解业务需求的技术实现，确保架构设计与项目目标一致。</li></ul><p><strong>规划与时间管理</strong>：</p><ul><li><strong>协作</strong>：项目经理可以根据架构师提供的技术路线图进行项目进度规划，确保各项技术实现能按时完成。</li></ul><p><strong>任务分解与资源分配</strong>：</p><ul><li><strong>协作</strong>：项目经理可以将架构师提出的架构设计转化为具体的开发任务，并合理分配资源，以保证团队的高效工作。</li></ul><p><strong>风险管理</strong>：</p><ul><li><strong>协作</strong>：架构师可以识别技术风险，项目经理则负责整体项目风险的管理与缓解策略的制定，确保项目的顺利推进。</li></ul><p><strong>技术评审与反馈</strong>：</p><ul><li><strong>协作</strong>：架构师可以参与项目经理组织的评审会议，提供技术意见，同时项目经理可以从中获取技术可行性和实施建议。</li></ul><p><strong>团队沟通与协调</strong>：</p><ul><li><strong>协作</strong>：项目经理可以促进团队之间的沟通，而架构师可以提供技术指导，确保各个团队成员在同一方向上努力。</li></ul><p><strong>变更管理</strong>：</p><ul><li><strong>协作</strong>：在项目需求变更时，架构师可以评估变更对架构的影响，而项目经理则负责管理变更过程和与利益相关者的沟通。</li></ul><p>3.什么是质量属性？描述质量属性的方法？</p><p><strong>质量属性—系统在其生命周期过程中所表现出的各种特征</strong>。</p><p>场景描述法</p><p> <strong>质量属性场景</strong>就是通过对某个实体与系统的一次交互的简要描述说明一个有关质量属性的特定需求，它由六部分组成：<br>        • <strong>刺激源</strong>：可以是风险承担者、计算机系统等。<br>        • <strong>刺激</strong>：可以看作是一个事件。<br>        • <strong>环境</strong>：系统当前的状态。<br>        • <strong>制品</strong>：系统中对事件作出反应的部分，可以是整个系统或系统的某一部分。<br>        • <strong>反应</strong>：事件到达后系统的相关行为。<br>        • <strong>反应度量</strong>：对反应结果提供某种形式的衡量。</p><p>4.在架构设计过程中，功能和质量属性的关系</p><p>在架构设计过程中，功能和质量属性之间的关系密切且复杂，主要体现在以下几个方面：</p><ol><li><strong>相互依赖</strong>：<ul><li>功能需求定义了系统必须实现的特性和行为，而质量属性（如性能、安全性、可用性等）则描述了这些功能在何种条件下提供服务。质量属性往往是实现功能的前提或基础。</li></ul></li><li><strong>权衡与折衷</strong>：<ul><li>在设计过程中，架构师常常面临功能和质量属性之间的权衡。例如，为了提高系统的性能，可能需要牺牲某些功能的复杂性，反之亦然。因此，架构师需要根据业务需求和用户期望进行合理的折衷。</li></ul></li><li><strong>影响设计选择</strong>：<ul><li>功能需求的性质可以影响质量属性的设计。例如，如果一个系统需要高并发处理功能，架构师必须考虑如何设计以满足性能要求，同时确保数据一致性和安全性。</li></ul></li><li><strong>验证与评估</strong>：<ul><li>功能和质量属性在测试阶段同样重要。功能测试确保系统按预期工作，而质量属性测试（如压力测试、安全性测试）则确保系统在不同条件下的可靠性和稳定性。</li></ul></li><li><strong>架构演化</strong>：<ul><li>随着系统的演化，功能需求可能会发生变化，质量属性也需要相应调整。因此，架构设计需要具备一定的灵活性，以便在未来适应新的功能需求和质量要求。</li></ul></li></ol><p>5.架构师的沟通能力是很重要的为什么</p><p>开发组织的开发团队的经验对设计师有影响，从而间接影响架构。</p><p><strong>跨团队协调</strong>：架构师需要与开发、测试、运维等多个团队协作，清晰的沟通能确保各方理解架构设计及其实现。</p><p><strong>需求澄清</strong>：与业务方和项目经理沟通可以帮助架构师更准确地理解需求，从而设计出更符合业务目标的系统架构。</p><p><strong>技术指导</strong>：架构师需要向团队成员传达技术决策和设计理念，良好的沟通能力能帮助他们有效理解和执行架构设计。</p><p><strong>冲突解决</strong>：在项目中可能会出现技术争议或团队间的意见分歧，架构师需要通过沟通来协调解决，维护团队的合作氛围。</p><p><strong>技术评审与反馈</strong>：在技术评审中，架构师需要清晰表达自己的观点，并能有效接纳和整合他人的意见，促进架构的不断优化。</p><p><strong>影响力</strong>：良好的沟通能力可以增强架构师在组织中的影响力，帮助推动技术变革和架构决策的实施。</p><p>6.为什么需求和架构模式要相互迭代</p><p>软件的架构不是静止的</p><ol><li>软件在开发过程中或交付使用后，都可能会发生修改，这些修改往往涉及到架构的变更。因此软件版本的演进也是软件架构的演进。 </li><li>软件架构影响设计师的经验。</li><li>软件架构影响开发组织的内部结构和经营目标。</li><li>软件架构可能会影响客户对下个系统的需求</li><li>有些系统甚至会影响并实际改变软件工程的发展，以及开发人员学习和实践的技术环境，如互联网、嵌入式、手机等。</li></ol><h3 id="五"><a href="#五" class="headerlink" title="五"></a>五</h3><p>从售票系统，选课系统等实验做的四个项目选一个回答以下问题</p><p>1.项目背景</p><p>购票系统旨在为用户提供便捷、高效的火车票购票服务，支持在线查询、预订、支付和退票等功能。随着用户需求的增加和在线购票的普及，系统需要处理高并发请求，并保证交易安全和用户数据隐私。</p><p>2.质量属性优先级和画两个质量场景图</p><p>高优先级：性能、安全性、可用性、易用性</p><p>低优先级：可维护性、可修改性、可移植性</p><p>3.ADD设计方法并进行第一步分解</p><p><strong>识别主要功能</strong>：</p><ul><li>用户登录&#x2F;注册</li><li>查询余票</li><li>购票操作</li><li>支付处理</li><li>订单管理</li></ul><p><strong>确定关键质量属性</strong>：</p><ul><li>针对每个功能，分析其对质量属性的影响，特别关注性能和安全性。</li></ul><p>4.生成质量属性效用树</p><p>质量属性、属性求精、场景编号、场景</p><p>5.选一个属性进行战术评审</p><p>安全性</p><p><strong>战术</strong>：采用HTTPS协议对数据传输进行加密，确保用户信息在网络传输中的安全性。</p><p><strong>数据泄露风险</strong>：</p><ul><li>敏感用户数据（如个人身份信息、支付信息）的存储和传输过程中的保护。</li></ul><p><strong>选择加密算法</strong>：</p><ul><li>需评估所选加密算法的强度及其对系统性能的影响，确保不会引入安全隐患或导致性能瓶颈。</li></ul><h3 id="六"><a href="#六" class="headerlink" title="六"></a>六</h3><p>12306有哪些架构模式和战术有利于购票？你能给出什么改进建议</p><p>架构模式</p><ol><li><strong>微服务架构</strong>：将不同功能（如用户管理、订单处理、支付等）拆分为独立的服务，提高了系统的灵活性和可维护性。</li><li><strong>事件驱动架构</strong>：通过事件通知机制，实时处理购票请求，提高系统响应速度。</li><li><strong>分布式架构</strong>：采用分布式系统来应对高并发请求，确保系统的可用性和稳定性。</li></ol><p>战术</p><ol><li><strong>缓存策略</strong>：使用缓存机制减少数据库访问，提高系统性能，尤其是在高峰期。</li><li><strong>负载均衡</strong>：通过负载均衡器分配用户请求，优化资源使用，防止单点故障。</li><li><strong>限流和熔断</strong>：在高并发情况下限制请求速率，保护后端系统免受冲击。</li></ol><p>改进建议</p><ol><li><strong>优化用户体验</strong>：引入智能推荐系统，根据用户历史行为和偏好推荐车票，提升购票体验。</li><li><strong>增强实时性</strong>：利用实时数据分析，预测购票高峰期并提前做出系统扩容，以应对突发流量。</li><li><strong>完善支付流程</strong>：提供更多支付方式和分期付款选项，减少用户在支付环节的流失。</li><li><strong>用户反馈机制</strong>：建立有效的用户反馈渠道，及时收集和处理用户在购票过程中的问题和建议。</li></ol>]]></content>
    
    
    <categories>
      
      <category>考试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件体系结构</tag>
      
      <tag>考试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MarsCode-多米诺骨牌</title>
    <link href="/2024/10/14/MarsCode-%E5%A4%9A%E7%B1%B3%E8%AF%BA%E9%AA%A8%E7%89%8C/"/>
    <url>/2024/10/14/MarsCode-%E5%A4%9A%E7%B1%B3%E8%AF%BA%E9%AA%A8%E7%89%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>多米诺骨牌游戏规则非常简单，将骨牌按一定间距的尺寸排成单行，或分行排成一片。推倒第一张骨牌，其余发生连锁反应依次倒下，或形成一条长龙，或形成一幅图案。</p><p>小 A 觉得多米诺骨牌超级没意思，所以他想了点小花招。</p><p>小 A 将 n 个多米诺骨牌放在一条线上，每一块都垂直竖立。他同时将一些骨牌向左或向右推倒。注意：不会出现连续向左或者向右推的情况。 每过一秒，被推向左边或右边的骨牌会将左边或右边的相邻骨牌推倒。当一个骨牌，其左边倒向它的骨牌数目与其右边倒向它的骨牌数目相等时，由于力的平衡，该骨牌将依然保持竖立。</p><p>给定小 A 最初推骨牌的方向，求出最后依然保持竖立的骨牌数目和位置。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入数据第一行包括一个整数 n（1≤n≤3000），表示这一行多米诺骨牌的数目。下一行包括一个长度为 n 的字符串，字符串的第 i 个字符意义如下：</p><p>“L”，第 i 个字符将要被向左推。</p><p>“R”，第 i 个字符将要被向右推。</p><p>“.”，第 i 个字符不会被推。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>首先输出保持竖立的骨牌数目。如果保持竖立的骨牌数目不为 0，下一行输出保持竖立的骨牌的位置，骨牌位置从 1 到 n。</p><p>每两个数之间用一个空格隔开，注意最后一个数后面没有空格。</p><p><strong>输入样例</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">14<br><br>.L.R...LR..L..<br><br>5<br><br>R....<br><br>1<br><br>.<br></code></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">4<br><br>3 6 13 14<br><br>0<br><br>1<br><br>1<br></code></pre></td></tr></table></figure><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">solution</span>(<span class="hljs-params">num, data</span>):<br>    <span class="hljs-comment"># Please write your code here</span><br>    ans = []<br>    <span class="hljs-comment"># 状态数组，左为负，右为正</span><br>    weight = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num)]<br>    <span class="hljs-comment"># 初始化</span><br>    <span class="hljs-keyword">for</span> i, state <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(data):<br>        <span class="hljs-keyword">if</span> state == <span class="hljs-string">&#x27;L&#x27;</span>:<br>            weight[i] = -<span class="hljs-number">1</span><br>        <span class="hljs-keyword">elif</span> state == <span class="hljs-string">&#x27;R&#x27;</span>:<br>            weight[i] = <span class="hljs-number">1</span><br>    <span class="hljs-comment"># 得出num天的状态</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, num):<br>        <span class="hljs-keyword">for</span> obj <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, num):<br>            <span class="hljs-comment"># 右倾倒</span><br>            <span class="hljs-keyword">if</span> weight[obj] == i <span class="hljs-keyword">and</span> obj != num-<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> weight[obj+<span class="hljs-number">1</span>] == <span class="hljs-number">0</span>:<br>                weight[obj+<span class="hljs-number">1</span>] = i+<span class="hljs-number">1</span><br>            <span class="hljs-comment"># 左倾倒</span><br>            <span class="hljs-keyword">elif</span> weight[obj] == -i <span class="hljs-keyword">and</span> obj != <span class="hljs-number">0</span>:<br>                <span class="hljs-comment"># 相同数量右倾倒和左倾倒，力平衡</span><br>                <span class="hljs-keyword">if</span> weight[obj-<span class="hljs-number">1</span>] != <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> weight[obj-<span class="hljs-number">1</span>] == i+<span class="hljs-number">1</span>:<br>                    weight[obj-<span class="hljs-number">1</span>] = <span class="hljs-number">0</span><br>                <span class="hljs-keyword">elif</span> weight[obj-<span class="hljs-number">1</span>] == <span class="hljs-number">0</span>:<br>                    weight[obj-<span class="hljs-number">1</span>] = -i-<span class="hljs-number">1</span><br>    <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num):<br>        <span class="hljs-keyword">if</span> weight[i] == <span class="hljs-number">0</span>:<br>            ans.append(i+<span class="hljs-number">1</span>)<br>    <br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(ans) == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0&quot;</span><br>    result = <span class="hljs-built_in">str</span>(<span class="hljs-built_in">len</span>(ans))+<span class="hljs-string">&quot;:&quot;</span><br>    result += <span class="hljs-string">&quot;,&quot;</span>.join(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">str</span>, ans))<br>    <span class="hljs-keyword">return</span> result<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-comment">#  You can add more test cases here</span><br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">14</span>, <span class="hljs-string">&quot;.L.R...LR..L..&quot;</span>) == <span class="hljs-string">&quot;4:3,6,13,14&quot;</span> )<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">5</span>, <span class="hljs-string">&quot;R....&quot;</span>) == <span class="hljs-string">&quot;0&quot;</span> )<br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;.&quot;</span>) == <span class="hljs-string">&quot;1:1&quot;</span> )<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>MarsCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>循环</tag>
      
      <tag>模拟</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MarsCode-徒步</title>
    <link href="/2024/10/13/MarsCode-%E5%BE%92%E6%AD%A5/"/>
    <url>/2024/10/13/MarsCode-%E5%BE%92%E6%AD%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>小明想从A徒步到B，总路程需要M天，路程中为了确保安全，小明每天需要消耗1份食物。  </p><p>在起点及路程当中，零星分布着N个补给站，可以补充食物，不同补给站的食物价格可能不同。  </p><p>请问小明若要安全完成徒步，最少需要花费多少钱呢？</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行为两个正整数<code>M</code>、<code>N</code>，代表总路程<code>M</code>天，补给站个数<code>N</code>   </p><p>接下来<code>N</code>行，每行有两个非负整数<code>A</code>、<code>B</code>代表一个补给站，表示第<code>A</code>天经过该补给站，每份食物的价格为<code>B</code>元。  </p><p><code>A</code>是从0开始严格递增的，即起点一定有补给站，补给站是按位置顺序给出的，且同一个位置最多有一个补给站。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一个整数，表示最少花费的金额</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">5 4  <br>0 2  <br>1 3  <br>2 1  <br>3 2  <br></code></pre></td></tr></table></figure><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">7<br></code></pre></td></tr></table></figure><p>说明：在第0天买2份食物，在第2天买3份食物，共花费7元</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h2><p>- 30%的数据，<code>N &lt;= M &lt;= 100</code>， <code>0 &lt;= A &lt; M</code>， <code>0 &lt;= B &lt;= 1000</code></p><p>- 80%的数据，<code>N &lt;= M &lt;= 10000</code>， <code>0 &lt;= A &lt; M</code>， <code>0 &lt;= B &lt;= 1000</code></p><p>- 100%的数据，<code>N &lt;= M &lt;= 1000000</code>， <code>0 &lt;= A &lt; M</code>， <code>0 &lt;= B &lt;= 1000</code></p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>采用动态规划求解<br>$$<br>dp[day][food] &#x3D;min{dp[day-1][food+1], dp[day-1][food]+price, dp[day-1][food-1]+price*2 + …}<br>$$<br>Python代码求解如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">solution</span>(<span class="hljs-params">n, k, p</span>):<br>    <span class="hljs-comment"># Edit your code here</span><br>    dp = [[<span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n+<span class="hljs-number">2</span>)] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n+<span class="hljs-number">2</span>)]<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n+<span class="hljs-number">1</span>):<br>        dp[<span class="hljs-number">0</span>][i] = <span class="hljs-number">0</span><br>    <span class="hljs-comment"># 若第1天有补给站，购买起始物资</span><br>    <span class="hljs-keyword">if</span> p[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">for</span> food <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n+<span class="hljs-number">1</span>):<br>            dp[<span class="hljs-number">1</span>][food] = food * p[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]<br>    <span class="hljs-comment"># 第2天到第n天</span><br>    <span class="hljs-keyword">for</span> day <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, n+<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">for</span> food <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n+<span class="hljs-number">1</span>):<br>            flag = <span class="hljs-number">0</span><br>            <span class="hljs-comment"># 遇到补给站</span><br>            <span class="hljs-keyword">for</span> station_day, station_price <span class="hljs-keyword">in</span> p:<br>                <span class="hljs-keyword">if</span> day == station_day+<span class="hljs-number">1</span>:<br>                    flag = <span class="hljs-number">1</span><br>                    <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(food+<span class="hljs-number">1</span>):<br>                        dp[day][food] = <span class="hljs-built_in">min</span>(dp[day][food], dp[day-<span class="hljs-number">1</span>][food-num+<span class="hljs-number">1</span>]+num * station_price)<br>            <span class="hljs-comment"># 无补给站</span><br>            <span class="hljs-keyword">if</span> flag == <span class="hljs-number">0</span>:<br>                dp[day][food] = dp[day-<span class="hljs-number">1</span>][food+<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">return</span> dp[n][<span class="hljs-number">1</span>]<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-comment"># Add your test cases here</span><br><br>    <span class="hljs-built_in">print</span>(solution(<span class="hljs-number">5</span>, <span class="hljs-number">4</span>, [[<span class="hljs-number">0</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">2</span>]]) == <span class="hljs-number">7</span>)<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>MarsCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>简单</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python二维数组定义(List)问题</title>
    <link href="/2024/10/06/Python%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E5%AE%9A%E4%B9%89(List)%E9%97%AE%E9%A2%98/"/>
    <url>/2024/10/06/Python%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E5%AE%9A%E4%B9%89(List)%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="Python二维数组定义-List-问题"><a href="#Python二维数组定义-List-问题" class="headerlink" title="Python二维数组定义(List)问题"></a>Python二维数组定义(List)问题</h1><h2 id="问题所在"><a href="#问题所在" class="headerlink" title="问题所在"></a>问题所在</h2><p>采用如下定义出现问题：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">n = <span class="hljs-number">5</span><br>dp = [[<span class="hljs-number">0</span>] * n] * n<br>dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br><span class="hljs-built_in">print</span>(dp)<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">[[1, 0, 0, 0, 0],<br> [1, 0, 0, 0, 0],<br> [1, 0, 0, 0, 0],<br> [1, 0, 0, 0, 0],<br> [1, 0, 0, 0, 0]]<br></code></pre></td></tr></table></figure><p>在改变<code>dp[0][0]</code>时把<code>dp[i][0]</code>都改变了。即每一行的改变都会改变其他行</p><h2 id="修改后"><a href="#修改后" class="headerlink" title="修改后"></a>修改后</h2><p>正确定义为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">n = <span class="hljs-number">5</span><br>dp = [[<span class="hljs-number">0</span>] * n <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br><span class="hljs-built_in">print</span>(dp)<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">[[1, 0, 0, 0, 0],<br> [0, 0, 0, 0, 0],<br> [0, 0, 0, 0, 0],<br> [0, 0, 0, 0, 0],<br> [0, 0, 0, 0, 0]]<br></code></pre></td></tr></table></figure><h2 id="问题探究"><a href="#问题探究" class="headerlink" title="问题探究"></a>问题探究</h2><ul><li>直接赋值：其实就是对象的引用（别名）。</li><li>浅拷贝(copy)：拷贝父对象，不会拷贝对象的内部的子对象。</li><li>深拷贝(deepcopy)： copy 模块的 deepcopy 方法，完全拷贝了父对象及其子对象。</li></ul>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>List</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pandas库特定无法使用某些函数的问题</title>
    <link href="/2024/05/18/%E8%A7%A3%E5%86%B3read_json%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98/"/>
    <url>/2024/05/18/%E8%A7%A3%E5%86%B3read_json%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="解决的问题AttributeError-partially-initialized-module-‘pandas’-has-no-attribute-‘read-json’-most-likely-due-to-a-circular-import"><a href="#解决的问题AttributeError-partially-initialized-module-‘pandas’-has-no-attribute-‘read-json’-most-likely-due-to-a-circular-import" class="headerlink" title="解决的问题AttributeError: partially initialized module ‘pandas’ has no attribute ‘read_json’ (most likely due to a circular import)"></a>解决的问题AttributeError: partially initialized module ‘pandas’ has no attribute ‘read_json’ (most likely due to a circular import)</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pandas<br><br>df = pandas.read_json(<span class="hljs-string">&#x27;Test/sites.json&#x27;</span>)<br><br><span class="hljs-built_in">print</span>(df.to_string())<br></code></pre></td></tr></table></figure><p>在运行过程中遇到如下报错：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">AttributeError: partially initialized module <span class="hljs-string">&#x27;pandas&#x27;</span> has no attribute <span class="hljs-string">&#x27;read_json&#x27;</span> (most likely due to a circular import)<br></code></pre></td></tr></table></figure><p>解决方法：</p><p><strong>检查其他模块的名称</strong>: 如果你有其他自定义模块或第三方模块的名称与pandas相似，可能会导致导入冲突。请确保没有其他模块干扰pandas的导入。如此处我命名该文件为json.py，即干扰了函数read_joson的使用。</p><p>其他函数如read_csv也适用。</p>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>pandas</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NOIP2003-普及组 栈</title>
    <link href="/2024/03/27/NOIP2003%20%E6%99%AE%E5%8F%8A%E7%BB%84-%E6%A0%88/"/>
    <url>/2024/03/27/NOIP2003%20%E6%99%AE%E5%8F%8A%E7%BB%84-%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<h1 id="NOIP2003-普及组-栈"><a href="#NOIP2003-普及组-栈" class="headerlink" title="[NOIP2003 普及组] 栈"></a>[NOIP2003 普及组] 栈</h1><h2 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h2><p>栈是计算机中经典的数据结构，简单的说，栈就是限制在一端进行插入删除操作的线性表。</p><p>栈有两种最重要的操作，即 pop（从栈顶弹出一个元素）和 push（将一个元素进栈）。</p><p>栈的重要性不言自明，任何一门数据结构的课程都会介绍栈。宁宁同学在复习栈的基本概念时，想到了一个书上没有讲过的问题，而他自己无法给出答案，所以需要你的帮忙。</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/5qxy9fz2.png"></p><p>宁宁考虑的是这样一个问题：一个操作数序列，$1,2,\ldots ,n$（图示为 1 到 3 的情况），栈 A 的深度大于 $n$。</p><p>现在可以进行两种操作，</p><ol><li>将一个数，从操作数序列的头端移到栈的头端（对应数据结构栈的 push 操作）</li><li>将一个数，从栈的头端移到输出序列的尾端（对应数据结构栈的 pop 操作）</li></ol><p>使用这两种操作，由一个操作数序列就可以得到一系列的输出序列，下图所示为由 <code>1 2 3</code> 生成序列 <code>2 3 1</code> 的过程。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/8uwv2pa2.png"></p><p>（原始状态如上图所示）</p><p>你的程序将对给定的 $n$，计算并输出由操作数序列 $1,2,\ldots,n$ 经过操作可能得到的输出序列的总数。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入文件只含一个整数 $n$（$1 \leq n \leq 18$）。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出文件只有一行，即可能输出序列的总数目。</p><h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">3<br></code></pre></td></tr></table></figure><h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">5<br></code></pre></td></tr></table></figure><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p><strong>【题目来源】</strong></p><p>NOIP 2003 普及组第三题</p><h2 id="解答1（递归求解，超时）"><a href="#解答1（递归求解，超时）" class="headerlink" title="解答1（递归求解，超时）"></a>解答1（递归求解，超时）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n;<br><br><span class="hljs-comment">//栈外总数，栈内总数 </span><br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">count</span><span class="hljs-params">(<span class="hljs-type">int</span> num,<span class="hljs-type">int</span> stack_num)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(stack_num &lt; <span class="hljs-number">0</span> || num &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br><span class="hljs-keyword">if</span>(num == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">count</span>(num<span class="hljs-number">-1</span>,stack_num+<span class="hljs-number">1</span>) + <span class="hljs-built_in">count</span>(num,stack_num<span class="hljs-number">-1</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin&gt;&gt;n;<br>cout&lt;&lt;<span class="hljs-built_in">count</span>(n,<span class="hljs-number">0</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="解答2（备忘录方法）"><a href="#解答2（备忘录方法）" class="headerlink" title="解答2（备忘录方法）"></a>解答2（备忘录方法）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> memo[<span class="hljs-number">20</span>][<span class="hljs-number">20</span>];<br><br><span class="hljs-comment">//栈外总数，栈内总数 </span><br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">count</span><span class="hljs-params">(<span class="hljs-type">int</span> num,<span class="hljs-type">int</span> stack_num)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(memo[num][stack_num]) <span class="hljs-keyword">return</span> memo[num][stack_num];<br> <br><span class="hljs-keyword">if</span>(num == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(stack_num &gt; <span class="hljs-number">0</span>) memo[num][stack_num] += <span class="hljs-built_in">count</span>(num,stack_num<span class="hljs-number">-1</span>);<br>memo[num][stack_num] += <span class="hljs-built_in">count</span>(num<span class="hljs-number">-1</span>,stack_num+<span class="hljs-number">1</span>) ;<br><span class="hljs-keyword">return</span> memo[num][stack_num];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin&gt;&gt;n;<br>cout&lt;&lt;<span class="hljs-built_in">count</span>(n,<span class="hljs-number">0</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>洛谷</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>递归</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一道关于双曲函数与三角函数的复变函数题</title>
    <link href="/2023/11/15/%E4%B8%80%E9%81%93%E5%85%B3%E4%BA%8E%E5%8F%8C%E6%9B%B2%E5%87%BD%E6%95%B0%E4%B8%8E%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0%E7%9A%84%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0%E9%A2%98/"/>
    <url>/2023/11/15/%E4%B8%80%E9%81%93%E5%85%B3%E4%BA%8E%E5%8F%8C%E6%9B%B2%E5%87%BD%E6%95%B0%E4%B8%8E%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0%E7%9A%84%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>$$<br>判断\overline{\cos z} &#x3D; \cos{\overline{z}}是否成立<br>$$</p><p>$$<br>{\cos z} &#x3D; \cos x \cos iy - \sin x \sin iy<br>&#x3D;\cos x\cosh y - i \sin x \sinh y<br>$$</p><p>$$<br>\overline{\cos z}&#x3D;\cos x\cosh y + i \sin x \sinh y<br>$$</p><p>$$<br>\cos {\overline z} &#x3D;\cos x \cos iy + \sin x \sin iy<br>&#x3D;\cos x\cosh y + i \sin x \sinh y<br>$$</p><p>$$<br>所以\overline{\cos z} &#x3D; \cos{\overline{z}}成立<br>$$</p><p>所用到的公式为双曲函数与三角函数的关系<br>$$<br>\sinh z &#x3D; \frac{e^z-e^{-z}}{2}，\<br>\cosh z &#x3D; \frac{e^z+e^{-z}}{2}，\<br>\sin z &#x3D; \frac{e^{iz}-e^{-iz}}{2i}，\<br>\cos z &#x3D; \frac{e^{iz}+e^{-iz}}{2}，\<br>$$</p><p>$$<br>\sinh z &#x3D; -i\sin iz，\<br>\cosh z &#x3D; \cos iz<br>$$</p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>后缀表达式</title>
    <link href="/2023/10/06/%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2023/10/06/%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="后缀表达式"><a href="#后缀表达式" class="headerlink" title="后缀表达式"></a>后缀表达式</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>所谓后缀表达式是指这样的一个表达式：式中不再引用括号，运算符号放在两个运算对象之后，所有计算按运算符号出现的顺序，严格地由左而右新进行（不用考虑运算符的优先级）。</p><p>如：$\texttt{3*(5-2)+7}$ 对应的后缀表达式为：$\texttt{3.5.2.-*7.+@}$。在该式中，<code>@</code> 为表达式的结束符号。<code>.</code> 为操作数的结束符号。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入一行一个字符串 $s$，表示后缀表达式。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一个整数，表示表达式的值。</p><h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">3</span>.<span class="hljs-number">5</span>.<span class="hljs-number">2</span>.-*<span class="hljs-number">7</span>.+@<br></code></pre></td></tr></table></figure><h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">16<br></code></pre></td></tr></table></figure><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>数据保证，$1 \leq |s| \leq 50$，答案和计算过程中的每一个值的绝对值不超过 $10^9$。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>利用栈将操作数存储下来，由于不用考虑操作符优先级，于是遇到操作符就进行一次操作，并将完成操作后的操作数压栈，最终栈中只剩下一个操作数，即后缀表达式的运算结果。</p><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">char</span> a[<span class="hljs-number">55</span>];<br>cin &gt;&gt; a;<br><span class="hljs-type">int</span> stk[<span class="hljs-number">50</span>] = &#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-comment">//利用栈储存操作数 </span><br><span class="hljs-type">int</span> top = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; a[i] != <span class="hljs-string">&#x27;@&#x27;</span>; i ++)<br>&#123;<br><span class="hljs-comment">// 读取操作数并压栈 </span><br><span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(a[i] &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; a[i] &lt;= <span class="hljs-string">&#x27;9&#x27;</span>)<br>&#123;<br>num = num * <span class="hljs-number">10</span> + a[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>i ++;<br>&#125;<br><span class="hljs-keyword">if</span>(a[i] == <span class="hljs-string">&#x27;.&#x27;</span>) stk[top++] = num;<br><span class="hljs-comment">//读取操作符并计算 </span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a[i] == <span class="hljs-string">&#x27;-&#x27;</span>)<br>&#123;<br><span class="hljs-type">int</span> num2 = stk[--top];<span class="hljs-comment">//减数 </span><br><span class="hljs-type">int</span> num1 = stk[--top];<span class="hljs-comment">//被减数</span><br>stk[top++] = num1 - num2;  <br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a[i] == <span class="hljs-string">&#x27;+&#x27;</span>)<br>&#123;<br><span class="hljs-type">int</span> num2 = stk[--top]; <br><span class="hljs-type">int</span> num1 = stk[--top];<br>stk[top++] = num1 + num2; <br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a[i] == <span class="hljs-string">&#x27;*&#x27;</span>)<br>&#123;<br><span class="hljs-type">int</span> num2 = stk[--top]; <br><span class="hljs-type">int</span> num1 = stk[--top];<br>stk[top++] = num1 * num2; <br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a[i] == <span class="hljs-string">&#x27;/&#x27;</span>)<br>&#123;<br><span class="hljs-type">int</span> num2 = stk[--top]; <span class="hljs-comment">//除数 </span><br><span class="hljs-type">int</span> num1 = stk[--top]; <span class="hljs-comment">//被除数 </span><br>stk[top++] = num1 / num2; <br>&#125;<br>&#125;<br>ans = stk[<span class="hljs-number">0</span>];<br>cout &lt;&lt; ans &lt;&lt; endl; <br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>洛谷</category>
      
    </categories>
    
    
    <tags>
      
      <tag>模拟</tag>
      
      <tag>每日一题</tag>
      
      <tag>字符串</tag>
      
      <tag>栈</tag>
      
      <tag>线性数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>N皇后问题</title>
    <link href="/2023/08/31/N%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/"/>
    <url>/2023/08/31/N%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>N皇后问题研究的是如何将 N 个皇后放置在 N×N 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p>递归算法求解</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">char</span> Queenspos[<span class="hljs-number">100</span>]=&#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-comment">//记录皇后的位置</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">NQueen</span><span class="hljs-params">( <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>( k == n) &#123;<span class="hljs-comment">//n行已经摆好，输出结果 </span><br><span class="hljs-type">int</span> i;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span> ; i &lt; n ;i ++)<span class="hljs-comment">//输出n皇后的位置 </span><br>&#123;<br>cout&lt;&lt;Queenspos[i]+<span class="hljs-number">1</span>&lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>&#125;<br>cout &lt;&lt; endl ;<br><span class="hljs-keyword">return</span> ;<br>&#125;<br><span class="hljs-type">int</span> i;<br><span class="hljs-keyword">for</span>( i = <span class="hljs-number">0</span>; i &lt; n ; i ++)&#123;<span class="hljs-comment">//0~k-1行已经摆好，尝试第k行的列位置 </span><br><span class="hljs-type">int</span> flag = <span class="hljs-literal">true</span> ;<br><span class="hljs-keyword">for</span> ( <span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j &lt; k ; j ++) &#123;<br><span class="hljs-keyword">if</span> ( Queenspos[j] == i || <span class="hljs-built_in">abs</span>(Queenspos[j] - i) == (<span class="hljs-built_in">abs</span>(k - j)) ) &#123;<span class="hljs-comment">//不满足条件 </span><br>flag = <span class="hljs-literal">false</span> ;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>( flag ) &#123;<br>Queenspos[k] = i ;  <br><span class="hljs-built_in">NQueen</span>( k+<span class="hljs-number">1</span> , n) ;<span class="hljs-comment">//满足条件，尝试下一行 </span><br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> n;<br>cin&gt;&gt;n;<span class="hljs-comment">//n皇后 </span><br><span class="hljs-built_in">NQueen</span>(<span class="hljs-number">0</span> , n);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>递归</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汉诺塔问题递归求解</title>
    <link href="/2023/08/31/%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98%E9%80%92%E5%BD%92%E6%B1%82%E8%A7%A3/"/>
    <url>/2023/08/31/%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98%E9%80%92%E5%BD%92%E6%B1%82%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>问题描述：给定三根柱子，记为 ‘A’,’B’,’C’ ，其中 A柱子上有 B个盘子，从上到下编号为 0 到 N−1 ，且上面的盘子一定比下面的盘子小。问：将 A 柱上的盘子经由B柱移动到C柱最少需要多少次？</p><p> 移动时应注意：</p><p>  ① 一次只能移动一个盘子</p><p>  ②大的盘子不能压在小盘子上</p><p>递归算法求解：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Honoi</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">char</span> first, <span class="hljs-type">char</span> second, <span class="hljs-type">char</span> third, <span class="hljs-type">int</span> &amp;num)</span></span>&#123;<br><span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span> ) &#123;<br>cout &lt;&lt; first &lt;&lt; <span class="hljs-string">&quot; -&gt; &quot;</span> &lt;&lt; third &lt;&lt; endl ;<span class="hljs-comment">//只有一个盘子 </span><br>num++;<br><span class="hljs-keyword">return</span> ;<br>&#125;<br><span class="hljs-built_in">Honoi</span>(n<span class="hljs-number">-1</span> , first , third , second, num);<span class="hljs-comment">//将n-1个盘子先移到second </span><br>cout &lt;&lt; first &lt;&lt; <span class="hljs-string">&quot; -&gt; &quot;</span> &lt;&lt; third &lt;&lt; endl;<span class="hljs-comment">//再将一个盘子移到third </span><br>num++;<br><span class="hljs-built_in">Honoi</span>(n<span class="hljs-number">-1</span> , second , first , third, num);<span class="hljs-comment">//再将剩下的n-1个盘子从second移到third </span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> n;<br>cin &gt;&gt; n;<span class="hljs-comment">//盘子数目</span><br><span class="hljs-type">int</span> num=<span class="hljs-number">0</span>;<span class="hljs-comment">//用来计算移动次数 </span><br><span class="hljs-built_in">Honoi</span>(n , <span class="hljs-string">&#x27;A&#x27;</span> , <span class="hljs-string">&#x27;B&#x27;</span> , <span class="hljs-string">&#x27;C&#x27;</span>, num);<br>cout &lt;&lt; <span class="hljs-string">&quot;一共用了&quot;</span> &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot;次&quot;</span>; <br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>递归</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STL之map</title>
    <link href="/2023/08/26/STL%E4%B9%8Bmap/"/>
    <url>/2023/08/26/STL%E4%B9%8Bmap/</url>
    
    <content type="html"><![CDATA[<h3 id="map的用法"><a href="#map的用法" class="headerlink" title="map的用法"></a>map的用法</h3><p>和multimap的区别在于：</p><ul><li>不能有关键字重复的元素</li><li>可以使用<code>[]</code>，下标为关键字，返回值为first和关键字相同的元素的second</li><li>插入元素可能失败</li></ul><h3 id="应用举例：单词词频统计程序"><a href="#应用举例：单词词频统计程序" class="headerlink" title="应用举例：单词词频统计程序"></a>应用举例：单词词频统计程序</h3><p>输入大量单词，每个单词，一行，不超过20个字符，没有空格。(验证发现可以直接输入，程序会以空格或换行来检测一个单词输入的结束)按出现次数从多到少输出这些单词及其出现次数。出现次数相同的，字典序靠前的在前面。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Word</span> &#123;<br><span class="hljs-type">int</span> times;<br>string wd;<br>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Rule</span> &#123;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span> <span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-type">const</span> Word &amp; w1, <span class="hljs-type">const</span> Word &amp; w2)</span> <span class="hljs-type">const</span> </span>&#123;<br><span class="hljs-keyword">if</span>( w1.times != w2.times)<br>&#123;<br><span class="hljs-keyword">return</span> w1.times &gt; w2.times;<span class="hljs-comment">//优先按次数排序 </span><br>&#125;<br><span class="hljs-keyword">else</span> <br><span class="hljs-keyword">return</span> w1.wd &lt; w2.wd;<span class="hljs-comment">//次数相同，按名称字典序排序 </span><br>&#125;<br>&#125;; <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>string s;<br>set&lt; Word, Rule &gt; st;<br>map&lt; string,<span class="hljs-type">int</span> &gt; mp;<br><span class="hljs-keyword">while</span>(cin &gt;&gt; s) &#123;<span class="hljs-comment">//ctrl+z结束循环 </span><br>++mp[s];<span class="hljs-comment">//如果s已存在mp中，则mp[s]返回值为次数，再进行++；如果还未存在，则创建该元素mp[s],再将返回值次数++</span><br>&#125;<br><span class="hljs-keyword">for</span>( map&lt;string,<span class="hljs-type">int</span>&gt;::iterator i = mp.<span class="hljs-built_in">begin</span>(); i!= mp.<span class="hljs-built_in">end</span>() ;i++)&#123;<span class="hljs-comment">//将mp中的元素复制到st中，进行自动排序 </span><br>Word temp;<br>temp.wd = i-&gt;first;<br>temp.times = i-&gt;second;<br>st.<span class="hljs-built_in">insert</span>(temp);<br>&#125;<br><span class="hljs-keyword">for</span>(set&lt;Word,Rule&gt;::iterator i =st.<span class="hljs-built_in">begin</span>(); i != st.<span class="hljs-built_in">end</span>(); i++)&#123;<br>cout&lt;&lt;i-&gt;wd &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>&lt;&lt;i-&gt;times &lt;&lt;endl;<br>&#125; <br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STL之multimap</title>
    <link href="/2023/08/26/STL%E4%B9%8Bmultimap/"/>
    <url>/2023/08/26/STL%E4%B9%8Bmultimap/</url>
    
    <content type="html"><![CDATA[<h3 id="multimap的用法"><a href="#multimap的用法" class="headerlink" title="multimap的用法"></a>multimap的用法</h3><p>multimap容器里的元素，都是pair形式的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">multimap</span>&lt;T1,T2&gt; mp;<br></code></pre></td></tr></table></figure><p>则mp里的元素都是如下类型的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> &#123;<br>T1 first; <span class="hljs-comment">//关键字</span><br>T2 second; <span class="hljs-comment">//值</span><br>&#125;<br></code></pre></td></tr></table></figure><p>multimap中的元素按照first进行排序，并可以按first进行查找</p><p>**缺省的排序规则是<code>a.first &lt; b.first</code>**时为<code>true</code>,则a排在b前面</p><h3 id="multimap的应用"><a href="#multimap的应用" class="headerlink" title="multimap的应用"></a>multimap的应用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;map&gt;</span><span class="hljs-comment">//使用multimap和map需要次头文件 </span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">StudentInfo</span> &#123;<br><span class="hljs-type">int</span> id;<br><span class="hljs-type">char</span> name[<span class="hljs-number">20</span>];<br>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Student</span> &#123;<br><span class="hljs-type">int</span> score;<br>StudentInfo info;<br>&#125;;<br><span class="hljs-keyword">typedef</span> multimap&lt;<span class="hljs-type">int</span>, StudentInfo&gt; MAP_STD; <span class="hljs-comment">//取别名 </span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>MAP_STD mp;<br>Student st;<br><span class="hljs-type">char</span> cmd[<span class="hljs-number">20</span>];<br><span class="hljs-keyword">while</span>( cin &gt;&gt; cmd ) &#123;<span class="hljs-comment">//输入，根据首字母判断是Add还是Query </span><br><span class="hljs-keyword">if</span>( cmd[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;A&#x27;</span> ) &#123;<span class="hljs-comment">//Add,添加数据 </span><br>cin&gt;&gt;st.info.name &gt;&gt; st.info.id&gt;&gt; st.score;<br>mp.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(st.score, st.info));<br><span class="hljs-comment">//make_pair生成了一个pair&lt;int, StudentInfo&gt;变量，其first等于st.score,second等于st.info </span><br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( cmd[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;Q&#x27;</span>)&#123;<span class="hljs-comment">//Query,查找数据 </span><br><span class="hljs-type">int</span> score;<br>cin&gt;&gt;score;<br>MAP_STD::iterator p = mp.<span class="hljs-built_in">lower_bound</span> (score);<br><span class="hljs-keyword">if</span>( p != mp.<span class="hljs-built_in">begin</span>()) &#123;<span class="hljs-comment">//查找成功，存在比score分数低的学生 </span><br>--p;<br>score = p-&gt;first;<span class="hljs-comment">//比查询分数低的最高分 </span><br>MAP_STD::iterator maxp = p;<br><span class="hljs-type">int</span> maxId = p-&gt;second.id;<br><span class="hljs-keyword">while</span>(p!= mp.<span class="hljs-built_in">begin</span>() &amp;&amp; p-&gt;first == score)&#123;<span class="hljs-comment">//遍历所有成绩和score相等的学生 </span><br><span class="hljs-keyword">if</span>(p-&gt;second.id &gt; maxId )&#123;<span class="hljs-comment">//同分找学号最大的 </span><br>maxp = p;<br>maxId = p-&gt;second.id;<br>&#125;<br>p--;<br>&#125;<br><span class="hljs-keyword">if</span>(p-&gt;first == score)&#123;<span class="hljs-comment">//上面循环因p == mp.begin()终止，但此时p指向mp的第一个元素，仍需要进行处理 </span><br><span class="hljs-keyword">if</span>(p-&gt;second.id &gt; maxId )&#123; <br>maxp = p;<br>maxId = p-&gt;second.id;<br>&#125;<br>&#125;<br>cout&lt;&lt; maxp-&gt;second.name &lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>&lt;&lt; maxp-&gt;second.id &lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>&lt;&lt; maxp-&gt;first &lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">else</span> cout&lt;&lt; <span class="hljs-string">&quot;Nobody&quot;</span> &lt;&lt; endl;<span class="hljs-comment">//未查找到 </span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo上传Latex代码遇到的问题</title>
    <link href="/2023/08/25/hexo%E4%B8%8A%E4%BC%A0Latex%E4%BB%A3%E7%A0%81%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2023/08/25/hexo%E4%B8%8A%E4%BC%A0Latex%E4%BB%A3%E7%A0%81%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>在使用Latex编写数学公式，再通过Hexo上传至个人博客时遇到一个问题<br><img src="/img/mistake.png" alt="报错"></p><p>报错显示<code>expected variable end</code></p><p>网上查找显示错误为 转义内容 Hexo使用Nunjucks渲染帖子（较早的版本使用Swig，它们具有相似的语法）。用<code>&#123;&#123; &#125;&#125;</code>或<code>&#123;％ ％&#125;</code>包装的内容将被解析，并可能导致问题。您可以使用原始标签插件包装敏感内容。<br>找到正文里面<code>&#123;&#123;    &#125;&#125;</code>、<code>&#123;%    %&#125;</code>这样的语句修改为<code>&#123; &#123;    &#125; &#125;</code>,<code>&#123; %    % &#125;</code>即可解决该问题</p>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Latex</tag>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一道有趣的无穷级数题</title>
    <link href="/2023/08/25/%E4%B8%80%E9%81%93%E6%9C%89%E8%B6%A3%E7%9A%84%E6%97%A0%E7%A9%B7%E7%BA%A7%E6%95%B0%E9%A2%98/"/>
    <url>/2023/08/25/%E4%B8%80%E9%81%93%E6%9C%89%E8%B6%A3%E7%9A%84%E6%97%A0%E7%A9%B7%E7%BA%A7%E6%95%B0%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>$$<br>\frac { 1+\frac { { \pi }^{ 4 } } { 4!{ 2 }^{ 4 } }+\frac { { \pi }^{ 8 } } { 8!{ 2 }^{ 8 } }+\frac { { \pi }^{12} } { 12!{2}^{12} }+\cdot \cdot \cdot } {\frac {1} {8}+\frac { { \pi }^{4} } { 6!{2}^{6} }+\frac { { \pi }^{8} } {10!{2}^{10} }+\frac { { \pi }^{12} } {14!{2}^{14} }+ \cdot \cdot \cdot }&#x3D;<br>$$</p><p>解： 记所求分式的分子分母分别为S，T，</p><p>将$cos\frac{\pi}{2}$展开成无穷级数<br>$$<br>\cos { \frac { \pi } {2} }&#x3D;\sum ^{\infty }_{n&#x3D;0} { \frac { \left ( {-1} \right )^{n} } { \left ( {2n} \right )!} }\left ( {\frac {\pi } {2} } \right )^{2n}<br>$$<br>$$<br>&#x3D;(1+\frac { {\pi }^{4} } {4!{2}^{4} }+\frac { { \pi }^{8} } {8!{2}^{8} }+\frac { {\pi }^{12} } {12!{2}^{12} }+\cdot \cdot \cdot)-(\frac { { \pi }^{2} } {2!{2}^{2} }+\frac { { \pi }^{6} } {6!{2}^{6} }+\frac { { \pi }^{10} } {10!{2}^{10} }+\frac { { \pi }^{14} } {14!{2}^{14} }+\cdot \cdot \cdot)<br>$$<br>$$<br>&#x3D;S-{\pi}^{2}T<br>$$<br>即$0&#x3D;S-{\pi}^{2}T$，所以$\frac{S}{T}&#x3D;{\pi}^{2}$.</p><p>巧妙的利用泰勒展开式找出分子分母的联系</p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STL之set</title>
    <link href="/2023/08/25/STL%E4%B9%8Bset/"/>
    <url>/2023/08/25/STL%E4%B9%8Bset/</url>
    
    <content type="html"><![CDATA[<ul><li><p>set和multiset的区别在于容器里不能有重复元素</p><p>a和b重复 &lt;&#x3D;&gt; “a必须排在b前面” 和”b必须排在a前面” 都不成立</p></li><li><p>set插入元素可能不成功</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;set&gt;</span><span class="hljs-comment">//使用multiset和set使用该头文件 </span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>set&lt;<span class="hljs-type">int</span>&gt; st;<br><span class="hljs-type">int</span> a[<span class="hljs-number">10</span>]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">14</span>,<span class="hljs-number">12</span>,<span class="hljs-number">13</span>,<span class="hljs-number">7</span>,<span class="hljs-number">13</span>,<span class="hljs-number">21</span>,<span class="hljs-number">19</span>,<span class="hljs-number">8</span>,<span class="hljs-number">8</span>&#125;;<span class="hljs-comment">//不重复算，如8，13只算一次 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)<br>st.<span class="hljs-built_in">insert</span>(a[i]);<br>cout&lt;&lt; st.<span class="hljs-built_in">size</span>()&lt;&lt;endl;<span class="hljs-comment">//输出存放的元素个数 </span><br>set&lt;<span class="hljs-type">int</span>&gt;::iterator i;<br><span class="hljs-keyword">for</span>(i=st.<span class="hljs-built_in">begin</span>();i!=st.<span class="hljs-built_in">end</span>();i++)&#123;<br>cout&lt;&lt;*i&lt;&lt;<span class="hljs-string">&#x27;,&#x27;</span>;<br>&#125; <br>cout&lt;&lt;endl;<br>pair&lt;set&lt;<span class="hljs-type">int</span>&gt;::iterator, <span class="hljs-type">bool</span>&gt; result = st.<span class="hljs-built_in">insert</span>(<span class="hljs-number">12</span>);<br><span class="hljs-keyword">if</span>( ! result.second ) cout&lt;&lt; * result.first&lt;&lt;<span class="hljs-string">&quot; already exists. &quot;</span>&lt;&lt;endl;<br><span class="hljs-keyword">else</span> cout&lt;&lt; * result.first&lt;&lt; <span class="hljs-string">&quot;inserted.&quot;</span>&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="pair模板的用法"><a href="#pair模板的用法" class="headerlink" title="pair模板的用法"></a>pair模板的用法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">pair&lt;set&lt;<span class="hljs-type">int</span>&gt;::iteractor, <span class="hljs-type">bool</span>&gt;<br><span class="hljs-comment">//等价于</span><br><span class="hljs-keyword">struct</span> &#123;<br>    set&lt;<span class="hljs-type">int</span>&gt;::iteractor first;<br>    <span class="hljs-type">bool</span> second;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">pair&lt;T1,T2&gt;<br><span class="hljs-keyword">struct</span>&#123;<br>T1 first;<br>T2 second;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STL之multiset</title>
    <link href="/2023/08/25/STL%E4%B9%8Bmultiset/"/>
    <url>/2023/08/25/STL%E4%B9%8Bmultiset/</url>
    
    <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">multiset&lt;T&gt; st;<br></code></pre></td></tr></table></figure><ul><li>定义了一个multiset变量st，st里面可以存放T类型的数据，并且能够自动排序。初始st为空。</li><li>排序规则：表达式“a&lt;b”为true，则a排在b的前面。</li><li><code>st.insert</code> 添加元素，<code>st.find</code>查找元素， st.erase删除元素，复杂度都是$log(n)$</li></ul><p>头文件<code>#include &lt;set&gt;//使用multiset和set都需要使用</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">multiset&lt;T&gt;::iterator p;<br></code></pre></td></tr></table></figure><ul><li><p>p是迭代器，相当于指针，可用于指向multiset中的元素。访问multiset中的元素要通过迭代器。</p></li><li><p>与指针的不同：</p><p>multiset上的迭代器可++，–，用!&#x3D;和&#x3D;&#x3D;比较，但不可以比大小，不可以加减整数，不可相减</p></li><li><p><code>st.begin()</code>返回值类型为<code>multiset&lt;T&gt;::iterator</code>,是指向st中的头一个元素的迭代器</p></li><li><p><code>st.end()</code>返回值类型为<code>multiset&lt;T&gt;::iterator</code>,是指向st中的最后一个元素后面的迭代器</p></li><li><p>对迭代器++，其就是指向容器中下一个元素，–则令其指向上一个元素</p></li></ul><p>一般用法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;set&gt;</span><span class="hljs-comment">//使用multiset和set使用该头文件 </span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>multiset&lt;<span class="hljs-type">int</span>&gt; st;<br><span class="hljs-type">int</span> a[<span class="hljs-number">10</span>]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">14</span>,<span class="hljs-number">12</span>,<span class="hljs-number">13</span>,<span class="hljs-number">7</span>,<span class="hljs-number">13</span>,<span class="hljs-number">21</span>,<span class="hljs-number">19</span>,<span class="hljs-number">8</span>,<span class="hljs-number">8</span>&#125;;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)<br>st.<span class="hljs-built_in">insert</span>(a[i]);<span class="hljs-comment">//插入a[i]的复制品 </span><br>multiset&lt;<span class="hljs-type">int</span>&gt;::iterator i;<span class="hljs-comment">//迭代器，近似于指针</span><br><span class="hljs-keyword">for</span>(i=st.<span class="hljs-built_in">begin</span>();i!=st.<span class="hljs-built_in">end</span>();i++)&#123;<br>cout&lt;&lt;*i&lt;&lt;<span class="hljs-string">&#x27;,&#x27;</span>;<br>&#125; <br>cout&lt;&lt;endl;<br>i=st.<span class="hljs-built_in">find</span>(<span class="hljs-number">22</span>);<span class="hljs-comment">//查找22，返回值为迭代器</span><br><span class="hljs-keyword">if</span>(i == st.<span class="hljs-built_in">end</span>())&#123;<span class="hljs-comment">//找不到则返回值为end() </span><br>cout&lt;&lt;<span class="hljs-string">&quot;Not Found&quot;</span>&lt;&lt;endl;<br>&#125; <br><span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//找到则返回指向找到元素的迭代器 </span><br>cout&lt;&lt;<span class="hljs-string">&quot;Found &quot;</span>&lt;&lt;*i&lt;&lt;endl;<br>&#125;<br>st.<span class="hljs-built_in">insert</span>(<span class="hljs-number">22</span>);<span class="hljs-comment">//插入22</span><br>i=st.<span class="hljs-built_in">find</span>(<span class="hljs-number">22</span>);<span class="hljs-comment">//再次查找 </span><br><span class="hljs-keyword">if</span>(i == st.<span class="hljs-built_in">end</span>())&#123; <br>cout&lt;&lt;<span class="hljs-string">&quot;Not Found&quot;</span>&lt;&lt;endl;<br>&#125; <br><span class="hljs-keyword">else</span> &#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;Found &quot;</span>&lt;&lt;*i&lt;&lt;endl;<br>&#125;<br>i = st.<span class="hljs-built_in">lower_bound</span>(<span class="hljs-number">13</span>);<br><span class="hljs-comment">//返回最靠后的迭代器i，使得[begin(),i)中的元素都在13前面，复杂度为log(n)</span><br>cout&lt;&lt; *i &lt;&lt;endl;<br>i=st.<span class="hljs-built_in">upper_bound</span>(<span class="hljs-number">8</span>);<br><span class="hljs-comment">// 回最靠前的迭代器i，使得[i,end())中的元素都在8后面，复杂度为log(n)</span><br>cout&lt;&lt; *i &lt;&lt;endl;<br>st.<span class="hljs-built_in">erase</span>(i);<span class="hljs-comment">//删除迭代器指向的元素，即12，并非删除迭代器</span><br><span class="hljs-keyword">for</span>(i=st.<span class="hljs-built_in">begin</span>();i!=st.<span class="hljs-built_in">end</span>();i++)<br>cout &lt;&lt; * i &lt;&lt; <span class="hljs-string">&#x27;,&#x27;</span>;<br>cout&lt;&lt;endl; <br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125;<br></code></pre></td></tr></table></figure><p>自定义排序规则的用法</p><ul><li>使用greater进行从大到小排序</li><li>自定义规则（结构体）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;set&gt;</span><span class="hljs-comment">//使用multiset和set使用该头文件 </span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Rule1</span> &#123;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span> <span class="hljs-params">( <span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp; a, <span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp; b)</span> <span class="hljs-type">const</span></span>&#123;<br><span class="hljs-keyword">return</span> (a%<span class="hljs-number">10</span>) &lt; (b%<span class="hljs-number">10</span>);<span class="hljs-comment">//返回值为true则说明a必须在b前面，但若个位数字相同，采取何种方式排序呢 </span><br>&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>multiset&lt;<span class="hljs-type">int</span>, greater&lt;<span class="hljs-type">int</span>&gt; &gt; st;<span class="hljs-comment">//排序规则为从小到大 </span><br><span class="hljs-type">int</span> a[<span class="hljs-number">10</span>]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">14</span>,<span class="hljs-number">12</span>,<span class="hljs-number">13</span>,<span class="hljs-number">7</span>,<span class="hljs-number">13</span>,<span class="hljs-number">21</span>,<span class="hljs-number">19</span>,<span class="hljs-number">8</span>,<span class="hljs-number">8</span>&#125;;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)<br>st.<span class="hljs-built_in">insert</span>(a[i]);<span class="hljs-comment">//插入a[i]的复制品 </span><br>multiset&lt;<span class="hljs-type">int</span>, greater&lt;<span class="hljs-type">int</span>&gt; &gt;::iterator i;<br><span class="hljs-keyword">for</span>(i=st.<span class="hljs-built_in">begin</span>();i!=st.<span class="hljs-built_in">end</span>();i++)&#123;<br>cout&lt;&lt;*i&lt;&lt;<span class="hljs-string">&#x27;,&#x27;</span>;<br>&#125; <br>cout&lt;&lt;endl;<br>multiset&lt;<span class="hljs-type">int</span>,Rule1&gt; st2;<span class="hljs-comment">//个位数字从小到大排列 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)<br>st2.<span class="hljs-built_in">insert</span>(a[i]);<span class="hljs-comment">//插入a[i]的复制品</span><br>multiset&lt;<span class="hljs-type">int</span>, Rule1&gt;::iterator p; <br><span class="hljs-keyword">for</span>(p=st2.<span class="hljs-built_in">begin</span>();p!=st2.<span class="hljs-built_in">end</span>();p++)&#123;<br>cout&lt;&lt;*p&lt;&lt;<span class="hljs-string">&#x27;,&#x27;</span>;<br>&#125; <br>cout&lt;&lt;endl;<br>p=st2.<span class="hljs-built_in">find</span>(<span class="hljs-number">133</span>);<span class="hljs-comment">//查找133，返回值为迭代器</span><br><span class="hljs-keyword">if</span>(p == st2.<span class="hljs-built_in">end</span>())&#123;<span class="hljs-comment">//找不到则返回值为end() </span><br>cout&lt;&lt;<span class="hljs-string">&quot;Not Found&quot;</span>&lt;&lt;endl;<br>&#125; <br><span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//找到则返回指向找到元素的迭代器 </span><br>cout&lt;&lt;<span class="hljs-string">&quot;Found &quot;</span>&lt;&lt;*p&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STL之二分查找</title>
    <link href="/2023/08/24/STL%E4%B9%8B%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <url>/2023/08/24/STL%E4%B9%8B%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="binary-search进行二分查找"><a href="#binary-search进行二分查找" class="headerlink" title="binary_search进行二分查找"></a>binary_search进行二分查找</h2><ul><li><p>在从小到大排好序的基本类型数组上进行二分查找</p><p>​<strong><code>binary_search(数组名+n1,数组名+n2,值);</code></strong></p><p>​n1和n2都是int类型的表达式，可以包含变量</p><p>​如果n1&#x3D;0，则+n1可以不写</p><p>查找区间为下标范围为[n1,n2)的元素，下标为n2的元素不在查找区间内</p><p>在该查找区间内查找“等于”值的元素，返回值为true（找到）或false（没找到）</p><p><strong>“等于”的含义：a等于b &lt;&#x3D;&gt; a&lt;b和b&lt;a都不成立</strong></p></li><li><p>在用自定义排序规则排好序的，元素为任意的T类型的数组中进行二分查找</p><p>​<strong><code>binary_search(数组名+n1,数组名+n2,值,排序规则结构名());</code></strong></p><p>​n1和n2都是int类型的表达式，可以包含变量</p><p>​如果n1&#x3D;0，则+n1可以不写</p><p>查找区间为下标范围为[n1,n2)的元素，下标为n2的元素不在查找区间内</p><p>在该查找区间内查找“等于”值的元素，返回值为true（找到）或false（没找到）</p><p><strong>查找时的排序规则，必须和排序时的规则一致</strong><br><strong>“等于”的含义：a等于b &lt;&#x3D;&gt; a&lt;b和b&lt;a都不成立</strong></p></li></ul><h2 id="lower-bound二分查找下界"><a href="#lower-bound二分查找下界" class="headerlink" title="lower_bound二分查找下界"></a>lower_bound二分查找下界</h2><ul><li><p>在对元素类型为T的从小到大排好序的基本类型数组上进行二分查找<br>​<strong><code>T * lower_bound(数组名+n1,数组名+n2,值);</code></strong><br>  返回一个指针 T * p;<br>  *p是查找区间里下标最小的，大于等于“值”的元素。如果找不到，p指向下标为n2的元素</p></li><li><p>在元素为任意的T类型、按自定义排序规则排好序的数组中进行查找<br>​<strong><code>T * lower_bound(数组名+n1,数组名+n2,值,排序规则结构名());</code></strong><br>  返回一个指针 T * p;<br>  *p是查找区间里下标最小的，按自定义排序规则，可以排在“值”后面的元素。如果找不到，p指向下标为n2的元素</p></li></ul><h2 id="upper-bound二分查找下界"><a href="#upper-bound二分查找下界" class="headerlink" title="upper_bound二分查找下界"></a>upper_bound二分查找下界</h2><ul><li><p>在对元素类型为T的从小到大排好序的基本类型数组上进行二分查找<br>​<strong><code>T * upper_bound(数组名+n1,数组名+n2,值);</code></strong><br>  返回一个指针 T * p;<br>  *p是查找区间里下标最小的，大于“值”的元素。如果找不到，p指向下标为n2的元素</p></li><li><p>在元素为任意的T类型、按自定义排序规则排好序的数组中进行查找<br>​<strong><code>T * upper_bound(数组名+n1,数组名+n2,值,排序规则结构名());</code></strong><br>  返回一个指针 T * p;<br>  *p是查找区间里下标最小的，按自定义排序规则，一定排在“值”后面的元素。如果找不到，p指向下标为n2的元素</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>STL</tag>
      
      <tag>二分查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>arctan的一些公式</title>
    <link href="/2023/08/23/arctan%E7%9A%84%E4%B8%80%E4%BA%9B%E5%85%AC%E5%BC%8F/"/>
    <url>/2023/08/23/arctan%E7%9A%84%E4%B8%80%E4%BA%9B%E5%85%AC%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>$$<br>arctan {A}+arctanB&#x3D;arctan\frac {A+B} {1-AB}<br>$$</p><p> 证明：令$x&#x3D;arctanA$,$y&#x3D;arctanB$,</p><p>$ \tan {\left ( {x+y} \right )&#x3D;\frac {\tan {x}+\tan {y, }} {1-\tan {x}\tan {y}}}&#x3D;\frac {A+B} {1-AB} $</p><p>$ arctan\frac {A+B} {1-AB}&#x3D;x+y&#x3D;arctanA+arctanB $</p><p>$arctan {A}+arctanB&#x3D;arctan\frac {A+B} {1-AB}$</p><p>同理可证<br>$$<br>arctan {A}-arctanB&#x3D;arctan\frac {A-B} {1+AB}<br>$$<br>由上述公式可得<br>$$<br>arctan {A}+arctan{\frac{1}{A}}&#x3D;\frac{\pi}{2}<br>$$</p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STL之sort排序</title>
    <link href="/2023/08/23/STL%E4%B9%8Bsort%E6%8E%92%E5%BA%8F/"/>
    <url>/2023/08/23/STL%E4%B9%8Bsort%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>STL头文件<code>#include &lt;algorithm&gt;</code></p><ul><li><p>对基本类型的数组从小到大进行排序：</p><p><strong><code>sort(数组名+n1,数组名+n2);</code></strong></p><p>n1,n2都是int类型的表达式，可以包含变量</p><p>如果n1&#x3D;0,则+n1可以省略不写</p></li></ul><p>将数组中下表范围为**[n1,n2)**的元素从小到大排序，下标为n2的元素不在排序区间内。</p><ul><li><p>对元素类型为T的基本类型数组从大到小进行排序：</p><p><strong><code>sort(数组名+n1,数组名+n2,greater&lt;T&gt;());</code></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a[] = &#123;<span class="hljs-number">15</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">7</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>&#125;;<br><span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+<span class="hljs-number">4</span>,<span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;());<span class="hljs-comment">//结果：&#123;15,9,4,3,7,2,6&#125;</span><br></code></pre></td></tr></table></figure></li><li><p>用自定义的排序规则，对任何类型T的数组进行排序</p><p><strong><code>sort(数组名+n1,数组名+n2,排序规则结构名());</code></strong></p><p>排序规则结构的定义方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> 结构名<br>&#123;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operater</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp; a1,<span class="hljs-type">const</span> T &amp; a2)</span> <span class="hljs-type">const</span></span>&#123;<br>        <span class="hljs-comment">//若a1应该在a2的前面，则返回true</span><br>        <span class="hljs-comment">//否则返回false</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>STL</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>strlen的糟糕用法</title>
    <link href="/2023/08/23/strlen%E7%9A%84%E7%B3%9F%E7%B3%95%E7%94%A8%E6%B3%95/"/>
    <url>/2023/08/23/strlen%E7%9A%84%E7%B3%9F%E7%B3%95%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p><strong>strlen的糟糕用法</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> s[<span class="hljs-number">100</span>]=<span class="hljs-string">&quot;test&quot;</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">strlen</span>(s);i++)<br>&#123;<br>    s[i]=s[i]+<span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>strlen函数的执行都是需要时间的，而且时间和字符串的长度成正比</p></li><li><p>每次循环都需要调用strlen函数，这是效率上的很大浪费<br><strong>修正用法</strong></p></li><li><p>应取出s的长度存放在另一个变量里面，然后在循环的时候使用该变量</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> s[<span class="hljs-number">100</span>]=<span class="hljs-string">&quot;test&quot;</span>;<br><span class="hljs-type">int</span> len=<span class="hljs-built_in">strlen</span>(s);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)<br>&#123;<br>    s[i]=s[i]+<span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>或直接将判断条件改为<code>s[i]</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> s[<span class="hljs-number">100</span>]=<span class="hljs-string">&quot;test&quot;</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;s[i];i++)<span class="hljs-comment">//s[i]以&#x27;\0&#x27;结尾，刚好其ASCII码为0</span><br>&#123;<br>    s[i]=s[i]+<span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 2682找出转圈游戏输家</title>
    <link href="/2023/08/16/Leetcode-2682%E6%89%BE%E5%87%BA%E8%BD%AC%E5%9C%88%E6%B8%B8%E6%88%8F%E8%BE%93%E5%AE%B6/"/>
    <url>/2023/08/16/Leetcode-2682%E6%89%BE%E5%87%BA%E8%BD%AC%E5%9C%88%E6%B8%B8%E6%88%8F%E8%BE%93%E5%AE%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><code>n</code> 个朋友在玩游戏。这些朋友坐成一个圈，按 <strong>顺时针方向</strong> 从 <code>1</code> 到 <code>n</code> 编号。从第 <code>i</code> 个朋友的位置开始顺时针移动 <code>1</code> 步会到达第 <code>(i + 1)</code> 个朋友的位置（<code>1 &lt;= i &lt; n</code>），而从第 <code>n</code> 个朋友的位置开始顺时针移动 <code>1</code> 步会回到第 <code>1</code> 个朋友的位置。</p><p>游戏规则如下：</p><p>第 <code>1</code> 个朋友接球。</p><ul><li>接着，第 <code>1</code> 个朋友将球传给距离他顺时针方向 <code>k</code> 步的朋友。</li><li>然后，接球的朋友应该把球传给距离他顺时针方向 <code>2 * k</code> 步的朋友。</li><li>接着，接球的朋友应该把球传给距离他顺时针方向 <code>3 * k</code> 步的朋友，以此类推。</li></ul><p>换句话说，在第 <code>i</code> 轮中持有球的那位朋友需要将球传递给距离他顺时针方向 <code>i * k</code> 步的朋友。</p><p>当某个朋友第 2 次接到球时，游戏结束。</p><p>在整场游戏中没有接到过球的朋友是 <strong>输家</strong> 。</p><p>给你参与游戏的朋友数量 <code>n</code> 和一个整数 <code>k</code> ，请按升序排列返回包含所有输家编号的数组 <code>answer</code> 作为答案。</p><h2 id="测试样例1"><a href="#测试样例1" class="headerlink" title="测试样例1"></a>测试样例1</h2><p><strong>输入</strong>：n &#x3D; 5, k &#x3D; 2<br><strong>输出</strong>：[4,5]<br><strong>解释</strong>：以下为游戏进行情况：<br>1）第 1 个朋友接球，第 1 个朋友将球传给距离他顺时针方向 2 步的玩家 —— 第 3 个朋友。<br>2）第 3 个朋友将球传给距离他顺时针方向 4 步的玩家 —— 第 2 个朋友。<br>3）第 2 个朋友将球传给距离他顺时针方向 6 步的玩家 —— 第 3 个朋友。<br>4）第 3 个朋友接到两次球，游戏结束。</p><h2 id="测试样例2"><a href="#测试样例2" class="headerlink" title="测试样例2"></a>测试样例2</h2><p><strong>输入</strong>：n &#x3D; 4, k &#x3D; 4<br><strong>输出</strong>：[2,3,4]<br><strong>解释</strong>：以下为游戏进行情况：<br>1）第 1 个朋友接球，第 1 个朋友将球传给距离他顺时针方向 4 步的玩家 —— 第 1 个朋友。<br>2）第 1 个朋友接到两次球，游戏结束。</p><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>1 &lt;&#x3D; k &lt;&#x3D; n &lt;&#x3D; 50</p><h2 id="c语言实现"><a href="#c语言实现" class="headerlink" title="c语言实现"></a>c语言实现</h2><h3 id="初步完成"><a href="#初步完成" class="headerlink" title="初步完成"></a>初步完成</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span>* <span class="hljs-title function_">circularGameLosers</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span>* returnSize)</span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-type">int</span> a[<span class="hljs-number">51</span>]=&#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-comment">//最多50人</span><br>    a[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<span class="hljs-comment">//初始第一个人</span><br>    <span class="hljs-type">int</span> next=<span class="hljs-number">1</span>;<span class="hljs-comment">//下一次是第几个人</span><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;;i++)<span class="hljs-comment">//循环直到第二个人接球结束</span><br>    &#123;<br>        <span class="hljs-type">int</span> lenth=i*k;<span class="hljs-comment">//步长</span><br>        next+=lenth;<span class="hljs-comment">//下一位接球者</span><br>        <span class="hljs-keyword">while</span>(next&gt;n)<span class="hljs-comment">//超过人数最大限制时重新轮圈</span><br>        &#123;<br>            next-=n;<br>        &#125;<br>        a[next]++;<span class="hljs-comment">//记录每人接球次数</span><br>        <span class="hljs-keyword">if</span>(a[next]==<span class="hljs-number">2</span>) <span class="hljs-keyword">break</span>;<span class="hljs-comment">//循环结束</span><br>    &#125;<br>    <span class="hljs-type">int</span> num=<span class="hljs-number">0</span>;<span class="hljs-comment">//计数</span><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(a[i]==<span class="hljs-number">0</span>) num++;<br>    &#125;<br>    *returnSize=num;<br>    <span class="hljs-type">int</span>* answer=<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>)*num);<br>    <span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(a[i]==<span class="hljs-number">0</span>) answer[j++]=i;<span class="hljs-comment">//确定返回的数组</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> answer;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="最终解法"><a href="#最终解法" class="headerlink" title="最终解法"></a>最终解法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span>* <span class="hljs-title function_">circularGameLosers</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span>* returnSize)</span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-type">bool</span> visit[n];<span class="hljs-comment">//是否接球</span><br>    <span class="hljs-built_in">memset</span>(visit, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(visit));<span class="hljs-comment">//使用memset初始化数组</span><br>    <span class="hljs-type">int</span> next=<span class="hljs-number">0</span>;<span class="hljs-comment">//下一次是第几个人,从0开始</span><br>    <span class="hljs-keyword">for</span>(i=k;!visit[next];i+=k)<span class="hljs-comment">//循环直到第二个人接球结束</span><br>    &#123;<br>        visit[next]=<span class="hljs-literal">true</span>;<br>        next=(next+i)%n;<span class="hljs-comment">//使用取余简化解法,无需循环</span><br>    &#125;<br>    <span class="hljs-type">int</span>* answer=<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>)*n);<br>    <span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(!visit[i]) answer[j++]=i+<span class="hljs-number">1</span>;<span class="hljs-comment">//数组下标从0开始，所以需要+1</span><br>    &#125;<br>    *returnSize=j;<span class="hljs-comment">//j即为数组大小</span><br>    <span class="hljs-keyword">return</span> answer;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>每日一题</tag>
      
      <tag>简单</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分类与回归</title>
    <link href="/2023/06/19/%E5%88%86%E7%B1%BB%E4%B8%8E%E5%9B%9E%E5%BD%92/"/>
    <url>/2023/06/19/%E5%88%86%E7%B1%BB%E4%B8%8E%E5%9B%9E%E5%BD%92/</url>
    
    <content type="html"><![CDATA[<p>分类是一种典型的有监督学习问题<br><strong>分类一般分为以下两个阶段：</strong></p><ol><li>分类器训练：即通过训练样本的特征和标签来建立分类模型</li><li>分类预测：利用分类模型对没有分类标签的数据进行分类<br><strong>数据集划分为训练集和测试集</strong></li><li>训练集训练分类器</li><li>测试集用于评估分类性能</li></ol><h1 id="决策树分类算法"><a href="#决策树分类算法" class="headerlink" title="决策树分类算法"></a>决策树分类算法</h1><h2 id="CLS"><a href="#CLS" class="headerlink" title="CLS"></a>CLS</h2><p>CLS算法问题：<br>       测试属性集的组成以及测试属性的先后对决策树的学习具有举足轻重的影响。</p><h2 id="ID3"><a href="#ID3" class="headerlink" title="ID3"></a>ID3</h2><p>**不纯度 (impurity)**：<br>    表示落在当前节点的样本类别分布的均衡程度，节点分裂后，节点不纯度应该更低，选择特征及对应分割点，使得分裂前后的不纯度(impurity)下降最大。<br>节点不纯度的度量</p><h3 id="信息熵"><a href="#信息熵" class="headerlink" title="信息熵"></a>信息熵</h3><h4 id="信息增益"><a href="#信息增益" class="headerlink" title="信息增益"></a>信息增益</h4><h3 id="Gini指数"><a href="#Gini指数" class="headerlink" title="Gini指数"></a>Gini指数</h3><h3 id="误分率"><a href="#误分率" class="headerlink" title="误分率"></a>误分率</h3><p>ID3算法存在的问题：<br>    倾向于分裂成很多的小节点（节点的样本数较小），容易造成过拟合 </p><h2 id="C4-5"><a href="#C4-5" class="headerlink" title="C4.5"></a>C4.5</h2><h3 id="信息增益率"><a href="#信息增益率" class="headerlink" title="信息增益率"></a>信息增益率</h3><h2 id="决策树的剪枝"><a href="#决策树的剪枝" class="headerlink" title="决策树的剪枝"></a>决策树的剪枝</h2><h1 id="朴素贝叶斯算法"><a href="#朴素贝叶斯算法" class="headerlink" title="朴素贝叶斯算法"></a>朴素贝叶斯算法</h1><p>0概率处理：<br>    加1平滑，使用加1的方法估计没有出现过现象的概率，以保证概率不会出现0<br>优缺点分析：</p><h1 id="K近邻"><a href="#K近邻" class="headerlink" title="K近邻"></a>K近邻</h1><h1 id="回归"><a href="#回归" class="headerlink" title="回归"></a>回归</h1><h2 id="一元线性回归"><a href="#一元线性回归" class="headerlink" title="一元线性回归"></a>一元线性回归</h2><h2 id="多元线性回归"><a href="#多元线性回归" class="headerlink" title="多元线性回归"></a>多元线性回归</h2><h2 id="多项式回归"><a href="#多项式回归" class="headerlink" title="多项式回归"></a>多项式回归</h2><p><strong>多项式回归的优点</strong>：可以通过增加 x 的高次项对实测点进行逼近，直至满意为止。<br>多项式回归可以处理相当一类非线性问题，它在回归分析中占有重要的地位，因为任一函数都可以分段用多项式来逼近。因此，在通常的实际问题中，不论依变量与其他自变量的关系如何，我们总可以用多项式回归来进行分析。</p><h2 id="过拟合问题"><a href="#过拟合问题" class="headerlink" title="过拟合问题"></a>过拟合问题</h2><h3 id="减少特征数量"><a href="#减少特征数量" class="headerlink" title="减少特征数量"></a>减少特征数量</h3><h3 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h3><h4 id="Lasso回归"><a href="#Lasso回归" class="headerlink" title="Lasso回归"></a>Lasso回归</h4><h4 id="岭回归"><a href="#岭回归" class="headerlink" title="岭回归"></a>岭回归</h4><h4 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h4><h1 id="SVM"><a href="#SVM" class="headerlink" title="SVM"></a>SVM</h1><p>最大化边界<br>线性不可分——升维<br>核函数</p><h1 id="关联规则挖掘"><a href="#关联规则挖掘" class="headerlink" title="关联规则挖掘"></a>关联规则挖掘</h1><p>支持度，置信度（条件概率</p><p><strong>事务</strong>：每一条购物信息可以被定义为一个事务；<br><strong>项</strong>：购物信息中的一项物品被定义为项；<br><strong>项集</strong>：包含零个项或多个项的集合被称为项集，含有k个项的项集称为k项集；<br><strong>关联规则</strong>就可以表示为形如“A&#x3D;&gt;B” 的蕴涵式，其中A，B均为非空项集，且A∩B&#x3D; ∅。<br>支持度大于预定义的最小支持度阈值的项集称为<strong>频繁项集</strong>。<br>有了频繁项集的定义，可以把从数据集中挖掘强关联规则的过程分为两步：<br>    第一步：需要找出满足最小支持度阈值的项集，即频繁项集；<br>    第二步：根据最小置信度阈值，从频繁项集中生成强关联规则。<br><strong>Apriori性质</strong>：<br>    如果一个项集A是频繁项集，那么它的非空子集B也是频繁项集。<br>    或者：如果一个项集不是频繁项集，那它的超集也不是频繁项集。</p><p>FP-Growth算法</p><h1 id="集成"><a href="#集成" class="headerlink" title="集成"></a>集成</h1><p>降低误差<br>    - 假设单个分类器误差 𝑝，分类器之间独立，𝑇个分类器采用投票进行预测，得到集成模型 𝐻<br>    - 集成分类器误差为：<br>       𝑇&#x3D;5,   𝑝&#x3D;0.1 时， Error𝐻&lt;0.01</p><ul><li>多数投票方法 (majority vote)</li><li>平均 (averaging)</li><li>加权平均 (weighted averaging)：如AdaBoost</li></ul><h2 id="Bagging算法"><a href="#Bagging算法" class="headerlink" title="Bagging算法"></a>Bagging算法</h2><p>优势：<br>    - 特别适合用来提高那些方差大但偏差小的基模型(决策树，神经网络等)的预测性能<br>    - 单个模型不稳定：对训练数据轻微的改变就能够造成分类器性能很明显的变化<br>    - 使用Bagging可以综合投票结果，从而提升稳定性以及准确率<br>    - 便于并行化。多个抽样数据的获取及基模型的训练互相没有关联，可以方便地进行并行计算 </p><h3 id="随机森林"><a href="#随机森林" class="headerlink" title="随机森林"></a>随机森林</h3><h4 id="决策树的局限性"><a href="#决策树的局限性" class="headerlink" title="决策树的局限性"></a>决策树的局限性</h4><h4 id="随机森林算法原理"><a href="#随机森林算法原理" class="headerlink" title="随机森林算法原理"></a>随机森林算法原理</h4><h4 id="性能评估"><a href="#性能评估" class="headerlink" title="性能评估"></a>性能评估</h4><h4 id="随机森林与特征选择"><a href="#随机森林与特征选择" class="headerlink" title="随机森林与特征选择"></a>随机森林与特征选择</h4><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>优点：<br>    - 能够处理很高维度的数据，并且不用做特征选择<br>    - 对特征之间存在的多重共线性不敏感，并且能够在一定程度上处理缺失数据和不均衡数据<br>    - 在训练完后能够给出哪些特征比较重要<br>    - 容易做成并行化方法<br>缺点：<br>    - 处理噪音较大的小样本和低维数据集的问题上会过度拟合<br>    - 相对于决策树，预测速度较慢<br>    - 相对于决策树，模型可解释性较差</p><h4 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h4><h2 id="Boosting算法"><a href="#Boosting算法" class="headerlink" title="Boosting算法"></a>Boosting算法</h2><p>串行方式训练获得强分类器</p><h3 id="AdaBoost"><a href="#AdaBoost" class="headerlink" title="AdaBoost"></a>AdaBoost</h3><p>AdaBoost (Adaptive Boosting)是最有代表性的Boosting算法；<br>AdaBoost的核心思想是利用同一训练样本的不同加权版本，训练一组弱分类器，然后把这些弱分类器以加权的形式集成起来，形成一个最终的强分类器：</p><h4 id="分类器权重更新"><a href="#分类器权重更新" class="headerlink" title="分类器权重更新"></a>分类器权重更新</h4><h4 id="样本权重更新"><a href="#样本权重更新" class="headerlink" title="样本权重更新"></a>样本权重更新</h4><h4 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h4>]]></content>
    
    
    <categories>
      
      <category>数据科学导论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据科学导论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>聚类分析</title>
    <link href="/2023/06/19/%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90/"/>
    <url>/2023/06/19/%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<ul><li>聚类模型的本质：将数据集中相似的样本进行分组的过程</li><li>每个组称为一个簇(cluster)每个簇的样本对应一个潜在的类别 </li><li>样本是没有类别标签的，因此聚类是一种典型的无监督学习任务 ，这些簇满足以下两个条件：<ul><li>相同簇的样本之间距离较近</li><li>不同簇的样本之间距离较远</li></ul></li></ul><h2 id="K-means模型"><a href="#K-means模型" class="headerlink" title="K-means模型"></a>K-means模型</h2><h2 id="层次聚类"><a href="#层次聚类" class="headerlink" title="层次聚类"></a>层次聚类</h2><p><strong>层次聚类</strong>(hierarchical clustering)在不同层级上对样本进行聚类，逐步形成树状的结构<br>根据层次分解是以自底向上（合并）还是自顶向下（分裂）方式，层次聚类方法可以分为<br>    <strong>聚合式</strong>聚类(agglomerative clustering)<br>    <strong>分拆式</strong>聚类(divisive clustering)<br>两种方法均是启发式的策略，并没有去优化一个明确的目标函数来实现聚类，很难严格评价聚类的效果</p><h3 id="聚合式聚类"><a href="#聚合式聚类" class="headerlink" title="聚合式聚类"></a>聚合式聚类</h3><h4 id="单连接"><a href="#单连接" class="headerlink" title="单连接"></a>单连接</h4><h4 id="完整连接"><a href="#完整连接" class="headerlink" title="完整连接"></a>完整连接</h4><h4 id="平均连接"><a href="#平均连接" class="headerlink" title="平均连接"></a>平均连接</h4><h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><p>单连接法只需要两簇内有成员对距离足够近就将两簇合并，而并没有考虑其他簇内其他成员的距离，因此单连接方法形成的簇很有<strong>可能违背紧致性特征</strong> 即簇内成员应该尽可能相似<br>完整连接法是另外一个极端，只有当两簇的联合的成员间的距离相对较小时才将两簇进行合并，因此完整连接法倾向于生成紧致簇<br>平均连接法是介于单连接和完整连接之间的方法，易于生成相对紧致的簇同时簇间距离较远 </p><h3 id="分拆式聚类"><a href="#分拆式聚类" class="headerlink" title="分拆式聚类"></a>分拆式聚类</h3><p>分拆式聚类将所有样本集合看作一簇，以自上而下的方式，递归地将现有的簇分拆为两个子簇<br>利用不同的启发式方法进行分拆方式的选择：<br><strong>二分K-means聚类</strong><br>    选择半径最大的簇，对该簇进行K-means聚类分为两个子簇<br>    重复此过程直到达到想要的簇个数<br><strong>最小生成树法</strong><br>    将每个样本看作一个图节点，将样本间距离看作节点间边的权重，根据此图建立最小生成树<br>    从权重最大处将该簇分拆为两簇，然后重复此过程直到达到想要的簇个数。实际上，该方法得到的聚类结果和单连接的聚合聚类得到的结果一致</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>层次聚类一次性地得到了整个聚类的过程，想要分多少个簇都可以直接根据树图来得到结果，改变簇的数目不需要再次计算数据点的归属类别;<br>单连接和完全连接代表了簇间距离度量的两个极端，它们对离群点或噪声数据过分敏感;<br>平均连接是一种折中方法，它可以克服离群点敏感性问题<br>层次聚类的缺点是计算量大，而且错分在层次聚类中是不可修正的，一旦某个样本被分到某个聚类中，则该样本永远停留在该聚类中</p><h2 id="密度聚类"><a href="#密度聚类" class="headerlink" title="密度聚类"></a>密度聚类</h2><p>密度聚类又称为<strong>基于密度聚类</strong>（density-based clustering）。此类算法假设聚类结构由样本分布的紧密程度确定，以数据集在空间分布上的稠密程度为依据进行聚类，即只要一个区域中的样本<strong>密度大于某个阈值</strong>，就把它<strong>划入与之相近的簇中</strong>。<br>不同于基于质心的原型聚类算法，基于密度的算法不需要事先设置k值。常用的密度聚类算法：DBSCAN、MDCA、OPTICS、DENCLUE等。</p><h3 id="DBSCAN算法"><a href="#DBSCAN算法" class="headerlink" title="DBSCAN算法"></a>DBSCAN算法</h3><p><strong>算法原理</strong><br>    DBSCAN是一种著名的密度聚类算法，它基于一组邻域参数(ϵ，Minpts)刻画样本分布的紧密程度，寻找数据集中的高密度以及低密度区域来完成聚类。可以将该算法归纳为三个步骤：设定邻域参数，数据点分类，聚类。<br>第一步：<strong>设定邻域参数(ϵ，Minpts)</strong><br>以各个数据点为中心，以ϵ为半径，计算其ϵ-邻域内的数据点密度。其中Minpts代表一个簇中最少的数据点个数，高于这个值则为高密度区域，否则为低密度区域。用户可以根据数据集的实际密度的不同设置这两个参数。<br>第二步：<strong>数据点分类</strong><br>基于邻域参数，在DBSCAN算法中，所有的数据点可以分为以下三个类别：<br><strong>核心点</strong>:如果某个点的邻域内的数据点数目高于阈值minpts，则将这个点视为核心点。<br><strong>边界点</strong>是位于核心点邻域之内的，但是其自身的邻域内数据点数小于minpts的点，起到将高密度区域与低密度区域分割开的作用。<br><strong>噪声点</strong>:既不是核心点也不是边界点的其他数据点，他们组成低密度区域。<br>![[Pasted image 20230604194801.png]]<br>进行密度聚类之前还需要了解下面三个概念：<br><strong>密度直达</strong>：两个同属于一个邻域的数据点是密度直达关系<br><strong>密度可达</strong>：o在p的邻域内，从p到o是密度直达，而q对象的邻域内不包括p，但是包括o，这样p-&gt;o-&gt;q，称p到q是密度可达的。<br><strong>密度相连</strong>：q和p是密度可达的, q和t也是密度可达的，则p和t是密度相连的。<br>第三步：<strong>聚类</strong><br>DBSCAN的目标为找到密度相连数据点的最大集合，此集合作为最终的一簇。首先核心点各自成簇，采用密度相连的概念逐步对簇进行合并，打上标记。<br>最终核心点密集的区域会被低密度噪声点包围，噪声点不单独成簇。所以采用DBSCAN进行聚类，最终的结果有一些数据点是没有标记的，这些就是噪声点。<br><strong>优点</strong>：</p><ol><li>无需事先设定簇的个数，算法根据数据自身找出各簇</li><li>适于稠密的非凸数据集，可以发现任意形状的簇</li><li>可以在聚类时发现噪音点、对数据集中的异常点不敏感</li><li>对样本输入顺序不敏感<br><strong>缺点</strong>：</li><li>因为是基于密度分析，如果客观存在的两个簇没有明显的可分间隔，则很有可能被合并为同一个簇</li><li>同时DBSCAN聚类的参数调节较为复杂，参数设置对结果影响较大</li><li>DBSCAN对高维的数据处理效果不好</li></ol><h2 id="PageRank算法"><a href="#PageRank算法" class="headerlink" title="PageRank算法"></a>PageRank算法</h2><p>基本思想：</p><ol><li>不只考虑词项，还考虑指向该网页的链接情况</li><li>被越多优质的网页所指的网页，它是优质的概率就越大<br>Dead End问题<br>链接农场问题<br>交换网站<br>黄金链<br>如何解决链接农场问题？</li><li>对链接的质量进行评估：Google 能够评估链接的质量，通过评估，会考虑链接的来源、内容以及对页面质量产生的影响等因素。</li><li>对链接的数量进行评估：如果某个网站的链接数量异常突出，Google 就会高度怀疑这些链接的真实性，因此会对这些链接进行评估，以判断它们是否具有真正价值。</li><li>采用基于内容的评估方法：Google 会对链接所指向的网页进行内容判断，如果发现这些页面的内容与链接不相关或者低质量，就会对链接产生负面评价。</li></ol>]]></content>
    
    
    <categories>
      
      <category>数据科学导论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据科学导论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据预处理</title>
    <link href="/2023/06/18/%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86/"/>
    <url>/2023/06/18/%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="离散程度度量"><a href="#离散程度度量" class="headerlink" title="离散程度度量"></a>离散程度度量</h1><h2 id="方差和标准差"><a href="#方差和标准差" class="headerlink" title="方差和标准差"></a>方差和标准差</h2><h2 id="正态分布函数曲线"><a href="#正态分布函数曲线" class="headerlink" title="正态分布函数曲线"></a>正态分布函数曲线</h2><h2 id="极差"><a href="#极差" class="headerlink" title="极差"></a>极差</h2><h2 id="百分位数"><a href="#百分位数" class="headerlink" title="百分位数"></a>百分位数</h2><h2 id="四分位数"><a href="#四分位数" class="headerlink" title="四分位数"></a>四分位数</h2><p>Q1 (25th percentile), Q3 (75th percentile)</p><h2 id="中间四分位数极差"><a href="#中间四分位数极差" class="headerlink" title="中间四分位数极差"></a>中间四分位数极差</h2><p>IQR &#x3D; Q3 – Q1 </p><h2 id="孤立点"><a href="#孤立点" class="headerlink" title="孤立点"></a>孤立点</h2><p>挑出落在至少高于第三个四分位数或低于第一个四分位数<strong>1.5×IQR</strong> 处的值</p><h2 id="盒图"><a href="#盒图" class="headerlink" title="盒图"></a>盒图</h2><h2 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a>直方图</h2><h2 id="分位数图"><a href="#分位数图" class="headerlink" title="分位数图"></a>分位数图</h2><h2 id="散布图"><a href="#散布图" class="headerlink" title="散布图"></a>散布图</h2><h2 id="局部回归曲线"><a href="#局部回归曲线" class="headerlink" title="局部回归曲线"></a>局部回归曲线</h2><h1 id="缺失值处理"><a href="#缺失值处理" class="headerlink" title="缺失值处理"></a>缺失值处理</h1><h2 id="删除法"><a href="#删除法" class="headerlink" title="删除法"></a>删除法</h2><h3 id="删除样本"><a href="#删除样本" class="headerlink" title="删除样本"></a>删除样本</h3><h3 id="删除特征"><a href="#删除特征" class="headerlink" title="删除特征"></a>删除特征</h3><h2 id="填补法"><a href="#填补法" class="headerlink" title="填补法"></a>填补法</h2><h3 id="均值填补"><a href="#均值填补" class="headerlink" title="均值填补"></a>均值填补</h3><p>连续性特征，采用<strong>平均值</strong>填补<br>离散型特征，使用<strong>众数</strong>填补</p><h3 id="随机填补"><a href="#随机填补" class="headerlink" title="随机填补"></a>随机填补</h3><h4 id="贝叶斯Boostrap方法"><a href="#贝叶斯Boostrap方法" class="headerlink" title="贝叶斯Boostrap方法"></a>贝叶斯Boostrap方法</h4><p>假设数据集有 n 个样本，某特征 f 存在 k 个非缺失值和  (n−k) 个缺失值，使用贝叶斯Bootstrap方法进行缺失值填补共有两步：<br><strong>第一步</strong>：从均匀分布 U(0, 1)中随机抽取 k−1个随机数，并进行升序排序记为{0, a_1,a_2, …,a_k−1, 1}；<br><strong>第二步</strong>：对 (n−k) 个缺失值，分别从非缺失值 {f_1, f_2,… , f_k} 中以概率 a_1,a_2−a_1, …,1−a_k−1采样一个值进行填补.</p><h4 id="近似贝叶斯Boostrap方法"><a href="#近似贝叶斯Boostrap方法" class="headerlink" title="近似贝叶斯Boostrap方法"></a>近似贝叶斯Boostrap方法</h4><h3 id="基于模型的填补"><a href="#基于模型的填补" class="headerlink" title="基于模型的填补"></a>基于模型的填补</h3><p>基于模型的方法将缺失特征 f 作为预测目标. 将数据集中其他特征或其子集作为输入特征，通过特征f的非缺失值构造训练集，训练分类或回归模型. 然后使用构建的模型来预测特征f的缺失值. </p><h3 id="哑变量方法"><a href="#哑变量方法" class="headerlink" title="哑变量方法"></a>哑变量方法</h3><p>对于离散型特征，如果存在缺失值，可以将缺失值作为一个单独的取值进行处理，这种方法称为哑变量方法.<br>例如学生信息数据集中，将”性别”特征的缺失值作为一个特殊的取值”unknown”，表示性别未知. 此时认为”性别”特征包含”F”、”M”和”unknown”三个不同取值. </p><h1 id="数据转换与编码"><a href="#数据转换与编码" class="headerlink" title="数据转换与编码"></a>数据转换与编码</h1><h2 id="数据的标准化"><a href="#数据的标准化" class="headerlink" title="数据的标准化"></a>数据的标准化</h2><h3 id="0-1标准化"><a href="#0-1标准化" class="headerlink" title="0-1标准化"></a>0-1标准化</h3><p>适用范围：<br>    0-1标准化适用于需要将数据简单地变换映射到某 一区间中，但其不足之处在于当有新数据加入时，可能会导致数据系列中的最大值或最小值发生变化，此时便需要重新定义最大值、最小值。</p><h3 id="小数定标标准化"><a href="#小数定标标准化" class="headerlink" title="小数定标标准化"></a>小数定标标准化</h3><h3 id="Z-score-标准化"><a href="#Z-score-标准化" class="headerlink" title="Z-score 标准化"></a>Z-score 标准化</h3><h3 id="Logistic标准化"><a href="#Logistic标准化" class="headerlink" title="Logistic标准化"></a>Logistic标准化</h3><h3 id="各种标准化的优缺点"><a href="#各种标准化的优缺点" class="headerlink" title="各种标准化的优缺点"></a>各种标准化的优缺点</h3><h2 id="数据的编码"><a href="#数据的编码" class="headerlink" title="数据的编码"></a>数据的编码</h2><h3 id="数字编码"><a href="#数字编码" class="headerlink" title="数字编码"></a>数字编码</h3><h3 id="One-hot编码"><a href="#One-hot编码" class="headerlink" title="One-hot编码"></a>One-hot编码</h3><h3 id="哑变量编码"><a href="#哑变量编码" class="headerlink" title="哑变量编码"></a>哑变量编码</h3><h1 id="数据的离散化"><a href="#数据的离散化" class="headerlink" title="数据的离散化"></a>数据的离散化</h1><h3 id="离散化概述"><a href="#离散化概述" class="headerlink" title="离散化概述"></a>离散化概述</h3><h3 id="离散化示例"><a href="#离散化示例" class="headerlink" title="离散化示例"></a>离散化示例</h3><h3 id="离散化步骤"><a href="#离散化步骤" class="headerlink" title="离散化步骤"></a>离散化步骤</h3><h3 id="离散化分类"><a href="#离散化分类" class="headerlink" title="离散化分类"></a>离散化分类</h3><h4 id="等距离散化"><a href="#等距离散化" class="headerlink" title="等距离散化"></a>等距离散化</h4><h4 id="等频离散化"><a href="#等频离散化" class="headerlink" title="等频离散化"></a>等频离散化</h4><h4 id="聚类离散化"><a href="#聚类离散化" class="headerlink" title="聚类离散化"></a>聚类离散化</h4><h4 id="信息增益离散化"><a href="#信息增益离散化" class="headerlink" title="信息增益离散化"></a>信息增益离散化</h4><p><strong>自顶向下的分裂策略</strong></p><p>步骤：</p><h4 id="卡方离散化"><a href="#卡方离散化" class="headerlink" title="卡方离散化"></a>卡方离散化</h4><p><strong>自底向上的合并策略</strong></p><h5 id="ChiMerge方法"><a href="#ChiMerge方法" class="headerlink" title="ChiMerge方法"></a>ChiMerge方法</h5><h4 id="类别属性依赖最大化（CAIM）离散化"><a href="#类别属性依赖最大化（CAIM）离散化" class="headerlink" title="类别属性依赖最大化（CAIM）离散化"></a>类别属性依赖最大化（CAIM）离散化</h4><h3 id="离散化总结"><a href="#离散化总结" class="headerlink" title="离散化总结"></a>离散化总结</h3><h1 id="降维"><a href="#降维" class="headerlink" title="降维"></a>降维</h1><p><strong>目的</strong><br>特征选择能剔除不相关(irrelevant)或冗余(redundant )的特征，从而达到减少特征个数，简化模型，提高模型精确度，减少运行时间的目的<br><strong>两种情况</strong></p><ol><li>特征与特征之间互不相关</li><li>特征之间相互依赖<br><strong>分类</strong></li><li>特征选择</li></ol><ul><li>向前搜索</li><li>向后搜索</li><li>双向搜索</li></ul><ol><li>特征提取</li></ol><ul><li>线性：主成分分析，线性判别分析</li><li>非线性：多维尺度变换，局部线行嵌入<br><strong>策略</strong></li></ul><ol><li>过滤式</li><li>封装式</li><li>嵌入式</li></ol><h3 id="PCA算法"><a href="#PCA算法" class="headerlink" title="PCA算法"></a>PCA算法</h3><h3 id="LDA算法"><a href="#LDA算法" class="headerlink" title="LDA算法"></a>LDA算法</h3><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><h1 id="数据脱敏"><a href="#数据脱敏" class="headerlink" title="数据脱敏"></a>数据脱敏</h1><p><strong>原则</strong></p><ul><li>单向性</li><li>无残留</li><li>易于实现</li></ul><h1 id="数据规约"><a href="#数据规约" class="headerlink" title="数据规约"></a>数据规约</h1><h1 id="数据标注"><a href="#数据标注" class="headerlink" title="数据标注"></a>数据标注</h1>]]></content>
    
    
    <categories>
      
      <category>数据科学导论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据科学导论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>My New Post</title>
    <link href="/2023/06/18/My-New-Post/"/>
    <url>/2023/06/18/My-New-Post/</url>
    
    <content type="html"><![CDATA[<h1 id="我的第一篇博客文章"><a href="#我的第一篇博客文章" class="headerlink" title="我的第一篇博客文章"></a>我的第一篇博客文章</h1><p>希望能成功运行css，js样式</p><p><img src="/img/photo1.png" alt="奇思科技"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/06/18/hello-world/"/>
    <url>/2023/06/18/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><h3 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h3><p>删除<code>_posts</code>目录下的<code>.md</code>文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo clean<br>$ hexo g<br>$ hexo d<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
